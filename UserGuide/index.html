<!DOCTYPE html>
<html lang="en" data-bs-theme="auto">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>User Guide - RomWBW Documentation V3.6</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" disabled>
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">RomWBW Documentation V3.6</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../Introduction/" class="nav-link">Introduction</a>
                            </li>
                            <li class="nav-item">
                                <a href="./" class="nav-link active" aria-current="page">User Guide</a>
                            </li>
                            <li class="nav-item">
                                <a href="../SystemGuide/" class="nav-link">System Guide</a>
                            </li>
                            <li class="nav-item">
                                <a href="../Applications/" class="nav-link">Applications</a>
                            </li>
                            <li class="nav-item">
                                <a href="../Catalog/" class="nav-link">Catalog</a>
                            </li>
                            <li class="nav-item">
                                <a href="../Hardware/" class="nav-link">Hardware</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../Introduction/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../SystemGuide/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="https://github.com/wwarthen/RomWBW" class="nav-link"><i class="fa-brands fa-github"></i> GitHub</a>
                            </li>
                            <li class="nav-item dropdown">
                              <button id="theme-menu" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme" class="nav-link dropdown-toggle">
                                <i class="fa-solid fa-circle-half-stroke fa-fw"></i>
                                <span class="d-lg-none ms-2">Toggle theme</span>
                              </button>
                              <ul class="dropdown-menu dropdown-menu-end">
                                <li>
                                  <button class="dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                                    <i class="fa-solid fa-sun fa-fw"></i>
                                    <span class="ms-2">Light</span>
                                    <i class="fa-solid fa-check ms-auto d-none"></i>
                                  </button>
                                </li>
                                <li>
                                  <button class="dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                                    <i class="fa-solid fa-moon fa-fw"></i>
                                    <span class="ms-2">Dark</span>
                                    <i class="fa-solid fa-check ms-auto d-none"></i>
                                  </button>
                                </li>
                                <li>
                                  <button class="dropdown-item d-flex align-items-center" data-bs-theme-value="auto" aria-pressed="true">
                                    <i class="fa-solid fa-circle-half-stroke fa-fw"></i>
                                    <span class="ms-2">Auto</span>
                                    <i class="fa-solid fa-check ms-auto"></i>
                                  </button>
                                </li>
                              </ul>
                            </li>
                    </ul>
                </div>
            </div>
        </div>
        <script src="../js/darkmode.js"></script>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            
            
            <li class="nav-item" data-bs-level="1"><a href="#getting-started" class="nav-link">Getting Started</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#installation" class="nav-link">Installation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#system-startup" class="nav-link">System Startup</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#core-system-information" class="nav-link">Core System Information</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#hardware-discovery" class="nav-link">Hardware Discovery</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#device-unit-assignments" class="nav-link">Device Unit Assignments</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#startup-example" class="nav-link">Startup Example</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#boot-loader-operation" class="nav-link">Boot Loader Operation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#starting-applications-from-rom" class="nav-link">Starting Applications from ROM</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#starting-operating-systems-from-disk" class="nav-link">Starting Operating Systems from Disk</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#auto-submit-batch-files" class="nav-link">Auto-Submit Batch Files</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#system-management" class="nav-link">System Management</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#listing-device-inventory" class="nav-link">Listing Device Inventory</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#rebooting-the-system" class="nav-link">Rebooting the System</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#setting-nvram-options" class="nav-link">Setting NVRAM Options</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#changing-console-and-console-speed" class="nav-link">Changing Console and Console Speed</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#hbios-diagnostic-verbosity" class="nav-link">HBIOS Diagnostic Verbosity</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#console-takeover" class="nav-link">Console Takeover</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#front-panel" class="nav-link">Front Panel</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#disk-management" class="nav-link">Disk Management</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#key-terminologyconcepts" class="nav-link">Key Terminology/Concepts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#startup-hardware-discovery" class="nav-link">Startup Hardware Discovery</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#drive-letter-assignment" class="nav-link">Drive Letter Assignment</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#default-drive-letters" class="nav-link">Default Drive Letters</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#assign-drive-letters" class="nav-link">Assign Drive Letters</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#disk-operationscommands" class="nav-link">Disk Operations/Commands</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#preparing-media-for-first-use" class="nav-link">Preparing Media for First Use</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#clearing-formatting-drives" class="nav-link">Clearing (Formatting) Drives</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#checking-disk-layout" class="nav-link">Checking Disk Layout</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#disk-types" class="nav-link">Disk Types</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#ram-rom-disks" class="nav-link">RAM &amp; ROM Disks</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#floppy-disks" class="nav-link">Floppy Disks</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#hard-disks" class="nav-link">Hard Disks</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#hard-disk-layouts" class="nav-link">Hard Disk Layouts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#hard-disk-slices" class="nav-link">Hard Disk Slices</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#slice-assignment" class="nav-link">Slice Assignment</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#hard-disk-capacity" class="nav-link">Hard Disk Capacity</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#disk-preparation" class="nav-link">Disk Preparation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#floppy-disk-formatting" class="nav-link">Floppy Disk Formatting</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#hard-disk-preparation" class="nav-link">Hard Disk Preparation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#partition-setup" class="nav-link">Partition Setup</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#slice-initialization" class="nav-link">Slice Initialization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#post-disk-preparation" class="nav-link">Post Disk Preparation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#making-a-disk-bootable" class="nav-link">Making a Disk Bootable</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#copying-system-files" class="nav-link">Copying System Files</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#disk-images" class="nav-link">Disk Images</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#floppy-disk-images" class="nav-link">Floppy Disk Images</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#hard-disk-images" class="nav-link">Hard Disk Images</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#standard-hard-disk-layout" class="nav-link">Standard Hard Disk Layout</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#combo-hard-disk-image" class="nav-link">Combo Hard Disk Image</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#custom-hard-disk-image" class="nav-link">Custom Hard Disk Image</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#writing-hard-disk-images" class="nav-link">Writing Hard Disk Images</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#writing-hard-disk-slices" class="nav-link">Writing Hard Disk Slices</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#operating-systems" class="nav-link">Operating Systems</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#digital-research-cpm-22" class="nav-link">Digital Research CP/M 2.2</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#z-system" class="nav-link">Z-System</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#nzcom-automatic-z-system" class="nav-link">NZCOM Automatic Z-System</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#digital-research-cpm-3" class="nav-link">Digital Research CP/M 3</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#z3plus-z-system-for-cpm-plus" class="nav-link">Z3PLUS Z-System for CP/M-Plus</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#zpm3" class="nav-link">ZPM3</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#qpm" class="nav-link">QP/M</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#ucsd-p-system" class="nav-link">UCSD p-System</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#freertos" class="nav-link">FreeRTOS</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#fuzix" class="nav-link">Fuzix</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#custom-applications" class="nav-link">Custom Applications</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#real-time-clock-datetime-stamping" class="nav-link">Real Time Clock &amp; Date/Time Stamping</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#datetime-utilities" class="nav-link">Date/Time Utilities</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#wdate-utility" class="nav-link">WDATE Utility</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#rtc-utility" class="nav-link">RTC Utility</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#testclok-utility" class="nav-link">TESTCLOK Utility</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#datetime-file-stamping" class="nav-link">Date/Time File Stamping</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#datestamper" class="nav-link">DateStamper</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#p2dos-cpm-plus-compatible" class="nav-link">P2DOS (CP/M Plus compatible)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#nzt" class="nav-link">NZT</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#additional-notes" class="nav-link">Additional Notes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#timezone" class="nav-link">Timezone</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#cpnet-networking" class="nav-link">CP/NET Networking</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#cpnet-client-setup" class="nav-link">CP/NET Client Setup</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#cpnet-sever-setup" class="nav-link">CP/NET Sever Setup</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#cpnet-usage" class="nav-link">CP/NET Usage</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#network-boot" class="nav-link">Network Boot</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#transferring-files" class="nav-link">Transferring Files</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#serial-port-transfers" class="nav-link">Serial Port Transfers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#disk-image-transfers" class="nav-link">Disk Image Transfers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#fat-filesystem-transfers" class="nav-link">FAT Filesystem Transfers</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="3"><a href="#fat-filesystem-preparation" class="nav-link">FAT Filesystem Preparation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="3"><a href="#fat-application-usage" class="nav-link">FAT Application Usage</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#customizing-romwbw" class="nav-link">Customizing RomWBW</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#startup-command-processing" class="nav-link">Startup Command Processing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#nvram-configuration" class="nav-link">NVRAM Configuration</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#rom-customization" class="nav-link">ROM Customization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#rom-user-application" class="nav-link">ROM User Application</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#upgrading" class="nav-link">Upgrading</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#application-boot" class="nav-link">Application Boot</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#upgrading-via-flash-utility" class="nav-link">Upgrading via Flash Utility</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#upgrading-via-xmodem-flash-updater" class="nav-link">Upgrading via XModem Flash Updater</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#post-upgrade-update" class="nav-link">Post Upgrade Update</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#system-update" class="nav-link">System Update</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<p><strong>RomWBW User Guide</strong> \
Version 3.6 \
Wayne Warthen  (<a href="mailto:wwarthen@gmail.com">wwarthen@gmail.com</a>) \
31 May 2025</p>
<h4 id="preface">Preface</h4>
<p>This document is a general usage guide for the RomWBW software and is
generally the best place to start with RomWBW.</p>
<p>On a personal note, I found this document very difficult to write.
Members of the retro-computing community have dramatically different
experiences, skill levels, and desires. I realize some readers will find
this document far too basic. Others will find it lacking in many areas.
I am doing my best and encourage you to provide constructive feedback.</p>
<h4 id="conventions-used">Conventions Used</h4>
<h5 id="size-suffixes">Size Suffixes</h5>
<p>Within the documentation and in RomWBW in general, the use of size
suffixes KB, MB, GB, and TB refer to the binary variant as shown below.
The modern suffixes (KiB, MiB, etc.) are not used here because they were
not prevalent during the time that the RomWBW OSes were used. This keeps
all of RomWBW and associated applications consistent.</p>
<table>
<thead>
<tr>
<th>Suffix</th>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>KB</td>
<td>1024</td>
<td>1,024 bytes</td>
</tr>
<tr>
<td>MB</td>
<td>1024<sup>2</sup></td>
<td>1,048,576 bytes</td>
</tr>
<tr>
<td>GB</td>
<td>1024<sup>3</sup></td>
<td>1,073,741,824 bytes</td>
</tr>
<tr>
<td>TB</td>
<td>1024<sup>4</sup></td>
<td>1,099,511,627,776 bytes</td>
</tr>
</tbody>
</table>
<h5 id="links-and-urls">Links and URLs</h5>
<p>Many of the references in the documentation to Internet addresses (URLs)
do not provide the address in the text. However, these links are
embedded and “clickable” within the documents. Your PDF viewer should
highlight these links in some manner (typically an alternate color or an
underline).</p>
<h1 id="getting-started">Getting Started</h1>
<h2 id="installation">Installation</h2>
<p>In general, installation of RomWBW on your platform is very simple. You
just need to program your ROM with the correct ROM image from the RomWBW
distribution. Subsequently, you can write disk images on your disk
drives (IDE disk, CF Card, SD Card, etc.) which then provides even more
functionality.</p>
<p>Depending on how you got your hardware, you may have already been
provided with a pre-programmed ROM chip. If so, use that initially.
Otherwise, you will need to use a ROM programmer to initially program
your ROM chip. Please refer to the documentation that came with your ROM
programmer for more information.</p>
<p>The fully-built distribution releases are available on the <a href="https://github.com/wwarthen/RomWBW/releases">RomWBW
Releases Page</a>
(<a href="https://github.com/wwarthen/RomWBW/releases">https://github.com/wwarthen/RomWBW/releases</a>) of the repository.</p>
<p>The distribution is a .zip archive. After downloading it to a working
directory on your modern computer (Windows/Linux/Mac) use any zip tool
to extract the contents of the archive.</p>
<p>The Binary directory of the distribution contains the pre-built ROM
images.<br />
Refer to <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Hardware.pdf">RomWBW
Hardware</a>
to identify the correct ROM image for your system.</p>
<p>A complete list of the currently supported platforms is found in <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Hardware.pdf">RomWBW
Hardware</a>.
You must burn the correct ROM image that matches your hardware</p>
<p>Once you have a running RomWBW system, you can generally update your ROM
to a newer version in-situ with the included ROM Flashing tool (Will
Sowerbutts’ FLASH application) as described in the
<a href="#upgrading">Upgrading</a> chapter of this document.</p>
<h2 id="system-startup">System Startup</h2>
<p>Initially, don’t worry about trying to write a disk image to any disk
(or CF/SD/USB) devices you have. This will be covered later. You will be
able to boot and check out your system with just the ROM.</p>
<p>Connect a serial terminal or computer with terminal emulation software
to the primary serial port of your CPU board. You may need to refer to
your hardware provider’s documentation for details. A null-modem
connection may be required. Set the baud rate as indicated in <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Hardware.pdf">RomWBW
Hardware</a>.
Set the line characteristics to 8 data bits, 1 stop bit, no parity, and
no flow control. If possible, select ANSI or VT-100 terminal emulation.
Hardware flow control is not required for terminal operation, but may be
necessary for <a href="#serial-port-transfers">Serial Port Transfers</a>.</p>
<p>RomWBW will automatically attempt to detect and support typical add-on
components for each of the systems supported. More information on the
required system configuration and optional supported components for each
ROM is found in <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Hardware.pdf">RomWBW
Hardware</a>
.</p>
<p>Upon power-up, your terminal should display a sign-on banner within 2
seconds followed by hardware inventory and discovery information. When
hardware initialization is completed, a boot loader prompt allows you to
choose a ROM-based operating system, system monitor, application, or
boot from a disk device.</p>
<h3 id="core-system-information">Core System Information</h3>
<p>During startup, the first few lines of information displayed provide the
most basic information on your system. In the example above, these lines
are the Core System Information:</p>
<pre><code>RomWBW HBIOS v3.5, 2025-03-01

RCBus [RCZ80_kio] Z80 @ 7.372MHz
0 MEM W/S, 1 I/O W/S, INT MODE 2, Z2 MMU
512KB ROM, 512KB RAM
ROM VERIFY: 00 00 00 00 PASS
</code></pre>
<p>The first line is a version identification banner for RomWBW. After that
you see a group of 4 lines describing the basic system. In this example,
the platform is the RCBus running a configuration named “RCZ80_kio”. The
CPU is a Z80 with a current clock speed of 7.372 MHz. There are 0 memory
wait states and 1 I/O wait state. Z80 interrupt mode 2 is active and the
bank memory manager is type “Z2” which is standard for RCBus. The system
has 512KB of ROM total and 512KB of RAM total. Finally, a verification
of the checksums of the critical ROM banks is shown (all 4 should be
00).</p>
<p>RomWBW attempts to detect the running configuration of the system at
startup. Depending on your hardware, there may be inaccuracies in this
section. For example, in some cases the CPU clock speed is assumed
rather than actually measured. This does not generally affect the
operation of your system. If you want to correct any of the information
displayed, you can create a custom ROM which is described later.</p>
<h3 id="hardware-discovery">Hardware Discovery</h3>
<p>The next set of messages during boot show the hardware devices as they
are probed and initially configured. In the example above, these lines
are:</p>
<pre><code>KIO: IO=0x80 ENABLED
CTC: IO=0x84 TIMER MODE=TIM16
AY: MODE=RCZ80 IO=0xD8 NOT PRESENT
SIO0: IO=0x89 SIO MODE=115200,8,N,1
SIO1: IO=0x8B SIO MODE=115200,8,N,1
DSRTC: MODE=STD IO=0xC0 NOT PRESENT
MD: UNITS=2 ROMDISK=384KB RAMDISK=256KB
FD: MODE=RCWDC IO=0x50 NOT PRESENT
IDE: IO=0x10 MODE=RC
IDE0: NO MEDIA
IDE1: NO MEDIA
PPIDE: IO=0x20
PPIDE0: LBA BLOCKS=0x00773800 SIZE=3815MB
PPIDE1: NO MEDIA
</code></pre>
<p>What you see will depend on your specific system and ROM, but should
match the hardware present in your system. Each device has a tag that
precedes the colon. This tag identifies the driver and instance of each
device. For example, the tag “SIO0:” refers to the SIO serial port
driver and specifically the first channel. The “SIO1:” tag refers to the
second channel.</p>
<p>In many cases you will see IO=0xNN in the data following the tag. This
identifies the base I/O port address of the hardware device and is
useful for identifying hardware conflicts.</p>
<p>Note that you may see some lines indicating that the associated hardware
is not present. Above, you can see that the FD driver did not find a
floppy interface. Lines such as these are completely normal when your
system does not have the associated hardware.</p>
<p>Finally, be aware that all ROMs are configured to identify specific
hardware devices at specific port addresses. If you add hardware to your
system that is not automatically identified, you may need to build a
custom ROM to add support for it. Building a custom ROM is covered
later.</p>
<p><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Hardware.pdf">RomWBW
Hardware</a>
contains a list of the RomWBW hardware devices which may help you
identify the hardware discovered in your system.</p>
<h3 id="device-unit-assignments">Device Unit Assignments</h3>
<p>In order to support a wide variety of hardware, RomWBW HBIOS uses a
modular approach to implementing device drivers and presenting devices
to an operating system. In general, all devices are classified as one of
the following:</p>
<ul>
<li>Disk (RAM/ROM Disk, Floppy Disk, Hard Disk, CF Card, SD Card, etc.)</li>
<li>Character (Serial Ports, Parallel Ports, etc.)</li>
<li>Video (Video Display/Keyboard Interfaces)</li>
<li>Sound (Audio Playback Devices)</li>
<li>RTC/NVRAM (Real Time Clock, Non-volatile RAM)</li>
<li>System (Internal Services, e.g. Timer, DMA, etc.)</li>
</ul>
<p>HBIOS uses the concept of unit numbers to present a generic set of
hardware devices to the operating system. As an example, a typical
system might have a ROM Disk, RAM Disk, Floppy Drives, and Disk Drives.
All of these are considered disk devices and are presented to the
operating system as generic block devices. This means that each
operating system does not need to embed code to interact directly with
all of the different hardware devices – RomWBW takes care of that.</p>
<p>In the final group of startup messages, a device unit summary table is
displayed so that you can see how the actual hardware devices have been
mapped to unit numbers during startup.</p>
<pre><code>Unit        Device      Type              Capacity/Mode
----------  ----------  ----------------  --------------------
Char 0      UART0:      RS-232            38400,8,N,1
Char 1      UART1:      RS-232            38400,8,N,1
Disk 0      MD1:        RAM Disk          384KB,LBA
Disk 1      MD0:        ROM Disk          384KB,LBA
Disk 2      FD0:        Floppy Disk       3.5",DS/HD,CHS
Disk 3      FD1:        Floppy Disk       3.5",DS/HD,CHS
Disk 4      IDE0:       CompactFlash      3815MB,LBA
Disk 5      IDE1:       Hard Disk         --
Disk 6      PRPSD0:     SD Card           1886MB,LBA
Video 0     CVDU0:      CRT               Text,80x25
</code></pre>
<p>In this example, you can see that the system has a total of 7 Disk Units
numbered 0-6. There are also 2 Character Units and 1 Video Unit. The
table shows the unit numbers assigned to each of the devices. Notice how
the unit numbers are assigned sequentially regardless of the specific
device.</p>
<p>There may or may not be media in the disk devices listed. For example,
the floppy disk devices (Disk Units 2 &amp; 3) may not have a floppy in the
drive. Also note that Disk Unit 4 shows a disk capacity, but Disk Unit 5
does not. This is because the PPIDE interface of the system supports up
to two drives, but there is only one actual drive attached. A unit
number is assigned to all available devices regardless of whether they
have actual media installed at boot time.</p>
<p>Note that Character Unit 0 is the initial system console unless modified
in a customized ROM image.</p>
<p>If your system has an RTC/NVRAM device, it will not be listed in the
unit summary table. Since only a single RTC/NVRAM device can exist in
one system, unit numbers are not required nor used for this type of
device. Also, System devices are not listed because they are entirely
internal to RomWBW.</p>
<h2 id="startup-example">Startup Example</h2>
<p>Here is an example of a fairly typical startup. Your system will have
different devices and configuration, but the startup should look
similar.</p>
<pre><code>RomWBW HBIOS v3.5, 2025-03-01

RCBus [RCZ80_kio] Z80 @ 7.372MHz
0 MEM W/S, 1 I/O W/S, INT MODE 2, Z2 MMU
512KB ROM, 512KB RAM
ROM VERIFY: 00 00 00 00 PASS

KIO: IO=0x80 ENABLED
CTC: IO=0x84 TIMER MODE=TIM16
AY: MODE=RCZ80 IO=0xD8 NOT PRESENT
SIO0: IO=0x89 SIO MODE=115200,8,N,1
SIO1: IO=0x8B SIO MODE=115200,8,N,1
DSRTC: MODE=STD IO=0xC0 NOT PRESENT
MD: UNITS=2 ROMDISK=384KB RAMDISK=256KB
FD: MODE=RCWDC IO=0x50 NOT PRESENT
IDE: IO=0x10 MODE=RC
IDE0: NO MEDIA
IDE1: NO MEDIA
PPIDE: IO=0x20
PPIDE0: LBA BLOCKS=0x00773800 SIZE=3815MB
PPIDE1: NO MEDIA

Unit        Device      Type              Capacity/Mode
----------  ----------  ----------------  --------------------
Char 0      SIO0:       RS-232            115200,8,N,1
Char 1      SIO1:       RS-232            115200,8,N,1
Disk 0      MD0:        RAM Disk          256KB,LBA
Disk 1      MD1:        ROM Disk          384KB,LBA
Disk 2      IDE0:       Hard Disk         --
Disk 3      IDE1:       Hard Disk         --
Disk 4      PPIDE0:     CompactFlash      3815MB,LBA
Disk 5      PPIDE1:     Hard Disk         --
</code></pre>
<p>If your system completes the ROM-based boot process successfully, you
should see the RomWBW Boot Loader prompt. For example:</p>
<pre><code>RCBus [RCZ80_kio] Boot Loader

Boot [H=Help]:
</code></pre>
<p>If you get to this prompt, your system has completed the boot process
and is ready to accept commands. Note that the Boot Loader is not an
operating system or application. It is essentially the point where you
choose which operating system or application you want RomWBW to execute.</p>
<p>The Boot Loader is explained in detail in the next section. For now, you
can try a few simple commands to confirm that you can interact with the
system.</p>
<p>At the Boot Loader prompt, you can type <code>H &lt;enter&gt;</code> for help. You can
type <code>L &lt;enter&gt;</code> to list the available built-in ROM applications. If
your terminal supports ANSI escape sequences, you can try the ‘P’
command to play a simple on-screen game. Instructions for the game are
found in <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>.</p>
<p>If all of this seems fine, your ROM has been successfully programmed.</p>
<h1 id="boot-loader-operation">Boot Loader Operation</h1>
<p>Once your system has completed the startup process, it presents a Boot
Loader command prompt. The purpose of the Boot Loader is to select and
launch a desired application or operating system. It also has the
ability to configure some aspects of system operation.</p>
<p>After starting your system, following the hardware initialization, you
will see the RomWBW Boot Loader prompt. Below is an example. Note that
the text preceding “Boot Loader” will vary and identifies your specific
system and configuration.</p>
<pre><code>Mark IV [MK4_wbw] Boot Loader

Boot [H=Help]:
</code></pre>
<p>From the Boot Loader prompt, you can enter commands to select and launch
any of the RomWBW operating systems or ROM applications. It also allows
you to manage some basic settings of the system. To enter a command,
just enter the command followed by <strong><em>\&lt;enter&gt;</em></strong>.</p>
<p>For example, typing <code>H&lt;enter&gt;</code> will display a short command summary:</p>
<pre><code>Boot [H=Help]: h

  L           - List ROM Applications
  D           - Device Inventory
  R           - Reboot System
  W           - RomWBW Configure
  I &lt;u&gt; [&lt;c&gt;] - Set Console Interface/Baud Rate
  V [&lt;n&gt;]     - View/Set HBIOS Diagnostic Verbosity
  &lt;u&gt;[.&lt;s&gt;]   - Boot Disk Unit/Slice
</code></pre>
<p>Likewise the <code>L</code> command (List ROM Applications) will display the list
of ROM Applications that you can launch right from the Boot Loader:</p>
<pre><code>Boot [H=Help]: L

ROM Applications:

  M: Monitor
  Z: Z-System
  C: CP/M 2.2
  F: Forth
  B: BASIC
  T: Tasty BASIC
  P: Play a Game
  N: Network Boot
  X: XModem Flash Updater
  U: User App
</code></pre>
<p>A more complete description of these options is found below in <a href="#system-management">System
Management</a>.</p>
<h2 id="starting-applications-from-rom">Starting Applications from ROM</h2>
<p>To start a ROM application you just enter the corresponding letter at
the Boot Loader prompt. In the following example, we launch the built-in
Microsoft BASIC interpreter. From within BASIC, we use the <code>BYE</code> command
to return to the Boot Loader:</p>
<pre><code>Boot [H=Help]: b

Loading BASIC...
Memory top?
Z80 BASIC Ver 4.7b
Copyright (C) 1978 by Microsoft
55603 Bytes free
Ok
bye


Mark IV [MK4_wbw] Boot Loader

Boot [H=Help]:
</code></pre>
<p>The following ROM applications and OSes are available at the boot loader
prompt:</p>
<table>
<thead>
<tr>
<th><strong>Application</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Monitor</td>
<td>Z80 system debug monitor w/ Intel Hex loader</td>
</tr>
<tr>
<td>CP/M 2.2</td>
<td>Digital Research CP/M 2.2 OS</td>
</tr>
<tr>
<td>Z-System</td>
<td>ZSDOS 1.1 w/ ZCPR 1 (Enhanced CP/M compatible OS)</td>
</tr>
<tr>
<td>Forth</td>
<td>Brad Rodriguez’s ANSI compatible Forth language</td>
</tr>
<tr>
<td>BASIC</td>
<td>Microsoft ROM BASIC</td>
</tr>
<tr>
<td>Tasty BASIC</td>
<td>Dimitri Theuling’s Tiny BASIC implementation</td>
</tr>
<tr>
<td>Play</td>
<td>A simple video game (requires ANSI terminal emulation)</td>
</tr>
<tr>
<td>Network Boot</td>
<td>Boot system via Wiznet MT011 device</td>
</tr>
<tr>
<td>Flash Update</td>
<td>Upload and flash a new ROMWBW image using xmodem</td>
</tr>
<tr>
<td>User App</td>
<td>User written application placeholder</td>
</tr>
</tbody>
</table>
<p>The User App is provided as a way to access a custom written ROM module.
In the pre-built ROMs, selecting User App will just return to the Boot
Loader menu. If you are interested in creating a custom application to
run here, review the “usrrom.asm” file in the Source/HBIOS folder of the
distribution.</p>
<p>Each of the ROM Applications is documented in <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>.
Some of the applications (such as BASIC) also have their own independent
manual in the Doc directory of the distribution. The OSes included in
the ROM (CP/M 2.2 &amp; Z-System) are described in the Operating Systems
chapter of this document.</p>
<p>In general, the command to exit any of these applications and restart
the system is <code>BYE</code>. The exceptions are the Monitor which uses <code>X</code> and
Play which uses <code>Q</code>.</p>
<p><strong>NOTE:</strong> Of the ROM Applications, only the operating systems (CP/M and
Z-System) have the ability to interact with disk drives. So, other than
these 2 OSes, the ROM Applications do <strong>not</strong> have any way to save or
load data from peristent/disk storage. For example, if you launch BASIC
from the Boot Loader, you will not be able to save or load your
programs. You will need to start an operating system first and then run
BASIC in order to save or load programs.</p>
<p>Two of the ROM Applications are, in fact, complete operating systems.
Specifically, “CP/M 2.2” and “Z-System” are provided so that you can
actually start either operating system directly from your ROM. This
technique is useful when:</p>
<ul>
<li>You don’t yet have any real disk drives in your system</li>
<li>You want to setup real disk drives for the first time</li>
<li>You are upgrading your system and need to upgrade your real disk
  drives</li>
</ul>
<p>The RAM disk and ROM disk drives will be available even if you have no
physical disk devices attached to your system.</p>
<p>Booting an operating system from ROM is not intended as a way to use
your operating system on a long-term basis. The ROM disk has only a
small subset of the operating system files. Additionally, you cannot
easily customize your ROM disk because you cannot write to it. For any
significant use of an operating system, you should boot directly to the
disk/slice that contains the complete operating system. This is
described in the next section.</p>
<h2 id="starting-operating-systems-from-disk">Starting Operating Systems from Disk</h2>
<p>In order to make use of the more sophisticated operating systems
available with RomWBW, you will need to boot an operating system from a
disk. Setting up disks is described in detail later. For now, we will
just go over the command line for performing this type of boot.</p>
<p>From the Boot Loader prompt, you can enter a number (<strong><em>\&lt;diskunit&gt;</em></strong>)
and optionally a dot followed by a second number (<strong><em>\&lt;slice&gt;</em></strong>). The
<strong><em>\&lt;disk unit&gt;</em></strong> unit number refers to a disk unit that was displayed
when the system was booted – essentially it specifies the specific
physical disk drive you want to boot. The <strong><em>\&lt;slice&gt;</em></strong> numbers refers
to a portion of the disk unit to boot. If no slice is specified, then it
is equivalent to booting from the first slice (slice 0). Disk units and
slices are described in more detail later.</p>
<p>Following this, you should see the operating system startup messages.
Your operating system prompt will typically be <code>A&gt;</code> and when you look at
the drive letter assignments, you should see that A: has been assigned
to the disk and slice you selected to boot.</p>
<p>If you receive the error message “Disk not bootable!”, you have either
failed to properly initialize the disk and slice requested or you have
selected an invalid/unavailable disk/slice.</p>
<p>The following example shows a disk boot into the first slice of disk
unit 4 which happens to be the CP/M 2.2 operating system on this disk.
This is accomplished by entering just the number ‘4’ and pressing
<strong><em>\&lt;enter&gt;</em></strong>.</p>
<pre><code>Boot [H=Help]: 4

Booting Disk Unit 4, Slice 0, Sector 0x00000800...

Volume "Unlabelled" [0xD000-0xFE00, entry @ 0xE600]...

CBIOS v3.1.1-pre.194 [WBW]

Formatting RAMDISK...

Configuring Drives...

        A:=IDE0:0
        B:=MD0:0
        C:=MD1:0
        D:=FD0:0
        E:=FD1:0
        F:=IDE0:1
        G:=IDE0:2
        H:=IDE0:3
        I:=PRPSD0:0
        J:=PRPSD0:1
        K:=PRPSD0:2
        L:=PRPSD0:3

        1081 Disk Buffer Bytes Free

CP/M-80 v2.2, 54.0K TPA

A&gt;
</code></pre>
<p>Notice that a list of drive letters and their assignments to RomWBW
devices and slices is displayed during the initialization of the
operating system.</p>
<p>Here is another example where we are booting disk unit 4, slice 3 which
is the CP/M 3 operating system on this disk:</p>
<pre><code>Boot [H=Help]: 4.3

Booting Disk Unit 4, Slice 3, Sector 0x0000C800...

Volume "Unlabelled" [0x0100-0x1000, entry @ 0x0100]...

CP/M V3.0 Loader
Copyright (C) 1998, Caldera Inc.

 BNKBIOS3 SPR  F600  0800
 BNKBIOS3 SPR  4500  3B00
 RESBDOS3 SPR  F000  0600
 BNKBDOS3 SPR  1700  2E00

 60K TPA

CP/M v3.0 [BANKED] for HBIOS v3.5

A&gt;
</code></pre>
<p>Some operating systems (such as CP/M 3 shown above) do not list the
drive assignments during initialization. In this case, you can use the
<code>ASSIGN</code> command to display the current assignments.</p>
<p>The Boot Loader simply launches whatever is in the disk unit/slice you
have specified. It does not know what operating system is at that
location. The layout of operating systems on disk media is described in
the <a href="#disk-images">Disk Images</a> section of this document.</p>
<h3 id="auto-submit-batch-files">Auto-Submit Batch Files</h3>
<p>All of the operating systems supplied with RomWBW have the ability to
execute a “batch” of commands by creating a batch submission file
containing the commands to be executed. The mechanism for running
commands automatically at startup varies by operating system. In some
cases, it was built into the original operating system. In other cases,
I have added this capability in the RomWBW BIOS of the operating system.</p>
<p>In all cases, the file containing the commands to run at startup must be
on the boot drive (A:). RomWBW automatically assigns A: to the disk
slice you choose to boot. Adding a startup command file to the ROM Disk
is not recommended because it would require customizing and building a
new ROM. Use of bootable disk slices is preferred since the startup
command files can be added/edited without any special system
customization.</p>
<p>Here is an overview for each operating system:</p>
<ul>
<li>
<p><strong>CP/M 2.2</strong> - Will run PROFILE.SUB as a SUBMIT file if it exists in
  A: at startup. Note that original CP/M 2.2 itself did not have this
  ability – it was added to the RomWBW CP/M 2.2 BIOS. The use of SUBMIT
  files is documented in Section 1.6.7 SUBMIT Command of the CPM Manual
  included in the Doc/CPM folder of the RomWBW distribution.</p>
</li>
<li>
<p><strong>Z-System (ZSDOS 1.1)</strong> - Will run run PROFILE.SUB as a SUBMIT file
  if it exists in A: at startup. Works exactly the same as CP/M 2.2. The
  original Z-System ZSDOS 1.1 did not have this ability – it was added
  to the RomWBW Z-System BIOS. The Z-System documentation does not cover
  the use of SUBMIT files – please refer to the CP/M 2.2 documentation.</p>
</li>
<li>
<p><strong>NZCOM</strong> - Will run the command STARTZCM at startup. This is normally
  an alias file, which you can edit using SALIAS. Please see Section 3.1
  Creating an Alias of the NZCOM Users Manual included in the Doc/CPM
  folder of the RomWBW distribution. Do not modify this file unless you
  fully understand the NZCOM boot process. Note that NZCOM itself is
  launched from ZSDOS via the included PROFILE.SUB file.</p>
</li>
<li>
<p><strong>CP/M 3</strong> - Will run PROFILE.SUB as a SUBMIT file if it exists in A:
  at startup. This mechanism is built into the CP/M 3 operating
  system.<br />
  Please see Section 4.5 Executing Multiple Commands and Section 5.2.74
  Executing the SUBMIT Command of the CPM3 Users Guide included in the
  Doc/CPM folder of the RomWBW distribution.</p>
</li>
<li>
<p><strong>Z3PLUS</strong> - Will run the command STARTZ3P at startup. This is
  normally an alias file, which you can edit using SALIAS. Please see
  Section 3.1 Creating an Alias of the Z3PLUS Users Manual included in
  the Doc/CPM folder of the RomWBW distribution. Do not modify this file
  unless you fully understand the Z3PLUS boot process. Note that Z3PLUS
  itself is launched from CP/M 3 via the included PROFILE.SUB file.</p>
</li>
<li>
<p><strong>ZPM3</strong> - Will run the command STARTZPM at startup. This is normally
  an alias file. You use SALIAS to edit such files. ZPM3 has no real
  documentation. The NZCOM documentation of STARTZCM is generally
  correct for ZPM3.</p>
</li>
</ul>
<p>Since RomWBW can utilize many disk slices, it is very easy to create
slices for specific workflows (editing, software development, games,
etc.). You can then just boot to the slice that is optimized for the
task you want to perform. Each such slice may have its own startup
command batch file that customizes the environment for the specific
workflow desired.</p>
<h2 id="system-management">System Management</h2>
<h3 id="listing-device-inventory">Listing Device Inventory</h3>
<p>The device units available in your system are listed in the boot
messages. However, if that list has scrolled off of your screen, you can
use the ‘D’ command to display a list of them at any time from the Boot
Loader prompt.</p>
<pre><code>Unit        Device      Type              Capacity/Mode
----------  ----------  ----------------  --------------------
Char 0      ASCI0:      RS-232            38400,8,N,1
Char 1      ASCI1:      RS-232            38400,8,N,1
Char 2      UART0:      RS-232            38400,8,N,1
Char 3      UART1:      RS-232            38400,8,N,1
Char 4      UART2:      RS-232            38400,8,N,1
Char 5      UART3:      RS-232            38400,8,N,1
Char 6      TERM0:      Terminal          Video 0,ANSI
Char 7      PRPCON0:    Terminal          Term Module,ANSI
Disk 0      MD0:        RAM Disk          352KB,LBA
Disk 1      MD1:        Flash Drive       384KB,LBA
Disk 2      FD0:        Floppy Disk       3.5",DS/HD,CHS
Disk 3      FD1:        Floppy Disk       3.5",DS/HD,CHS
Disk 4      IDE0:       CompactFlash      3815MB,LBA
Disk 5      IDE1:       Hard Disk         --
Disk 6      IDE2:       CompactFlash      3823MB,LBA
Disk 7      IDE3:       Hard Disk         --
Disk 8      IDE4:       Hard Disk         --
Disk 9      IDE5:       Hard Disk         --
Disk 10     SD0:        SD Card           --
Disk 11     PRPSD0:     SD Card           15193MB,LBA
Video 0     TMS0:       CRT               Text,40x24
Sound 0     SND0:       AY-3-8910         3+1 CHANNELS
</code></pre>
<h3 id="rebooting-the-system">Rebooting the System</h3>
<p>The ‘R’ command within the Boot Loader performs a software reset of the
system. The system will perform a startup just like powering up or
pressing the hardware reset button (although the hardware is not
physically reset).</p>
<p>There is generally no need to do this, but it can be convenient when you
want to see the boot messages again or ensure your system is in a clean
state.</p>
<pre><code>Boot [H=Help]: r

Restarting System...
</code></pre>
<h3 id="setting-nvram-options">Setting NVRAM Options</h3>
<p>On systems with RTC devices (that have Non-Volatile RAM), RomWBW
supports storing some limited configuration option options inside this
NVRAM.</p>
<p>Several configuration options are currently supported, these are known
as Switches</p>
<ul>
<li>Specify Automatic boot at startup, after an optional delay (AB)</li>
<li>Define the Disk or ROM App to be booted at for automatic boot (BO)</li>
</ul>
<p>RomWBW uses bytes located at the start of RTC NVRAM, and includes a
checksum of the bytes in NVRAM to check for integrity before using the
configuration.</p>
<p>Initially NVRAM has to be reset (with default values), before it can be
used. As well as setting defaults, it also writes the correct checksum,
and allows the NVRAM to be accessed and to store the RomWBW config.</p>
<p>This is an explicit step that must be done, as any existing data stored
is overwritten. If you are using NVRAM for other purposes, then you can
continue to do so so long as you do NOT perform this Reset step.</p>
<p>NVRAM may also need to be reset in these circumstances:</p>
<ul>
<li>When there has been a loss of power to the NVRAM.</li>
<li>When upgrading to a new RomWBW version, or a RomWBW version that has
  new switches.</li>
<li>If the NVRAM has been overwritten by another application.</li>
</ul>
<p>If you want to continue to use NVRAM in your applications you may want
to consider storing your data above the RomWBW Switch data.</p>
<p>To configure these options an inbuilt ROM application is provided which
can be accessed by the command “<code>W</code>” from the RomWBW boot menu.</p>
<p>This application is also built as a CP/M utility, but is not included on
an disk image, it is found in the <code>Binary/Applications</code> folder of the
RomWBW distribution.</p>
<p>For further guidance on using this application please see the section
“RomWBW System Configuration” in the <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>
document.</p>
<p>If your system has both a <a href="#front-panel">Front Panel</a> as well as NVRAM,
be aware that the Front Panel switches take precedence over the NVRAM
configuration settings.</p>
<p>Note that the WizNet class of Network devices also contain NVRAM which
is entirely separate from the RomWBW configuration NVRAM described here.
A separate utility is used to set the WizNet NVRAM (see <a href="#cpnet-client-setup">CP/NET Client
Setup</a>).</p>
<p><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a></p>
<h3 id="changing-console-and-console-speed">Changing Console and Console Speed</h3>
<p>Your system can support a number of devices for the console. They may be
VDU type devices or serial devices. If you want to change which device
is the console, the <strong><em>I</em></strong> menu option can be used to choose the unit
and its speed.</p>
<p>The command format is <code>I &lt;unit&gt; [&lt;baudrate&gt;]</code></p>
<p>where <strong><em>\&lt;unit&gt;</em></strong> is the character unit to select and
<strong><em>\&lt;baudrate&gt;</em></strong> is the optional baud rate.</p>
<p>Supported baud rates are:</p>
<pre><code> 75   450  1800   7200  38400  115200   460800  1843200
150   600  2400   9600  28800  153600   614400  2457600
225   900  3600  14400  57600  230400   921600  3686400
300  1200  4800  19200  76800  307200  1228800  7372800
</code></pre>
<p>Here is an example of changing the console to unit #1 (the second
serial port) and switching the port to 9600 baud:</p>
<pre><code>Boot [H=Help]: i 1 9600

  Change speed now. Press a key to resume.

  Console on Unit #1
</code></pre>
<p>At this point, the Boot Loader prompt will be displayed on character
unit #1.</p>
<p>Note that not all character devices support changing baud rates and some
only support a limited subset of the baud rates listed. If you attempt
to select an invalid baud rate for your system, you will get an error
message.</p>
<h3 id="hbios-diagnostic-verbosity">HBIOS Diagnostic Verbosity</h3>
<p>The ‘V’ command of the Boot Loader allows you to view and optionally
change the level of diagnostic messages that RomWBW will produce. The
normal verbosity level is 4, which means to display only fatal errors.
You can increase this level to see more warnings when function calls to
RomWBW HBIOS detect problems.</p>
<p>The use of diagnostic levels above 4 are really intended only for
software developers. I do not recommend changing this under normal
circumstances.</p>
<h2 id="console-takeover">Console Takeover</h2>
<p>If your system has more than one character unit, then the Boot Loader
will “poll” all of the character devices for a request to make any of
the alternate character devices the active console. This is called a
console takeover request. This functionality must be enabled in the ROM
build configuration, but currently it is for all standard ROMs.</p>
<p>To request a console takeover, you just press the \&lt;space&gt; character
twice in a row at the port or terminal that you want to move the console
to. The terminal or communication software <strong>must</strong> be configured for
the default serial port speed and data bits for this to work.</p>
<p>A takeover request is only possible while the active console is showing
the Boot Loader prompt prior to typing any characters at the active
console. In other words, once you start typing at the active console
prompt, the takeover polling is suspended. If you have started typing
characters, you can press \&lt;enter&gt; at the active console to get a fresh
Boot Loader prompt and reactivate the polling.</p>
<p>If you have built a custom ROM that includes an automatic boot command
with a timeout, then performing a console takeover will abort the
timeout process and the automatic boot command will not be performed.</p>
<h2 id="front-panel">Front Panel</h2>
<p>RomWBW supports the concept of a simple front panel. The following image
is a conceptual view of such a front panel. If your system has a front
panel, it should look similar to the <a href="#panel">RomWBW Front Panel</a>.</p>
<figure id="panel">
<img src="Graphics/Panel.svg" style="width:50.0%"
alt="RomWBW Front Panel" />
<figcaption aria-hidden="true">RomWBW Front Panel</figcaption>
</figure>

<p>The LEDs in the top row of the panel are used for multiple purposes.
They are initially used to display the progress of the system boot. This
may help in diagnosing a hardware or configuration issue in a system
that does not progress far enough to display text output on the console.
The meaning of the LEDs is:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O-------</code></td>
<td>System Boot has started</td>
</tr>
<tr>
<td><code>OO------</code></td>
<td>Common RAM bank activated</td>
</tr>
<tr>
<td><code>OOO-----</code></td>
<td>HBIOS transitioned to RAM</td>
</tr>
<tr>
<td><code>OOOO----</code></td>
<td>Basic initialization done</td>
</tr>
<tr>
<td><code>OOOOO---</code></td>
<td>CPU detection complete</td>
</tr>
<tr>
<td><code>OOOOOO--</code></td>
<td>System timer configured</td>
</tr>
<tr>
<td><code>OOOOOOO-</code></td>
<td>Pre-console device init done</td>
</tr>
<tr>
<td><code>OOOOOOOO</code></td>
<td>Console activation</td>
</tr>
</tbody>
</table>
<p>Once the system has booted, the LEDs are used to indicate disk device
activity. Each LED numbered 7-0 represents disk units 7-0. As each disk
device performs I/O, the LED will light while the disk is active. This
is only possible for the first 8 disk units.</p>
<p>The second row of the front panel is composed of switches that allow you
to control a few aspects of the system startup. The switches are also
re-read during warm boot, so confirm the switch settings are your
desired boot configuration before executing ‘REBOOT /W’.</p>
<p>The first two switches affect the device used as the initial console.</p>
<table>
<thead>
<tr>
<th>CRT/Serial</th>
<th>Sec/Pri</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRT</td>
<td>Pri</td>
<td>Primary Cathode Ray Tube device (high speed console)</td>
</tr>
<tr>
<td>CRT</td>
<td>Sec</td>
<td>Secondary Cathode Ray Tube device (high speed console)</td>
</tr>
<tr>
<td>Serial</td>
<td>Pri</td>
<td>Boot Console is Primary Serial Port</td>
</tr>
<tr>
<td>Serial</td>
<td>Sec</td>
<td>Boot Console is Secondary Serial Port</td>
</tr>
</tbody>
</table>
<p>If not available (default): “Char Unit 0” is used</p>
<p>The final six switches allow you to select the desired boot device.</p>
<table>
<thead>
<tr>
<th>Auto / Menu</th>
<th>Disk / ROM</th>
<th>Floppy / Hard</th>
<th>ROM/App/Boot Slice</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>Explanation</td>
</tr>
<tr>
<td>Menu</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>Boot to RomWBW Menu</td>
</tr>
<tr>
<td>Auto</td>
<td>Disk</td>
<td>Floppy</td>
<td>#</td>
<td>#</td>
<td>#</td>
<td>Boot Selected Floppy Disk Index</td>
</tr>
<tr>
<td>Auto</td>
<td>Disk</td>
<td>Hard</td>
<td>#</td>
<td>#</td>
<td>#</td>
<td>Boot Selected Hard Disk Index</td>
</tr>
<tr>
<td>Auto</td>
<td>ROM</td>
<td>–</td>
<td>#</td>
<td>#</td>
<td>#</td>
<td>Boot selected ROM Index</td>
</tr>
</tbody>
</table>
<p>If not available: Boot Loader Command Prompt<br />
‘–’ Ignored<br />
‘#’ bit flag to select any three bits 4,2,1</p>
<p>ROM or Hard Disk - First 8 Drive Images</p>
<table style="width:53%;">
<colgroup>
<col style="width: 11%" />
<col style="width: 25%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>4 2 1</th>
<th>Floppy / Hard<br />
Drive Index</th>
<th>ROM Index</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0 0 0</td>
<td>Zero</td>
<td>Monitor</td>
</tr>
<tr class="even">
<td>0 0 1</td>
<td>One</td>
<td>BASIC</td>
</tr>
<tr class="odd">
<td>0 2 0</td>
<td>Two</td>
<td>Forth</td>
</tr>
<tr class="even">
<td>0 2 1</td>
<td>Three</td>
<td>Game</td>
</tr>
<tr class="odd">
<td>4 0 0</td>
<td>Four</td>
<td>CP/M</td>
</tr>
<tr class="even">
<td>4 0 1</td>
<td>Five</td>
<td>Z-System</td>
</tr>
<tr class="odd">
<td>4 2 0</td>
<td>Six</td>
<td>Net Boot</td>
</tr>
<tr class="even">
<td>4 2 1</td>
<td>Seven</td>
<td>User</td>
</tr>
</tbody>
</table>

<h1 id="disk-management">Disk Management</h1>
<p>The systems supported by RomWBW all have the ability to use persistent
disk media. Some systems have disk interfaces built-in, while others
will require add-in cards. You will need to refer to the documentation
for your system for your specific options.</p>
<p>The RomWBW firmware provides a hardware abstraction layer, All disks
will work on all hardware variations. This means you can remove disk
media from one RomWBW system and put it in a different RomWBW system.
The only constraint is that the applications on the disk media must be
up to date with the firmware on the system being used.</p>
<h2 id="key-terminologyconcepts">Key Terminology/Concepts</h2>
<p>The following important terminology applies</p>
<h4 id="disk-or-disk-drive">Disk (or Disk Drive)</h4>
<p>The hardware storage device that RomWBW talks to. RomWBW supports a
variety of storage disk device types.</p>
<ul>
<li>ROM Disk - RomWBW firmware - containing CPM utilities</li>
<li>RAM Disk - A section of system RAM initially empty</li>
<li>Floppy Disk(s) - Removable media</li>
<li>Hard Disk(s) - Includes CF Cards, SD Cards, USB Stick, etc.</li>
</ul>
<p>The different disk types are further defined in the section <a href="#disk-types">Disk
Types</a>.</p>
<h4 id="media">Media</h4>
<p>The storage device inserted into a disk drive, e.g. a floppy disk, CF
Card, SD Card, etc.</p>
<h4 id="slice">Slice</h4>
<p>For hard disks a Slice is a smaller logical block of disk space that is
allocated and formatted with a filesystem and typically allocated to a
Drive letter. Slices allow large modern storage media to be sliced up
into smaller units compatible with CP/M. Slices should not be confused
with partitions, a slice is not a partition.</p>
<p>The concept of slices is described in detail in the section <a href="#hard-disk-slices">Hard Disk
Slices</a>.</p>
<h4 id="drive">Drive</h4>
<p>The mapping of a hardware disk (and slice) to a Drive letter in an
operating system. A Drive has a file system installed on it</p>
<h4 id="disk-image">Disk Image</h4>
<p>A disk image is a predefined image of a complete CP/M filesystem, or
filesystem(s), including any partition tables (for hard disk images).
Each disk image has the complete set of normal applications and tools
distributed with the associated operating system or application suite.</p>
<p>This comes in for form of a file which is suitable for copying directly
onto target media, using a modern computer. It is generally easier to
use these disk images than transferring files over individually. See the
section <a href="#disk-images">Disk Images</a> for further details.</p>
<h2 id="startup-hardware-discovery">Startup Hardware Discovery</h2>
<p>During startup RomWBW performs detection for hardware supported by your
platform. During startup you will see messages for any disk
interface(s), listing device types (e.g. FD:, IDE:, SD:), and any media
that has been found on these interfaces. The messages you see will vary
depending on your hardware and the media you have installed.</p>
<p>As an example, here are the messages you might see if you have an IDE
interface in your system with a single disk drive connected to the
primary side of the interface:</p>
<pre><code>IDE: IO=0x80 MODE=MK4
IDE0: 8-BIT LBA BLOCKS=0x00773800 SIZE=3815MB
IDE1: NO MEDIA
</code></pre>
<p>See <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Hardware.pdf">RomWBW
Hardware</a>
for a complete list of the different device types supported.</p>
<p>If you do not see drive letters assigned as expected, refer to the prior
system boot messages to ensure media has been detected in the interface.</p>
<p>Each drive letter refers back to a specific disk hardware interface like
IDE0. This is important as it is telling you what each drive letter
refers to.</p>
<p>Mass storage disks (like IDE) will normally have multiple drive letters
assigned. The extra drive letters refer to additional “slices” on the
disk.</p>
<p>Once your system has working disk devices, they will be accessible from
any operating system you choose to run. Disk storage is available
whether you boot your OS from ROM or from the disk media itself.</p>
<h2 id="drive-letter-assignment">Drive Letter Assignment</h2>
<p>In legacy CP/M operating systems only 16 drive letters (A:-P:) available
to be assigned to disks Drive letters were generally mapped to disk
drives in a completely fixed way. For example, drive A: would <strong>always</strong>
refer to the first floppy disk drive.</p>
<p>RomWBW implements a much more flexible drive letter assignment mechanism
so that any drive letter can dynamically be assigned to any disk device,
or slice of media.</p>
<p>For clarification, CP/M <strong>cannot</strong> refer directly to disk devices, CP/M
only understands drive letters, so to access a given disk device it must
first be assigned to a drive letter.</p>
<p>As the operating system starts up, you should see a list of drive
letters assigned to the disk media you have installed. Here is an
example of the list of drive letter assignments made during the startup
of Z-System:</p>
<pre><code>Configuring Drives...

        A:=MD0:0
        B:=MD1:0
        C:=FD0:0
        D:=FD1:0
        E:=IDE0:0
        F:=IDE0:1
        G:=IDE0:2
        H:=IDE0:3
</code></pre>
<p>Above you can see that:</p>
<ul>
<li>Drive A: has been assigned to MD0 which is the RAM disk device.</li>
<li>Drive B: has been assigned to MD1 which is the ROM disk device.</li>
<li>Drives C: and D: have been assigned to floppy disk drives.</li>
<li>Drives E: thru H: have been assigned to the IDE0 hard disk device. The
  4 entries for IDE0 are referring to the first 4 slices on that disk.</li>
</ul>
<p>CP/M 3 and ZPM3 do not automatically display the assignments at startup,
but you can use <code>ASSIGN</code> to display them.</p>
<p>The assignments at boot will stay the same on each boot as long as you
do not make changes to your hardware configuration. i.e. If you insert
or remove an SD Card, CF Card or USB Stick, the drive assignments will
change at next boot.</p>
<p>Since drive letter assignments can change, you must be careful when
doing destructive things like using <code>CLRDIR</code> to make sure the drive
letter you use is referring to the desired media.</p>
<p>Drive assignments can be changed at any time, by the <code>ASSIGN</code> command.
Please see the section <a href="#assign-drive-letters">Assign Drive Letters</a> for
further details.</p>
<h3 id="default-drive-letters">Default Drive Letters</h3>
<p>When an operating system is booted, RomWBW will automatically assign
drive letters to disk devices. The assignment process varies depending
on:</p>
<ul>
<li>the disk/slice you choose to boot from, and</li>
<li>the number, type, and sizes of mass storage devices available at boot</li>
</ul>
<p>The A: drive letter is considered special by most CP/M operating systems
and is automatically used in some cases. e.g. submitting batch files,
and is expected to be a writable volume.</p>
<p>If you boot to a physical disk device, then the first drive letter (A:)
will be assigned to the disk/slice that you are booting from, and the
rest of the drive letters will be offset to accommodate this. By making
the selected disk/slice the A: drive, you can setup different
disks/slices for specific uses and just boot it, and the booted
operating system will be the A: drive</p>
<p>However when performing a ROM boot of an operating system, the first two
drive letters will be assigned to your RAM disk (A:) and your ROM disk
(B:). This provides the maximum compatibility with CP/M.</p>
<p>After the first drive letter is assigned (as well as the second drive
letter in the case of a ROM boot), RomWBW will assign additional drive
letters based on the disk drives in the system. Additional drive letters
will be assigned in the following order:</p>
<ul>
<li>RAM Disk</li>
<li>ROM Disk</li>
<li>Floppy Disk(s)</li>
<li>Hard Disk(s)</li>
</ul>
<p>If a disk/slice was already assigned as the A: (or B:) drive letter,
then it will not be assigned again.</p>
<p>Floppy or removable disk drives will be assigned a drive letter
regardless of whether there is any media inserted at the time of boot.</p>
<p>In the case of hard disks, 1-8 drive letters will be assigned to the
initial 1-8 slices of the disk drive. The number of drive letters
assigned to each hard disk depends on the number of hard disks in the
system:</p>
<ul>
<li>1 Hard Disk: 8 drive letters (slices)</li>
<li>2 Hard Disks: 4 drive letters (slices) per disk</li>
<li>3+ Hard Disks: 2 drive letters (slices) per disk</li>
</ul>
<p>This somewhat complicated algorithm is used to try and maximize the
limited number of operating system drive letters available (16) to the
available disk devices as evenly as possible.</p>
<p>For hard disk devices which are treated as non-removable media, drive
letters will only be assigned to disk devices that actually contain
media. i.e. No drive letters will be assigned to an SD Card slot that
has no SD Card inserted.</p>
<h3 id="assign-drive-letters">Assign Drive Letters</h3>
<p>The <code>ASSIGN</code> command is used to view or change the current drive letter
mappings. Any changes made to drive letter mappings take immediate
effect</p>
<p>Refer to <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>
for more information on use of the <code>ASSIGN</code> command.</p>
<p>Since drive letter assignments are easily changed at any time using the
<code>ASSIGN</code> command, you can customize your assignments as desired after
starting the operating system. Even better, you can use an auto-submit
batch file to customzie the assignments at startup without any user
intervention.</p>
<h2 id="disk-operationscommands">Disk Operations/Commands</h2>
<p>With some understanding of how RomWBW presents disk space to the
operating systems, we need to go over the options for actually setting
up your disk(s) with content.</p>
<h3 id="preparing-media-for-first-use">Preparing Media for First Use</h3>
<p>You can initialize the media in-place using your RomWBW system.
Essentially, this means you are creating a set of blank directories on
your disk so that files can be saved there. This is somewhat analogous
to partitioning of a hard disk or doing a low level format of a floppy
disk.</p>
<p>Initilizing a Floppy disk is covered in the section <a href="#floppy-disk-formatting">Floppy Disk
Formatting</a>, or for a Hard disk the section
<a href="#hard-disk-preparation">Hard Disk Preparation</a> covers the steps to
manually setup a hard disk for first use.</p>
<h3 id="clearing-formatting-drives">Clearing (Formatting) Drives</h3>
<p>This is somewhat analogous to doing a FORMAT operation on other systems.</p>
<p>With RomWBW you use the <code>CLRDIR</code> command to do this. This command is
merely “clearing out” the directory space of the drive referred to by a
drive letter and setting up the new empty directory.</p>
<p>Refer to <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>
for more information on use of the <code>CLRDIR</code> command.</p>
<p>Since <code>CLRDIR</code> works on drive letters, make absolutely sure you know
what media and slice are assigned to that drive letter before using
<code>CLRDIR</code> because <code>CLRDIR</code> will wipe out any pre-existing contents of the
slice.</p>
<p>After <code>CLRDIR</code> completes, the slice should be ready to use by the
operating system via the drive letter assigned. Start by using the <code>DIR</code>
command on the drive. This should return without error, but list no
files.</p>
<p>Here is an example of using <code>CLRDIR</code>. In this example, the <code>ASSIGN</code>
command is used to show the current drive letter assignments. Then the
<code>CLRDIR</code> command is used to initialize the directory of drive ‘G’ which
is slice 2 of hard disk device IDE0 (“IDE0:2”).</p>
<pre><code>B&gt;ASSIGN

   A:=MD0:0
   B:=MD1:0
   C:=FD0:0
   D:=FD1:0
   E:=IDE0:0
   F:=IDE0:1
   G:=IDE0:2
   H:=IDE0:3

B&gt;CLDIR G:
CLRDIR Version 1.2B May 2024 by Max Scane

Warning - this utility will overwrite the directory sectors of Drive: G
Type CAPITAL Y to proceed, any key other key to exit. Y
Directory cleared.
B&gt;
</code></pre>
<h3 id="checking-disk-layout">Checking Disk Layout</h3>
<p>If you are not sure which disk layout is used for your existing media,
you can use the CP/M 2.2 <code>STAT</code> command to display information including
the number of “32 Byte Directory Entries” for a drive letter on the
corresponding hard disk.</p>
<ul>
<li>If it indicates 512, your disk layout is legacy (hd512).  </li>
<li>If it indicates 1024, your disk layout is modern (hd1k).</li>
</ul>
<p>Here is an example of checking the disk layout.</p>
<pre><code>B&gt;STAT E:DSK:

    E: Drive Characteristics
65408: 128 Byte Record Capacity
 8176: Kilobyte Drive  Capacity
 1024: 32  Byte Directory Entries
    0: Checked  Directory Entries
  256: Records/ Extent
   32: Records/ Block
   64: Sectors/ Track
    2: Reserved Tracks
</code></pre>
<p>It is critical that you include <code>DSK:</code> after the drive letter in the
<code>STAT</code> command line. The important line to look at is labeled “32 Byte
Directory Entries”.</p>
<h1 id="disk-types">Disk Types</h1>
<h2 id="ram-rom-disks">RAM &amp; ROM Disks</h2>
<p>A typical RomWBW system has 512KB of ROM and 512KB of RAM. Some portions
of each are dedicated to loading and running applications and operating
system. The space left over is available for an operating system to use
as a pseudo-disk device (ROM Disk and RAM Disk).</p>
<p>Unlike other types of disk devices, ROM and RAM Disks do not contain an
actual operating system and are not “bootable”. However, they are
accessible to any operating system (whether the operating system is
loaded from ROM or a different disk device).</p>
<p>Neither RAM nor ROM disks require explicit formatting or initialization.
ROM disks are pre-formatted and RAM disks are formatted automatically
with an empty directory when first used.</p>
<h4 id="ram-disk">RAM Disk</h4>
<p>The RAM disk provides a small CP/M filesystem that you can use for the
temporary storage of files. Unless your system has a battery backed
mechanism for persisting your RAM contents, the RAM disk contents will
be lost at each power-off.</p>
<p>The RAM disk is an excellent choice for storing temporary files because
it is very fast. You will notice that the first time an operating system
is started after the power was turned off, you will see a message
indicating that the RAM disk is being formatted. If you reset your
system without turning off power, the RAM disk will not be reformatted
and it’s contents will still be intact.</p>
<h4 id="rom-disk">ROM Disk</h4>
<p>Like the RAM disk, the ROM disk also provides a small CP/M filesystem,
but it’s contents are static – they are part of the ROM. As such, you
cannot save files to the ROM disk. Any attempt to do this will result in
a disk I/O error.</p>
<p>The contents of the ROM disk have been chosen to provide a core set of
tools and applications that are helpful for either CP/M 2.2 or ZSDOS.
Since ZSDOS is CP/M 2.2 compatible, this works fairly well. However, you
will find some files on the ROM disk that will work with ZSDOS, but will
not work on CP/M 2.2. For example, <code>LDDS</code>, which loads the ZSDOS
date/time stamper will only run under ZSDOS.</p>
<h4 id="flash-rom-disks">Flash ROM Disks</h4>
<p>The limitation of ROM disks being read-only can be overcome on some
platforms with the appropriate selection of Flash ROM chip and system
configuration. In this case the flash-file system can be enabled which
will allow the ROM disk to be read and written to. Flash devices have a
limited write lifespan and continual usage will eventually wear out the
device. It is not suited for high usage applications. Enabling ROM disk
writing requires building a custom ROM.</p>
<h2 id="floppy-disks">Floppy Disks</h2>
<p>If your system has the appropriate hardware, RomWBW will support the use
of floppy disks. The supported floppy disk formats are generally derived
from the IBM PC floppy disk formats:</p>
<ul>
<li>5.25” 360K Double-sided, Double-density</li>
<li>5.25” 1.2M Double-sided, High-density</li>
<li>3.5” 720K Double-sided, Double-density</li>
<li>3.5” 1.44M Double-sided, High-density</li>
</ul>
<p>When supported, RomWBW is normally configured for 2 3.5” floppy disk
drives. If a high-density disk drive is used, then RomWBW automatically
detects and adapts to double-density or high-density media. It cannot
automatically detect 3.5” vs. 5.25” disk drive types – the ROM must be
pre-configured for the disk drive type.</p>
<p><strong>WARNING:</strong> Some of the operating systems provided with RomWBW require
that a soft-reset be performed when swapping floppy disk media. For
example, under CP/M 2.2, you must press control-C at the CP/M prompt
after inserting a new floppy disk. The consequences of failing to
perform the soft-reset vary from unexpected error messages to full disk
directory corruption.</p>
<h2 id="hard-disks">Hard Disks</h2>
<p>The concept of a hard disk in RomWBW applies to any storage device that
provides at least 8MB of space. The actual media can be a real spinning
hard disk, a CompactFlash Card, a SD Card, etc. In this document, the
term hard disk will apply equally to all of these.</p>
<p>The vintage operating systems included with RomWBW were produced at a
time when mass storage devices were quite small. CP/M 2.2 could only
handle filesystems up to 8MB.</p>
<p>Since storage devices today are quite large, RomWBW implements a
mechanism called slicing (see <a href="#hard-disk-slices">Hard Disk Slices</a>) to
allow up to 256 8MB CP/M filesystems on a single large storage device,
where each slice can be assigned to a drive letter in CPM, and be
treated as its own hard disk drive (from a CPM perspective).</p>
<p>In order to achieve compatibility across all of the operating systems
supported by RomWBW, the hard disk filesystem format used is 8MB. This
ensures any filesystem will be accessible to any of the operating
systems.</p>
<p>RomWBW uses Logical Block Addressing (LBA) to interact with all hard
disks. The RomWBW operating systems use older Cylinder/Head/Sector (CHS)
addressing. To accommodate the operating systems, RomWBW emulates CHS
addressing. Specifically, it makes all hard disks look like they have 16
sectors and 16 heads. The number of tracks varies with the size of the
physical hard disk.</p>
<h3 id="hard-disk-layouts">Hard Disk Layouts</h3>
<p>When RomWBW uses a hard disk, it utilizes an area of the physical hard
disk drive space to store a sequential series of slices that contain the
actual CP/M filesystems referred to by drive letters by the operating
system.</p>
<p>Two hard disk layout schemes exist:</p>
<ul>
<li>Modern (hd1k)</li>
<li>Legacy (hd512)</li>
</ul>
<p>You <strong>cannot</strong> mix disk layouts on a single disk device, however It is
perfectly fine for one system to have multiple hard disks with different
layouts – each physical disk device is handled separately.</p>
<p>If you are setting up a new disk, the modern (hd1k) layout is
recommended for the following reasons:</p>
<ul>
<li>Larger number of directory entries per filesystem</li>
<li>Simplifies creation of coresident FAT filesystem</li>
<li>Reduces chances of data corruption</li>
<li>Each slice occupies exactly 8MB (an exact power of 2) in size</li>
</ul>
<p>Both the legacy and modern disk layouts continue to be fully supported
by RomWBW. There are no plans to deprecate the legacy layout.</p>
<h4 id="modern-layout">Modern Layout</h4>
<p>RomWBW (Starting with v3.2) supports the use of disk partitioning,
utilising a Master Boot Record (MBR) partition tables. The Wikipedia
article on the <a href="https://en.wikipedia.org/wiki/Master_boot_record">Master Boot
Record</a> is excellent
if you are not familiar with them.</p>
<p>RomWBW uses the partition type id <code>0x2E</code>. This partition type id does
not equate to any existing well-known partition types – it was chosen
because it is not generally used. RomWBW does not support extended
partitions – only a single primary partition can be used.</p>
<p>The existence of a partition table entry for RomWBW on a hard disk makes
it behave in the modern mode. Removing the RomWBW partition entry from a
modern hard disk layout will cause the existing data to be unavailable
and/or corrupted</p>
<p>The CP/M filesystem in the slices of the modern disk layout contain 1024
directory entries.</p>
<h4 id="legacy-layout">Legacy Layout</h4>
<p>Originally, RomWBW always used the very start of the hard disk media for
the location of the slices. In this layout, slice 0 referred to the
first chunk of ~8MB on the disk, slice 1 referred to the second chunk of
~8MB on the disk, and so on. The number of slices is limited to the size
of the disk media – if you attempted to read/write to a slice that would
exceed the disk size, you would see I/O errors.</p>
<p>The legacy format takes steps to allow a partition table to still be
used for other types of filesystems such as DOS/FAT. It just does not
use a partition table entry to determine the start of the RomWBW slices.</p>
<p>The lack of a RomWBW partition table entry will cause legacy behaviour.
Adding a partition table entry on an existing legacy RomWBW hard disk
will cause the existing data to be unavailable and/or corrupted.</p>
<p>The CP/M filesystem in the slices of the legacy disk layout contain 512
directory entries.</p>
<h3 id="hard-disk-slices">Hard Disk Slices</h3>
<p>RomWBW implements a mechanism called slicing to allow multiple CP/M
filesystem on a single large storage device. To say it another way, the
media is “sliced up” into many CP/M filesystems.</p>
<p>You cannot use slices on any media less than 8MB in size. Specifically,
you cannot slice RAM disks, ROM disks, floppy disks, etc. All of these
are considered to have a single slice (0)</p>
<p>It is very important to understand that RomWBW slices are not
individually created or allocated on your hard disk. RomWBW uses a
single partition on your hard disk to contain the slices. You should
think of slices as just an index into a sequential set of 8MB areas that
exist in this partition.</p>
<p>RomWBW allows up to up to 256 slices each of 8MB in size on a single
large storage device. This allows the use of up to 2GB of usable space
on one media device.</p>
<p>It is possible to create other partitions (typically FAT), for now, we
are just talking about the slices within the single RomWBW partition.</p>
<h3 id="slice-assignment">Slice Assignment</h3>
<p>When assigning Hard disks to drive letters you also need to assign the
slice.</p>
<p>Referring to slices within a storage device is done by appending a
<code>:&lt;n&gt;</code> where \&lt;n&gt; is the device relative slice number from 0-255. For
example, if you have an IDE device, it will show up as IDE0: in the boot
messages meaning the first IDE device. To refer to the fourth slice of
IDE0, you would type “IDE0:3”. Here are some examples:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IDE0:0</code></td>
<td>First slice of disk in IDE0</td>
</tr>
<tr>
<td><code>IDE0:</code></td>
<td>First slice of disk in IDE0</td>
</tr>
<tr>
<td><code>IDE0:3</code></td>
<td>Fourth slice of disk in IDE0</td>
</tr>
</tbody>
</table>
<p>So, if you wanted to use drive letter L: to refer to the fourth slice of
IDE0, you could use the command <code>ASSIGN L:=IDE0:3</code>. There are a couple
of rules to be aware of when assigning drive letters. First, you may
only refer to a specific device/slice with one drive letter at a time.
Said another way, you cannot have multiple drive letters referring to a
the same device/slice at the same time. Second, there must always be a
drive assigned to A:. Any attempt to violate these rules will be blocked
by the <code>ASSIGN</code> command.</p>
<p>As you see, the name of a slice does not reference the hard disk
partition containing the slices. Since there can only be a single RomWBW
partition containing slices on any disk, the partition is determined
automatically.</p>
<p>RomWBW does not prevent you from assigning slices to drive letters even
if the location of the slice does not fit on the physical disk. Any
attempt to access a drive letter mapped to a slice that does not fit
will result in an error such as “no disk” from the operating system.</p>
<p>For example, a 64MB CF Card (which is typically a bit smaller than 64MB)
will only fit 7 slices. At startup, you will typically see 8 drive
letters assigned to the CF Card. Attempting to access the last drive
letter will result in a “no disk” error from the operating system.</p>
<h3 id="hard-disk-capacity">Hard Disk Capacity</h3>
<p>The exact number of CP/M filesystem slices that will fit on your
specific physical hard disk can be determined as follows:</p>
<ul>
<li>For modern (hd1k) disk layouts, it is 1024KB + (slices * 8192KB). Or
  equivalent to say 1MB + (slices * 8MB).</li>
<li>For legacy (hd512) disk layouts, it is slices * 8,320KB.</li>
</ul>
<p><strong>WARNING</strong>: In this document KB means 1024 bytes and MB means 1048576
bytes (frequently expressed as KiB and MiB in modern terminology). In
general, hard disk capacities use KB to mean 1000 bytes and MB to mean
1,000,000 bytes.</p>
<p>As an example, A “64MB” CF Card probably has less than 62.5MB of actual
space (using the RomWBW definition that 1MB is 1048576 bytes). Such a
drive will not support 8 slices. It will support 7 slices just fine
because 1024KB + (7 * 8192MB) = 57MB (hd1k) or 7 * 8,320KB = 58.24MB
(hd512)</p>
<p>Although you can use up to 256 slices per physical disk, equating to 2GB
of storage this large number of slices is rarely used. It is recommended
that hard disk media used with RomWBW be 1GB or greater in capacity.
This will support the RomWBW Combo Disk Image (see <a href="#combo-hard-disk-image">Combo Hard Disk
Image</a>) that allows you to use 64 CP/M
filesystem slices and a 384KB FAT filesystem.</p>
<h1 id="disk-preparation">Disk Preparation</h1>
<p>There are two approaches to preparing disks for use by RomWBW.</p>
<ul>
<li><strong>Manual</strong>: Use RomWBW itself to format empty disks and then transfer
  files over to the disks.</li>
<li><strong>Images</strong>: Use a modern computer to write a pre-built disk image
  including files to a disk.</li>
</ul>
<p>This section of the document describes the manual process of preparing
empty disks that are ready for use by an operating system.</p>
<p>Alternatively, you can use the pre-built RomWBW disk images to quickly
create disk media that already has a large selection of files and
bootable operating system slices. Using images to prepare a disk is
documented in <a href="#disk-images">Disk Images</a>. You do not need to follow the
instructions in this section if you want to use disk images.</p>
<h2 id="floppy-disk-formatting">Floppy Disk Formatting</h2>
<p>Floppy media must be physically formatted before it can be used. This is
normally accomplished by using the supplied Floppy Disk Utility <code>FDU</code>
application. This application interacts directly with your hardware and
therefore you must specify your floppy interface hardware at application
startup. Additionally, you need to specify the floppy disk drive and
media format to use for formatting.</p>
<p>Refer to <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>
for more information on use of the <code>FDU</code> command.</p>
<p>Since the physical format of floppy media is the same as that used in a
standard MS-DOS/Windows computer, you can also format floppy disk media
in a standard computer. However there are caveats:</p>
<ul>
<li>The directory format itself will <strong>NOT</strong> be compatible with CP/M OSes.
  You <strong>WILL</strong> need to use the <code>CLRDIR</code> command to reformat the
  directory area from CP/M. See section <a href="#clearing-formatting-drives">Clearing (Formatting)
  Drives</a></li>
<li>FDU allows you to specify physical sector interleaving (defaults to 2)
  which will result in faster floppy disk I/O. Formatting on a modern
  computer may not optimize this.</li>
</ul>
<p>Below is a sample session using <code>FDU</code> to format a 1.44M floppy disk in
the first (primary) floppy disk drive:</p>
<pre><code>B&gt;FDU

Floppy Disk Utility (FDU) v5.8, 26-Jul-2021 [HBIOS]
Copyright (C) 2021, Wayne Warthen, GNU GPL v3

SELECT FLOPPY DISK CONTROLLER:
  (A) Disk IO ECB Board
  (B) Disk IO 3 ECB Board
  (C) Zeta SBC Onboard FDC
  (D) Zeta 2 SBC Onboard FDC
  (E) Dual IDE ECB Board
  (F) N8 Onboard FDC
  (G) RCBus SMC (SMB)
  (H) RCBus WDC (SMB)
  (I) SmallZ80 Expansion
  (J) Dyno-Card FDC, D1030
  (K) RCBus EPFDC
  (L) Multi-Board Computer FDC
  (X) Exit
=== OPTION ===&gt; D-IDE

===== D-IDE ===========&lt;&lt; FDU MAIN MENU &gt;&gt;======================
(S)ETUP: UNIT=00  MEDIA=720KB DS/DD    MODE=POLL        TRACE=00
----------------------------------------------------------------
(R)EAD          (W)RITE         (F)ORMAT        (V)ERIFY
(I)NIT BUFFER   (D)UMP BUFFER   FDC (C)MDS      E(X)IT
=== OPTION ===&gt; SETUP
ENTER UNIT [00-03] (00):
00: 3.5" 720KB - 9 SECTORS, 2 SIDES, 80 TRACKS, DOUBLE DENSITY
01: 3.5" 1.44MB - 18 SECTORS, 2 SIDES, 80 TRACKS, HIGH DENSITY
02: 5.25" 320KB - 8 SECTORS, 2 SIDES, 40 TRACKS, DOUBLE DENSITY
03: 5.25" 360KB - 9 SECTORS, 2 SIDES, 40 TRACKS, DOUBLE DENSITY
04: 5.25" 1.2MB - 15 SECTORS, 2 SIDES, 80 TRACKS, HIGH DENSITY
05: 8" 1.11MB - 15 SECTORS, 2 SIDES, 77 TRACKS, DOUBLE DENSITY
06: 5.25" 160KB - 8 SECTORS, 1 SIDE, 40 TRACKS, DOUBLE DENSITY
07: 5.25" 180KB - 9 SECTORS, 1 SIDE, 40 TRACKS, DOUBLE DENSITY
08: 5.25" 320KB - 8 SECTORS, 1 SIDE, 80 TRACKS, DOUBLE DENSITY
09: 5.25" 360KB - 9 SECTORS, 1 SIDE, 80 TRACKS, DOUBLE DENSITY
ENTER MEDIA [00-09] (00): 01
00: POLLING (RECOMMENDED)
01: INTERRUPT (!!! READ MANUAL !!!)
02: FAST INTERRUPT (!!! READ MANUAL !!!)
03: INT/WAIT (!!! READ MANUAL !!!)
04: DRQ/WAIT (!!! NOT YET IMPLEMENTED!!!)
ENTER MODE [00-04] (00):
ENTER TRACE LEVEL [00-01] (00):

===== D-IDE ===========&lt;&lt; FDU MAIN MENU &gt;&gt;======================
(S)ETUP: UNIT=00  MEDIA=1.44MB DS/HD   MODE=POLL        TRACE=00
----------------------------------------------------------------
(R)EAD          (W)RITE         (F)ORMAT        (V)ERIFY
(I)NIT BUFFER   (D)UMP BUFFER   FDC (C)MDS      E(X)IT
=== OPTION ===&gt; FORMAT (T)RACK, (D)ISK ===&gt; DISK
ENTER INTERLEAVE [01-12] (02):

RESET DRIVE...
PROGRESS: TRACK=4F HEAD=01 SECTOR=01

===== D-IDE ===========&lt;&lt; FDU MAIN MENU &gt;&gt;======================
(S)ETUP: UNIT=00  MEDIA=1.44MB DS/HD   MODE=POLL        TRACE=00
----------------------------------------------------------------
(R)EAD          (W)RITE         (F)ORMAT        (V)ERIFY
(I)NIT BUFFER   (D)UMP BUFFER   FDC (C)MDS      E(X)IT
=== OPTION ===&gt; EXIT
</code></pre>
<p>You can confirm a floppy disk is ready for content by simply running a
<code>DIR</code> command on it. The <code>DIR</code> command should complete without error and
should list no files.</p>
<h2 id="hard-disk-preparation">Hard Disk Preparation</h2>
<p>This section deals with initializing hard disk media entirely from your
RomWBW system. The following instructions are one way to proceed. This
does not mean to imply it is the only possible way.</p>
<p>First you need to understand</p>
<ul>
<li>The disk layout approach (either hd1k or the legacy hd512). See <a href="#hard-disk-layouts">Hard
  Disk Layouts</a> section if you are not sure. hd1k
  should be the preferred layout.</li>
<li>The number of 8MB slices that you want to allocate, preferred is 64
  slices. At least 1 slice of 8MB is required</li>
<li>If you want to leave space for a FAT partition. See <a href="#fat-filesystem-preparation">FAT Filesystem
  Preparation</a></li>
<li>The total capacity of your drive, to hold the CP/M (and other)
  partition(s)</li>
</ul>
<p>Then you will need to start by inserting the disk media, booting RomWBW,
and confirming that the media is being recognized. If RomWBW recognizes
the media, it will indicate this in the boot messages even though the
media may not yet been prepared for use.</p>
<p>Then launch either CP/M 2.2 or Z-System from ROM using the Boot Loader
<code>C</code> or <code>Z</code> commands respectively. You can now use the tools on the ROM
disk to prepare your disks.</p>
<p>Note that you may see the operating system assign disks/slices to drives
letters even though the disks/slices are not yet initialized. This is
normal and does not mean the disks/slices are ready to use.</p>
<h3 id="partition-setup">Partition Setup</h3>
<p>To setup a partition you must run the <code>FDISK80</code> utility. After FDISK80
starts, enter the disk unit number of the new media. The disk unit
number was assigned at boot See <a href="#device-unit-assignments">Device Unit
Assignments</a></p>
<p>Refer to <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>
for more information on use of the <code>FDISK80</code> utility.</p>
<p>If you want to use the legacy hd512 layout skip down to the <a href="#legacy-hd512">Legacy
(hd512)</a> section</p>
<h4 id="modern-hd1k">Modern (hd1k)</h4>
<p>At this point, use the <code>I</code> command to initialize (reset) the partition
table to an empty state.</p>
<p>You must create a partition for the RomWBW CP/M slices. Then create a
partition using the <code>N</code> command. Importantly:</p>
<ul>
<li>The partition number should typically be <code>1</code> the first partition</li>
<li>The partition can be placed anywhere you want, The typical location
  for the RomWBW partition is at 1MB.</li>
<li>The partition size should be the total size of all the slices you
  require, and must be at least 8MB in size, in increments of 8MB makes
  sense.</li>
</ul>
<p>You <strong>must</strong> then set the type of partition to <code>2E</code> using the <code>T</code>
command. The <code>P</code> command can be used to display the partition before it
is written Finally the partition can be written to disk using the <code>W</code>
write command.</p>
<p><strong>WARNING</strong>: Modifying the partition table of existing media will make
any data on the media inaccessible.</p>
<p>Below is an example of creating a RomWBW partition following these
guidelines.</p>
<pre><code>FDISK80 for RomWBW, UNA, Mini-M68k, KISS-68030, SBC-188  ----
       Version 1.1-22 created 7-May-2020
                 (Running under RomWBW HBIOS)

HBIOS unit number [0..11]: 4
Capacity of disk 4:  (  4G)  7813120      Geom 77381010
Nr  ---Type- A --      Start         End   LBA start  LBA count  Size
 1             00       *** empty ***
 2             00       *** empty ***
 3             00       *** empty ***
 4             00       *** empty ***
&gt;&gt;i
&gt;&gt;n
New partition number: 1
Starting Cylinder (default 0): 1Mb
Ending Cylinder (or Size= "+nnn"): +512Mb
&gt;&gt;t
Change type of partition number: 1
New type (in hex), "L" lists types: 2e
&gt;&gt;p
Nr  ---Type- A --      Start         End   LBA start  LBA count  Size
 1    RomWBW   2e      8:0:1  1023:15:16        2048    1048576  512M
 2             00       *** empty ***
 3             00       *** empty ***
 4             00       *** empty ***
&gt;&gt;w
Do you really want to write to disk? [N/y]: y
Okay
FDISK exit.
</code></pre>
<p>At this point, it is best to restart your system to make sure that the
operating system is aware of the partition table updates. Start CP/M 2.2
or Z-System from ROM again.</p>
<h4 id="legacy-hd512">Legacy (hd512)</h4>
<p>At this point, use the <code>I</code> command to initialize (reset) the partition
table to an empty state.</p>
<p>To use the hd512 layout, use <code>W</code> to write the empty table to the disk
and exit. Remember that the lack of a partition for RomWBW implies the
legacy (hd512) layout.</p>
<p>At this point, it is best to restart your system to make sure that the
operating system is aware of the partition table updates. Start CP/M 2.2
or Z-System from ROM again.</p>
<h4 id="fat-partition">FAT Partition</h4>
<p>At this point you may want to consider creating a FAT partition Please
see the section <a href="#fat-filesystem-preparation">FAT Filesystem
Preparation</a> for detils on how to setup the
FAT partition.</p>
<h3 id="slice-initialization">Slice Initialization</h3>
<p>You need to initialize each slice for CP/M to use it. This is somewhat
analogous to doing a FORMAT operation on other systems, and is done
using the <code>CLRDIR</code> command.</p>
<p>This is covered in the section <a href="#clearing-formatting-drives">Clearing (Formatting)
Drives</a></p>
<p><strong>WARNING</strong>: Earlier versions of the <code>CLRDIR</code> application do not appear
to check for disk errors when it runs. If you attempt to run <code>CLRDIR</code> on
a drive that is mapped to a slice that does not actually fit on the
physical disk, it may behave erratically.</p>
<p>Assuming you want to use additional slices, you should initialize them
using the same process. You may need to reassign drive letters to access
some slices that are beyond the ones automatically assigned. You can use
the <code>ASSIGN</code> command to handle this.</p>
<h2 id="post-disk-preparation">Post Disk Preparation</h2>
<p>Once a disk (either floppy or hard disk) has been initialised and
formattted you may optionally; * Make the disk bootable * Copy system
(or other) files to the disk</p>
<h3 id="making-a-disk-bootable">Making a Disk Bootable</h3>
<p>To make a disk bootable you will need to follow the specific
instructions in <a href="#operating-systems">Operating Systems</a>, as each
operating system will be different.</p>
<p>Generally you will need to use <code>SYSCOPY</code> to setup the system track(s) of
the disk.As an example, If you wanted to setup C: as a bootable Z-System
disk you would use:</p>
<pre><code>B&gt;SYSCOPY C:=B:ZSYS.SYS

SYSCOPY v2.0 for RomWBW CP/M, 17-Feb-2020 (CP/M 2 Mode)
Copyright 2020, Wayne Warthen, GNU GPL v3

Transfer system image from B:ZSYS.SYS to C: (Y/N)? Y
Reading image... Writing image... Done
</code></pre>
<p>Once this process succeeds, you will be able to boot directly to the
disk slice from the boot loader prompt. See the instructions in
<a href="#starting-operating-systems-from-disk">Starting Operating Systems from
Disk</a> for details on this.</p>
<h3 id="copying-system-files">Copying System Files</h3>
<p>As well as making the disk bootable, you may need to transfer other
system and application files to your disks. Refer to <a href="#transferring-files">Transferring
Files</a> for more information on getting files onto
your disks.</p>
<h1 id="disk-images">Disk Images</h1>
<p>Since it would be quite a bit of work to transfer over all the files you
might want initially to your disk(s), It is generally easier to use
these disk images than transferring your files over individually. RomWBW
comes with a variety of ready to use disk images.</p>
<p>You can use your modern Windows, Linux, or Mac computer to copy a disk
image onto the disk media, then just move the media over to your RomWBW
computer.</p>
<p>The disk image files are found in the Binary directory of the
distribution.</p>
<p>Each disk image has the complete set of normal applications and tools
distributed with the associated operating system or application suite.
The following table shows the disk images available.</p>
<table>
<thead>
<tr>
<th><strong>Disk Image</strong></th>
<th><strong>Description</strong></th>
<th><strong>Boot</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>xxx_aztec.img</td>
<td>Aztec C Compiler</td>
<td>No</td>
</tr>
<tr>
<td>xxx_bascomp.img</td>
<td>Microsoft Basic-80 Compiler</td>
<td>No</td>
</tr>
<tr>
<td>xxx_blank.img</td>
<td><em>empty image</em></td>
<td>No</td>
</tr>
<tr>
<td>xxx_cowgol.img</td>
<td>Cowgol 2.0 Compiler</td>
<td>No</td>
</tr>
<tr>
<td>xxx_cpm22.img</td>
<td>DRI CP/M 2.2 Operating System</td>
<td>Yes</td>
</tr>
<tr>
<td>xxx_cpm3.img</td>
<td>DRI CP/M 3 Operating System</td>
<td>Yes</td>
</tr>
<tr>
<td>xxx_dos65.img</td>
<td>DOS/65 Operating System</td>
<td>Yes</td>
</tr>
<tr>
<td>xxx_fortran.img</td>
<td>Microsoft Fortran-80 Compiler</td>
<td>No</td>
</tr>
<tr>
<td>xxx_games.img</td>
<td>Games Disk for CP/M</td>
<td>No</td>
</tr>
<tr>
<td>xxx_hitechc.img</td>
<td>HI-TECH Z80 CP/M C compiler</td>
<td>No</td>
</tr>
<tr>
<td>xxx_msxroms1.img</td>
<td>MSX ROMs Disk 1</td>
<td>No</td>
</tr>
<tr>
<td>xxx_msxroms2.img</td>
<td>MSX ROMs Disk 2</td>
<td>No</td>
</tr>
<tr>
<td>xxx_nzcom.img</td>
<td>NZCOM ZCPR 3.4 Operating System</td>
<td>Yes</td>
</tr>
<tr>
<td>xxx_qpm.img</td>
<td>QPM Operating System</td>
<td>Yes</td>
</tr>
<tr>
<td>xxx_tpascal.img</td>
<td>Borland Turbo Pascal Compiler</td>
<td>No</td>
</tr>
<tr>
<td>xxx_ws4.img</td>
<td>WordStar v4 &amp; ZDE Applications</td>
<td>No</td>
</tr>
<tr>
<td>xxx_z80asm.img</td>
<td>Relocating macro assembler for CP/M</td>
<td>No</td>
</tr>
<tr>
<td>xxx_zpm3.img</td>
<td>ZPM3 Operating System</td>
<td>Yes</td>
</tr>
<tr>
<td>xxx_zsdos.img</td>
<td>ZCPR-DJ &amp; ZSDOS 1.1 Operating System</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>You will find 3 sets of these .img files in the distribution. The “xxx”
portion of the filename will be:</p>
<ul>
<li>“fd_” for a floppy image.</li>
<li>“hd1k_” for a modern layout hard disk image.</li>
<li>“hd512_” for a legacy layout hard disk image.</li>
</ul>
<p>In the case of xxx_dos65.img, only an hd512 variant is provided. This is
a constraint of the DOS65 distribution.</p>
<p>There is also an image file called “psys.img” which contains a bootable
p-System hard disk image. It contains 6 p-System filesystem slices, but
these are not interoperable with the CP/M slices described above. This
file is discussed separately under <a href="#ucsd-p-system">UCSD p-System</a> in
Operating Systems section.</p>
<h2 id="floppy-disk-images">Floppy Disk Images</h2>
<p>The floppy disk images are all intended to be used with 3.5”
high-density, double-sided 1.44 MB floppy disk media. This is ideal for
the default floppy disk drive support included in RomWBW standard ROMs.</p>
<p>For floppy disks, the .img file is written directly to the floppy media
as is. The floppy .img files are 1.44 MB which is the exact size of a
single 3.5” high density floppy disk. You will need a floppy disk drive
of the same type connected to your modern computer to write this image.
Although modern computers do not come equipped with a floppy disk drive,
you can still find USB floppy drives that work well for this.</p>
<p>The floppy disk must be physically formatted <strong>before</strong> writing the
image onto it. You can do this with RomWBW using <code>FDU</code> as described in
the <a href="#floppy-disk-formatting">Floppy Disk Formatting</a> section of this
document. While you can also format the floppy using your modern
computer, using <code>FDU</code> is preferable.</p>
<p>RomWBW includes a Windows application called RawWriteWin in the Tools
directory of the distribution. This simple application will let you
choose a file and write it to an attached floppy disk drive. For
Linux/MacOS, I think you can use the dd command (but I have not actually
tried this). It is probably obvious, but writing an image to a floppy
disk will overwrite and destroy all previous contents.</p>
<p>Once the image has been written to the floppy disk, you can insert the
floppy disk in your RomWBW floppy disk and read/write files on it
according to the specific operating system instructions. If the image is
bootable, then you will be able to boot from it by entering the floppy
disk drive’s corresponding unit number at the RomWBW Boot Loader command
prompt.</p>
<h2 id="hard-disk-images">Hard Disk Images</h2>
<p>Keeping in mind that a RomWBW hard disk (including CF/SD/USB devices)
allows you to have multiple slices (CP/M filesystems), there are a
couple ways to image hard disk media. The easiest approach is to use the
Combo Disk Image. This hard disk image is already prepared with 6 slices
containing 5 ready-to-run OSes and a slice with the WordStar application
files.</p>
<p>Alternatively, you can create your own hard disk image with the specific
slice contents you choose.</p>
<h3 id="standard-hard-disk-layout">Standard Hard Disk Layout</h3>
<p>As previously described in <a href="#hard-disk-layouts">Hard Disk Layouts</a>, the
exact placement of slices and optional FAT partition will vary depending
on which disk layout (hd512 or hd1k) you are using and your partition
table entries. To simplify the use of hard disk images, RomWBW has
adopted a standard partition layout for disk image files provided. This
standard layout is used to produce the Combo Disk Images described
below.</p>
<p>These partition sizes and locations were chosen to:</p>
<ul>
<li>Fit entirely on 1GB media</li>
<li>Allow for 64 CP/M filesystem slices</li>
<li>Allow for a 384KB FAT filesystem</li>
</ul>
<p>The standard partition table table entries are:</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align: right;"><strong>— Modern (hd1k) —</strong></th>
<th style="text-align: right;"></th>
<th style="text-align: right;"><strong>— Legacy (hd512) —</strong></th>
<th style="text-align: right;"></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td style="text-align: right;">Byte(s)</td>
<td style="text-align: right;">Sector(s)</td>
<td style="text-align: right;">Byte(s)</td>
<td style="text-align: right;">Sector(s)</td>
</tr>
<tr>
<td>RomWBW Partition Start</td>
<td style="text-align: right;">1 MB</td>
<td style="text-align: right;">2,048</td>
<td style="text-align: right;">–</td>
<td style="text-align: right;">–</td>
</tr>
<tr>
<td>RomWBW Partition Size</td>
<td style="text-align: right;">512 MB</td>
<td style="text-align: right;">1,048,576</td>
<td style="text-align: right;">–</td>
<td style="text-align: right;">–</td>
</tr>
<tr>
<td>FAT Filesystem Start</td>
<td style="text-align: right;">513 MB</td>
<td style="text-align: right;">1,050,624</td>
<td style="text-align: right;">520 MB</td>
<td style="text-align: right;">1,064,960</td>
</tr>
<tr>
<td>FAT Filesystem Size</td>
<td style="text-align: right;">384 MB</td>
<td style="text-align: right;">786,432</td>
<td style="text-align: right;">384 MB</td>
<td style="text-align: right;">786,432</td>
</tr>
<tr>
<td>\&lt;end&gt;</td>
<td style="text-align: right;">897 MB</td>
<td style="text-align: right;">1,851,392</td>
<td style="text-align: right;">904 MB</td>
<td style="text-align: right;">1,837,056</td>
</tr>
</tbody>
</table>
<p><strong>NOTE:</strong> RomWBW is not limited to these partition table entries. You
can change the size and location of the RomWBW and/or FAT partitions to
increase/decrease the number of slices or FAT filesystem size. Doing so
would require using <code>FDISK80</code> to define your own custom disk layout and
initializing your filesystems manually.</p>
<p>The <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20System%20Guide.pdf">RomWBW System
Guide</a>
has more information on the standard disk layouts as implemented in the
Combo Disk Images. Additionally, there is a document called “Hard Disk
Anatomy.pdf” in the Doc directory of the RomWBW distribution with
detailed information on the standard disk layouts.</p>
<h3 id="combo-hard-disk-image">Combo Hard Disk Image</h3>
<p>The Combo Disk Image is essentially just a single disk image that has
several of the individual filesystem images (slices) already
concatenated together using the standard disk layout described above.
The Combo Disk Image includes the partition table of the standard disk
layout and the following 6 slices in the positions indicated:</p>
<table>
<thead>
<tr>
<th><strong>Slice</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Slice 0</td>
<td>DRI CP/M 2.2 Operating System</td>
</tr>
<tr>
<td>Slice 1</td>
<td>ZCPR-DJ &amp; ZSDOS 1.1 Operating System</td>
</tr>
<tr>
<td>Slice 2</td>
<td>NZCOM ZCPR 3.4 Operating System</td>
</tr>
<tr>
<td>Slice 3</td>
<td>DRI CP/M 3 Operating System</td>
</tr>
<tr>
<td>Slice 4</td>
<td>ZPM3 Operating System</td>
</tr>
<tr>
<td>Slice 5</td>
<td>WordStar v4 &amp; ZDE Applications</td>
</tr>
<tr>
<td>Slice 6-63</td>
<td><em>blank unformatted</em></td>
</tr>
</tbody>
</table>
<p>There are actually 2 Combo Disk Images in the distribution. One for an
hd512 disk layout (hd512_combo.img) and one for an hd1k disk layout
(hd1k_combo.img). Simply use the image file that corresponds to your
desired hard disk layout. Review the information in <a href="#hard-disk-layouts">Hard Disk
Layouts</a> if you need more information of the disk
layout options.</p>
<blockquote>
<p><strong>Note</strong>: Apart from the hd512 and hd1k Combo Disk Images (mentioned
above) there are actually a number of other <code>hd1k_*_combo.img</code> files.
These additional combo files are platform (generally romless)
specific, and should be ignored unless you are on one of these
platforms. If you are on one of these platforms you must use the
correct combo file</p>
</blockquote>
<p>The Combo Disk Image actually only contains the initial partition table,
and the first 6 slices (Slice 0 to 5), this is approximately 49MB in
size. While the partition table reserves space to store 64 CP/M
filesystem slices as well as a single 384MB FAT filesystem, these areas
remain empty, and must be initialized manually using <code>CLRDIR</code> for CP/M
filesystems and <code>FAT FORMAT</code> for the FAT filesystem.</p>
<h4 id="combo-disk-image-capacity">Combo Disk Image Capacity</h4>
<p>The standard hard disk layout used by the Combo Disk Image was designed
to fit well on a 1GB hard disk. The 64 CP/M slices (approximately 512MB)
and 384MB FAT filesystem all fit well within a 1GB hard disk. This size
choice was a bit arbitrary, but based on the idea that 1GB CF/SD/USB
Media is easy and cheap to acquire.</p>
<p>It is fine if your hard disk is smaller than 1GB. It just means that it
will not be possible to use the pre-allocated FAT filesystem partition
and any CP/M filesystem slices that don’t fit. The true number of CP/M
filesystem slices that will fit on your specific physical hard disk can
be calculated as described in <a href="#hard-disk-capacity">Hard Disk Capacity</a>.</p>
<p>If you attempt to access a slice past the end of the physical hard disk
you will get “no disk” errors. You should calculate the maximum number
of slices your hard disk will support and do not exceed this number.</p>
<h4 id="combo-disk-image-advice">Combo Disk Image Advice</h4>
<p>A great way to maintain your own data on a hard disk is to put your data
in slices beyond the first 6. By doing so, you can always “re-image”
your drive media with the Combo Disk Image without overlaying the data
stored in the slices beyond the first 6. Just be very careful to use the
same combo image layout (hd512 or hd1k) as you used originally.</p>
<h3 id="custom-hard-disk-image">Custom Hard Disk Image</h3>
<p>For hard disks, each .img file represents a single slice (CP/M
filesystem). Since a hard disk can contain many slices, you can just
concatenate the slices (.img files) together to create your desired hard
disk image.</p>
<p>If you look in the Binary directory of the distribution, you will see
that there are more disk (slice) images than the 6 that are included in
the Combo Disk Images. These supplemental disk images are identified by
looking for the files that start with hd1k_ or hd512_.</p>
<h4 id="adding-slices-to-combo-image">Adding Slices to Combo Image</h4>
<p>You can add slices to the Combo Disk Images simply by tacking slices
onto the end. For example, if you want to add a slice containing the MSX
ROMs to the end of the combo image, you could use one of the following
command lines depending on your operating system:</p>
<p>Windows:</p>
<p><code>COPY /B hd1k_combo.img + hd1k_msxroms.img my_hd.img</code></p>
<p>Linus/MaxOS:</p>
<p><code>cat hd1k_combo.img hd1k_msxroms.img &gt;my_hd.img</code></p>
<p>Note that you <strong>must</strong> be sure to use either the hd1k_ or hd512_
prefixed files together. You cannot mix them.</p>
<h4 id="creating-a-new-custom-image">Creating a new Custom Image</h4>
<p>If you want to create a completely custom hard disk image that is not
based on the existing combo image, you can generate a disk image
entirely from scratch using whatever slices you want in whatever order
you like.</p>
<p>For example, if you want to create a hard disk image that has slices for
CP/M 2.2, CP/M 3, and WordStar in the hd512 format, you would use the
command line of your modern computer to create the final image:</p>
<p>Windows:</p>
<p><code>COPY /B hd512_cpm22.img + hd512_cpm3.img + hd512_ws hd.img</code></p>
<p>Linux/MacOS:</p>
<p><code>cat hd512_cpm22.img hd512_cpm3.img hd512_ws &gt;hd.img</code></p>
<p><strong>NOTE:</strong> For the hd1k disk layout, you <strong>must</strong> prepend the prefix file
called hd1k_prefix.dat which contains the required partition table. So,
for an hd1k layout you would use the following:</p>
<p>Windows:</p>
<p><code>COPY /B hd1k_prefix.dat + hd1k_cpm22.img + hd1k_cpm3.img + hd1k_ws hd.img</code></p>
<p>Linux/MacOS:</p>
<p><code>cat hd1k_prefix.dat hd1k_cpm22.img hd1k_cpm3.img hd1k_ws &gt;hd.img</code></p>
<blockquote>
<p><strong>Note</strong>: Apart from the hd1k_prefix.dat file (mentioned above) there
are actaully a number of other <code>hd1k_*_prefix.dat</code> files. These
additional prefix files are platform (generally romless) specific, and
should be ignored unless you are on one of these platforms. If you are
on one of these platforms you must use the correct prefix file</p>
</blockquote>
<p>In all of the examples above, the resulting file (hd.img) would now be
written to your hard disk media and would be ready to use in a RomWBW
system.</p>
<p>If you wish to further customize or create new disk image definitions,
please refer to the ReadMe.txt file in the Source/Images directory.</p>
<h3 id="writing-hard-disk-images">Writing Hard Disk Images</h3>
<p>Once you have chosen a Combo Hard Disk Image file or prepared your own
custom hard disk image file, it will need to be written to the media
using your modern computer. When using this method, the disk will be
partitioned and setup with 1 or more slices containing ready-to-run
bootable operating systems.</p>
<p>To write a hard disk image file onto your actual media (actual hard disk
or CF/SD/USB Media), you need to use an image writing utility on your
modern computer. Your modern computer will need to have an appropriate
interface or slot that accepts the media. To actually copy the image</p>
<ul>
<li>On Linux or MacOS , you can use the <code>dd</code> command.</li>
<li>On Windows, in the “Tools” directory of the distribution, there is an
  application called Win32DiskImager.</li>
</ul>
<p>In all cases, the image file should be written to the media starting at
the very first block or sector of the media. This is the default
behaviour on all software.</p>
<p>To be entirely clear, writing a disk image file to your hard disk media
will overwrite an pre-existing partition table and the number of slices
that your image file contains. It will not overwrite or corrupt slices
beyond those in the image file. As a result, you can use additional
slices as a place to maintain your personal data because these slices
will survive re-imaging of the media. If you setup a FAT partition on
your media, it will also survive the imaging process.</p>
<h4 id="media-usage-and-initialization">Media Usage and Initialization</h4>
<p>Once you have copied the image onto the hard disk media, you can move
the media over to your RomWBW system. You can then boot to the operating
system slices by specifying (<strong><em>\&lt;diskunit&gt;.\&lt;slice&gt;</em></strong>) at the RomWBW
Boot Loader command prompt. See the section <a href="#starting-operating-systems-from-disk">Starting Operating Systems
from Disk</a> for further details</p>
<p>You are not limited to the number of slices that are contained in the
image that you write to your hard disk media. You can use additional
slices as long your media has room for them.</p>
<p>However, writing the disk image will not initialize the additional
slices. You will need to use the <code>CLRDIR</code> application to initialize any
un-initialized slice before its first use, and and optionally <code>SYSCOPY</code>
if you want th slice to be bootable. If you use the combo image this
applies to slices 6 thru 63. The procedure for this is documented in the
<a href="#clearing-formatting-drives">Clearing (Formatting) Drives</a> section.</p>
<p>Likewise, the pre-allocated FAT partition must still be formatted using
<code>FAT FORMAT</code> in order to actually use it (see <a href="#fat-filesystem-preparation">FAT Filesystem
Preparation</a>). Alternatively, the FAT
partition can be formatted on a modern computer.</p>
<h4 id="re-imaging-existing-media">Re-Imaging Existing Media</h4>
<p>In order for your additional slices and/or FAT partition to survive
re-imaging, you <strong>must</strong> follow these rules:</p>
<ul>
<li>Do not modify the partition table of the media using FDISK80 or any
  other partition management tools.</li>
<li>Ensure that your hard disk image file uses the same disk layout
  approach (hd512 or hd1k) as previously used on the media.</li>
</ul>
<h3 id="writing-hard-disk-slices">Writing Hard Disk Slices</h3>
<p>This section covers techniques to copy partial images onto pre-existing
media, in effect performing a selective slice copy. These techniques
currently <strong>only</strong> apply to hd1k formatted media, which has a partition
table entry, and a convenient 1MB size metric. However adapting to hd512
is possible, but left to the user.</p>
<p>You will need to have access to a Linux/MacOS machine, or have the Linux
tools for Windows installed, including the <code>dd</code> command line tool. For
Windows there are multiple options for installing <code>dd</code> including
<a href="https://www.msys2.org/">MSYS2</a>, <a href="https://www.cygwin.com/">CygWin</a>, and
<a href="http://www.chrysocome.net/dd">dd for Windows</a>.</p>
<p><strong>WARNING</strong>: The <code>dd</code> command is a low-level utility that writes
directly to raw disk sectors with almost no safety checks. It is very
easy to corrupt a disk if this tool is used incorrectly.</p>
<p>The <code>dd</code> command supports options to define precisely source and
destination offsets and sizes to copy. From the documentation of <code>dd</code>
the following options are important.</p>
<pre><code>     if=file  Read input from file instead of the standard input.
     of=file  Write output to file instead of the standard output.  
     skip=n   Skip n blocks from the beginning of the input before
              copying. 
     seek=n   Seek n blocks from the beginning of the output before
              copying.
     count=n  Copy only n input blocks.
     bs=n     Set both input and output block size to n bytes instead
              of the default 512
</code></pre>
<p>The best approach is to copy data to the RomWBW partition. To do this,
you must first determine the name that your operating system is using
for the RomWBW disk and partition. An easy way to determine this may be
the linux <code>mount</code> command, which lists the currently mounted partitions.
From here you can more easily determine the naming scheme used by your
operating system.</p>
<p>Typically disk devices are named something like <code>/dev/disk9</code> or
<code>/dev/sdg</code>, noting above the <code>g</code> is a alphabetic and it could be any
letter. This naming is arbitrary and depend on the operating system, and
the specific hardware connecting the device</p>
<p>Partitions are typically named by simply adding a number after the name
of the hard disk device. For example, the first partition could be
<code>/dev/disk9s1</code>, <code>/dev/sdg1</code>, or <code>/dev/sdgp1</code>.</p>
<p>In the following examples we use the above <code>dd</code> options, noting the
<code>of=</code> option is the RomWBW target partition.</p>
<p>** NOTE ** A second approach (Examples 3 and 4) is to address the
hard disk as a raw disk device and we take explicit steps to calculate
the start of the RomWBW partition. While this works, it is better to use
the partition relative approach.</p>
<p>The commands in the examples below are run from the <code>Binary</code> folder of
RomWBW distribution.</p>
<h4 id="example-1-copy-the-games-image-to-an-empty-slice-of-our-media">Example 1 : Copy the Games image to an empty slice of our media</h4>
<p>In this example we will copy the (hd1k) games image to Slice 6 (free) of
our existing media. In this example we assume the media has already been
formatted with the combo image, which already contains 6 slices
(numbered from 0 to 5). We are just copying the needed slice to the
existing media as a new slice (number 6) after the existing slices
making it the 7th slice.</p>
<pre><code>Binary % sudo dd if=hd1k_games.img of=/dev/sdg1 seek=6 bs=8M

Password:

1+0 records in
1+0 records out
8388608 bytes transferred in 1.917296 secs (4375228 bytes/sec)
</code></pre>
<p>Since bs=8MB the <code>seek=6</code> skips the first 6 (8MB slices) slices (in the
target image) and writes the games image to the 7th slice.</p>
<h4 id="example-2-copy-the-entire-combo-image-without-replacing-partition-table">Example 2 : Copy the entire Combo Image without replacing partition table</h4>
<p>In all of the following examples we use <code>bs=1MB</code> to defines the block
size used in other parameters. This is convenient since the combo image
reserves 1MB for the partition table at the start of the disk.</p>
<p>In this example we will copy the (hd1k) combo image (which includes a
partition table) over our media without replacing the partition table.
In this example we assume the media has already been formatted with the
combo image, and we have modified the partition table, which we do not
want to overwrite.</p>
<pre><code>Binary % sudo dd if=hd1k_combo.img of=/dev/sdg1 skip=1 bs=1M

Password:

48+0 records in
48+0 records out
50331648 bytes transferred in 11.503776 secs (4745528 bytes/sec)
</code></pre>
<p>The <code>skip=1</code> skips the first 1MB (partition table) in the input file,
effectively stripping out the combo images partition table, before
overwriting the slices in the target partition.</p>
<h4 id="example-3-copy-the-combo-image-without-replacing-partition-table">Example 3 : Copy the Combo Image without replacing partition table</h4>
<p>This example is identical to Example 2 except it writes to the target
disk device itself (<code>of=/dev/disk9</code>), not the target partition.</p>
<pre><code>Binary % sudo dd if=hd1k_combo.img of=/dev/disk9 skip=1 seek=1 bs=1M

Password:

48+0 records in
48+0 records out
50331648 bytes transferred in 11.503776 secs (4745528 bytes/sec)
</code></pre>
<p>The <code>skip=1</code> skips the first 1MB in the input file, and likewise
<code>seek=1</code> skips the first 1MB of the target media file we are writing to,
thus in effect we are skipping the first 1MB, which contains the
partition table itself.</p>
<h4 id="example-4-copy-the-games-image-to-an-empty-slice-of-our-media">Example 4 : Copy the Games image to an empty slice of our media</h4>
<p>In this example we will copy the (hd1k) games image to Slice 6 (free) of
our existing media. In this example we assume the media has already been
formatted with the combo image, which already contains 6 slices
(numbered from 0 to 5) We are just coping the needed slice to this
existing media as a new slice (number 6) after the existing slices
making it the 7th slice.</p>
<pre><code>Binary % sudo dd if=hd1k_games.img of=/dev/disk9 seek=49 bs=1M

Password:

8+0 records in
8+0 records out
8388608 bytes transferred in 1.917296 secs (4375228 bytes/sec)
</code></pre>
<p>The <code>seek=49</code> skips the first 49MB of the media file we are writing to.
49 is calculated as <code>(slice number * 8) + 1</code>, where 8 is the size of a
slice and 1 is the size of the partition table im megabytes. Thus we are
skipping 6 slices (in the combo image) and writing to the 7th slice.</p>
<h1 id="operating-systems">Operating Systems</h1>
<p>One of the primary goals of RomWBW is to expose a set of generic
hardware functions that make it easy to adapt operating systems to any
hardware supported by RomWBW. As a result, there are now 8 operating
systems that have been adapted to run under RomWBW. The adaptations are
identical for all hardware supported by RomWBW because RomWBW hides all
hardware specifics from the operating system.</p>
<p>By design, the operating systems provided with RomWBW are original and
unmodified from their original distribution. Patches published by the
authors are generally included or applied. The various enhancements
RomWBW provides (such as hard disk slices) are implemented entirely
within the system adaptation component of each operating system (e.g.,
CP/M CBIOS). As a result, each operating system should function exactly
as documented by the authors and retain maximum compatibility with
original applications.</p>
<p>Note that all of the operating systems included with RomWBW support the
same basic filesystem format from DRI CP/M 2.2 (except for p-System). As
a result, a formatted filesystem will be accessible to any operating
system. The only possible issue is that if you turn on date/time
stamping using the newer OSes, the older OSes will not understand this.
The older OS will not corrupt the files, but the date/time stamps will
not be maintained.</p>
<p>The following sections briefly describe the operating system options
currently available and brief operating notes.</p>
<h2 id="digital-research-cpm-22">Digital Research CP/M 2.2</h2>
<p>This is the most widely used variant of the Digital Research operating
systems. It has the most basic feature set, but is essentially the
compatibility metric for all other CP/M-like operating systems including
those listed below.</p>
<p>If you are new to the CP/M world, I would recommend using this CP/M
variant to start with simply because it is the most stable and you are
less likely to encounter compatibility issues.</p>
<h4 id="documentation">Documentation</h4>
<ul>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/CPM%20Manual.pdf">CPM
  Manual</a></li>
</ul>
<h4 id="boot-disk">Boot Disk</h4>
<p>To make a bootable CP/M disk, use the RomWBW <code>SYSCOPY</code> tool to place a
copy of the operating system on the boot track of the disk. The RomWBW
ROM disk has a copy of the boot track call “CPM.SYS”. For example:</p>
<p><code>SYSCOPY C:=B:CPM.SYS</code></p>
<h4 id="character-device-mapping">Character Device Mapping</h4>
<p>Character device mapping under CP/M 2.2 has 3 layers:</p>
<p>CP/M Logical Device –&gt; CP/M Physical Device –&gt; RomWBW HBIOS Device</p>
<p>The CP/M Logical Devices are:</p>
<table>
<thead>
<tr>
<th>Device</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CON:</code></td>
<td>System console device, used by CCP for communication with the operator</td>
</tr>
<tr>
<td><code>RDR:</code></td>
<td>Paper tape reader device</td>
</tr>
<tr>
<td><code>PUN:</code></td>
<td>Paper tape punch device</td>
</tr>
<tr>
<td><code>LST:</code></td>
<td>Output list device</td>
</tr>
</tbody>
</table>
<p>The CP/M Physical Devices are:</p>
<table>
<thead>
<tr>
<th>Device</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TTY:</code></td>
<td>Teletype device (slow speed console)</td>
</tr>
<tr>
<td><code>CRT:</code></td>
<td>Cathode ray tube device (high speed console)</td>
</tr>
<tr>
<td><code>BAT:</code></td>
<td>Batch processing (input from <code>RDR:</code>, output to <code>LST:</code>)</td>
</tr>
<tr>
<td><code>UC1:</code></td>
<td>User-defined console</td>
</tr>
<tr>
<td><code>PTR:</code></td>
<td>Paper tape reader (high speed reader)</td>
</tr>
<tr>
<td><code>UR1:</code></td>
<td>User-defined reader #1</td>
</tr>
<tr>
<td><code>UR2:</code></td>
<td>User-defined reader #2</td>
</tr>
<tr>
<td><code>PTP:</code></td>
<td>Paper tape punch (high speed punch)</td>
</tr>
<tr>
<td><code>UP1:</code></td>
<td>User-defined punch #1</td>
</tr>
<tr>
<td><code>UP2:</code></td>
<td>User-defined punch #2</td>
</tr>
<tr>
<td><code>LPT:</code></td>
<td>Line printer</td>
</tr>
<tr>
<td><code>UL1:</code></td>
<td>User-defined list device #1</td>
</tr>
</tbody>
</table>
<p>CP/M Logical Devices are mapped to CP/M Physical Devices via the IOBYTE
at 0x0003 as shown below.</p>
<table>
<thead>
<tr>
<th>Logical Device</th>
<th><code>LST:</code></th>
<th><code>PUN:</code></th>
<th><code>RDR:</code></th>
<th><code>CON:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>IOBYTE Bits</td>
<td>7 6</td>
<td>5 4</td>
<td>3 2</td>
<td>1 0</td>
</tr>
<tr>
<td>0 (0b00)</td>
<td><code>TTY:</code></td>
<td><code>TTY:</code></td>
<td><code>TTY:</code></td>
<td><code>TTY:</code></td>
</tr>
<tr>
<td>1 (0b01)</td>
<td><code>CRT:</code></td>
<td><code>PTP:</code></td>
<td><code>PTR:</code></td>
<td><code>CRT:</code></td>
</tr>
<tr>
<td>2 (0b10)</td>
<td><code>LPT:</code></td>
<td><code>UP1:</code></td>
<td><code>UR1:</code></td>
<td><code>BAT:</code></td>
</tr>
<tr>
<td>3 (0b11)</td>
<td><code>UL1:</code></td>
<td><code>UP2:</code></td>
<td><code>UR2:</code></td>
<td><code>UC1:</code></td>
</tr>
</tbody>
</table>
<p>The mappings above can be managed using the <code>STAT</code> command. This command
essentially just modifies the IOBYTE value.</p>
<p>CP/M Physical Devices are mapped to RomWBW HBIOS devices during the boot
process depending on the number of HBIOS Char devices in the system.</p>
<p>All CP/M Physical Devices are initially mapped to HBIOS Char 0. If
additional HBIOS Char devices are available in the system, they will be
mapped as below:</p>
<table>
<thead>
<tr>
<th>CP/M</th>
<th>RomWBW HBIOS</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TTY:</code></td>
<td>Char 0</td>
</tr>
<tr>
<td><code>CRT:</code></td>
<td>CRT</td>
</tr>
<tr>
<td><code>BAT:</code></td>
<td>CP/M RDR/LST</td>
</tr>
<tr>
<td><code>UC1:</code></td>
<td>Char 1</td>
</tr>
<tr>
<td><code>PTR:</code></td>
<td>Char 1</td>
</tr>
<tr>
<td><code>UR1:</code></td>
<td>Char 2</td>
</tr>
<tr>
<td><code>UR2:</code></td>
<td>Char 3</td>
</tr>
<tr>
<td><code>PTP:</code></td>
<td>Char 1</td>
</tr>
<tr>
<td><code>UP1:</code></td>
<td>Char 2</td>
</tr>
<tr>
<td><code>UP2:</code></td>
<td>Char 3</td>
</tr>
<tr>
<td><code>LPT:</code></td>
<td>Char 1</td>
</tr>
<tr>
<td><code>UL1:</code></td>
<td>Char 2</td>
</tr>
</tbody>
</table>
<p>Normally, the HBIOS Console device (Loader prompt) is on HBIOS Device
Char 0. If it has been reassigned to a different HBIOS character device
before launching CP/M, then the above mapping will be modified. TTY:
will be assigned to the current HBIOS console Char device. The remaining
assignments will be filled in with the other Char devices as available.</p>
<h4 id="notes">Notes</h4>
<ul>
<li>
<p>You can change media, but it must be done while at the OS command
  prompt and you <strong>must</strong> warm start CP/M by pressing ctrl-C. This is a
  CP/M 2.2 constraint and is well documented in the DRI manual.</p>
</li>
<li>
<p><code>SUBMIT.COM</code> has been patched per DRI to always place submit files on
  A:. This ensures the submitted file will always be properly executed.</p>
</li>
<li>
<p>The original versions of DDT, DDTZ, and ZSID used the RST 38 vector
  which conflicts with interrupt mode 1 use of this vector. The DDT,
  DDTZ, and ZSID applications in RomWBW have been modified to use RST 30
  to avoid this issue.</p>
</li>
<li>
<p>Z-System applications will not run under CP/M 2.2. For example, the
  <code>LDDS</code> date stamper will not work.</p>
</li>
</ul>
<h2 id="z-system">Z-System</h2>
<p>Z-System is the most popular non-DRI CP/M workalike “clone” which is
generally referred to as Z-System. Z-System is intended to be an
enhanced version of CP/M and should run all CP/M 2.2 applications. It is
optimized for the Z80 CPU (as opposed to 8080 for CP/M) and has some
significant improvements such as date/time stamping of files.</p>
<p>Z-System is a somewhat ambiguous term because there are multiple
generations of this software. RomWBW Z-System is a combination of both
ZCPR-DJ (the CCP) and ZSDOS 1.1 (the BDOS) when referring to Z-System.
The latest version of Z-System (ZCPR 3.4) is also provided with RomWBW
via the NZ-COM adaptation (see below).</p>
<h4 id="documentation_1">Documentation</h4>
<ul>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/ZCPR%20Manual.pdf">ZCPR
  Manual</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/ZCPR-DJ.doc">ZCPR-DJ</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/ZSDOS%20Manual.pdf">ZSDOS
  Manual</a></li>
</ul>
<h4 id="boot-disk_1">Boot Disk</h4>
<p>To make a bootable Z-System disk, use the RomWBW <code>SYSCOPY</code> tool to place
a copy of the operating system on the boot track of the disk. The RomWBW
ROM disk has a copy of the boot track call “ZSYS.SYS”. For example:</p>
<p><code>SYSCOPY C:=B:ZSYS.SYS</code></p>
<h4 id="character-device-mapping_1">Character Device Mapping</h4>
<p>Mapping of character devices to RomWBW HBIOS Character devices operates
exactly the same as described in <a href="#digital-research-cpm-2.2">Digital Research CP/M
2.2</a>. The CP/M 2.2 <code>STAT</code> command is used to
manipulate the device mappings.</p>
<h4 id="notes_1">Notes</h4>
<ul>
<li>
<p>Although most CP/M 2.2 applications will run under Z-System, some may
  not work as expected. The best example is PIP which is not aware of
  the ZSDOS paths and will fail in some scenarios (use <code>COPY</code> instead).</p>
</li>
<li>
<p>Although ZSDOS can recognize a media change in some cases, it will not
  always work. You should only change media at a command prompt and be
  sure to warm start the OS with a ctrl-C.</p>
</li>
<li>
<p>ZSDOS has a concept of fast relog of drives. This means that after a
  warm start, it avoids the overhead of relogging all the disk drives.
  There are times when this causes issues. After using tools like
  <code>CLRDIR</code> or MAP, you may need to run “RELOG” to get the drive properly
  recognized by ZSDOS.</p>
</li>
<li>
<p>ZSVSTAMP expects to be running under the ZCPR 3.X command processor.
  By default, RomWBW uses ZCPR 1.0 (intentionally, to reduce space
  usage) and ZSVSTAMP will just abort in this case. It will work fine if
  you implement NZCOM. ZSVSTAMP is included solely to facilitate usage
  if/when you install NZCOM.</p>
</li>
<li>
<p>Many of the tools can be configured (using either ZCNFG or DSCONFIG).
  The configuration process modifies the actual application file itself.
  This will fail if you try to modify one that is on the ROM disk
  because it will not be able to update the image.</p>
</li>
<li>
<p>DATSWEEP can be configured using DSCONFIG. However, DSCONFIG itself
  needs to be configured first for proper terminal emulation by using
  SETTERM. So, run SETTERM on DSCONFIG before using DSCONFIG to
  configure DATSWEEP!</p>
</li>
<li>
<p>Generic CP/M PIP and ZSDOS path searching do not mix well if you use
  PIP to copy to or from a directory in the ZSDOS search path. Best to
  use COPY from the ZSDOS distribution.</p>
</li>
</ul>
<h2 id="nzcom-automatic-z-system">NZCOM Automatic Z-System</h2>
<p>NZCOM is a much further refined version of Z-System (ZCPR 3.4). NZCOM
was sold as an enhancement for existing users of CP/M 2.2 or ZSDOS. For
this reason, (by design) NZCOM does not provide a way to boot directly
from disk. Rather, it is loaded after the system boots into a host OS.
On the RomWBW NZCOM disk images, the boot OS is ZSDOS 1.1. A
<code>PROFILE.SUB</code> file is included which automatically launches NZCOM as
soon as ZSDOS loads.</p>
<p>NZCOM is a companion product to Z3PLUS, they are almost identical having
been written by the same team. The only difference is the base operating
system on which they run, but the architecture, the tools, libraries,
files, etc are all primarily the same.</p>
<p>NZCOM is highly configurable. The RomWBW distribution has been
configured in the most basic way possible. You should refer to the
documentation and use <code>MKZCM</code> as desired to customize your system.</p>
<p>NZCOM has substantially more functionality than CP/M or basic Z-System.
It is important to read the “NZCOM Users Manual.pdf” document in order
to use this operating system effectively.</p>
<h4 id="documentation_2">Documentation</h4>
<ul>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/NZCOM%20Users%20Manual.pdf">NZCOM Users
  Manual</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/Z-System%20Users%20Guide.pdf">Z-System Users
  Guide</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/ZCPR3.3%20User%20Guide.pdf">ZCPR3.3 User
  Guide</a></li>
</ul>
<h4 id="boot-disk_2">Boot Disk</h4>
<p>Since NZ-COM boots via Z-System, you can make a bootable NZ-COM disk
using <code>ZSYS.SYS</code> as described in <a href="#z-system">Z-System</a> above. You will
need to add a <code>PROFILE.SUB</code> file to auto-start NZ-COM itself.</p>
<h4 id="character-device-mapping_2">Character Device Mapping</h4>
<p>Mapping of character devices to RomWBW HBIOS Character devices operates
exactly the same as described in <a href="#digital-research-cpm-2.2">Digital Research CP/M
2.2</a>. However, it is <strong>not</strong> possible to
manipulate the CP/M Logical to Physical device mapping using the <code>STAT</code>
command. The mapping is static.</p>
<p>Note: A custom ZCPR IOP module could theoretically be used to manage the
character device mappings. RomWBW does not provide this module and
writing an IOP module is beyond the scope of this document.</p>
<h4 id="notes_2">Notes</h4>
<ul>
<li>
<p>All of the notes for <a href="#z-system">Z-System</a> above generally apply to
  NZCOM.</p>
</li>
<li>
<p>There is no <code>DIR</code> command, you must use <code>SDZ</code> instead. If you don’t
  like this, look into the <code>ALIAS</code> facility.</p>
</li>
<li>
<p>For consistency with other ZCPR3 operating systems (ZPM3, Z3PLUS) the
  SHOW.COM and HELP.COM command files were renamed to ZSHOW.COM and
  ZHELP.COM</p>
</li>
</ul>
<h2 id="digital-research-cpm-3">Digital Research CP/M 3</h2>
<p>This is the Digital Research follow-up product to their very popular
CP/M 2.2 operating system. While highly compatible with CP/M 2.2, it
features many enhancements and is not 100% compatible. It makes direct
use of banked memory to increase the user program space (TPA). It also
has a new suite of support tools and help system.</p>
<h4 id="documentation_3">Documentation</h4>
<ul>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/CPM3%20Users%20Guide.pdf">CPM3 Users
  Guide</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/CPM3%20Command%20Summary.pdf">CPM3 Command
  Summary</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/CPM3%20Programmers%20Guide.pdf">CPM3 Programmers
  Guide</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/CPM3%20System%20Guide.pdf">CPM3 System
  Guide</a></li>
</ul>
<h4 id="boot-disk_3">Boot Disk</h4>
<p>To create (or update) a CP/M 3 boot drive, you must place <code>CPMLDR.SYS</code>
on the system track of the disk. You must also place <code>CPM3.SYS</code> and
<code>CCP.COM</code> on the target drive as regular files. Do <strong>not</strong> place
CPM3.SYS on the boot track. <code>CPMLDR.SYS</code> chain loads <code>CPM3.SYS</code> which
must exist as a regular file on the disk. Subsequently, <code>CPM3.SYS</code> loads
<code>CCP.COM</code>.</p>
<p>The CP/M 3 boot files are not included on the ROM disk due to space
constraints. You will need to transfer the following files to your
system from the RomWBW distribution directory Binary/CPM3. You can use
XModem for this (or any of the mechanisms in <a href="#transferring-files">Transferring
Files</a>.</p>
<ul>
<li><code>CPMLDR.SYS</code></li>
<li><code>CPM3.SYS</code> or <code>CPM3BNK.SYS</code></li>
<li><code>CCP.COM</code></li>
</ul>
<p>The <code>CPM3.SYS</code> boot file is provided in 2 versions. In the Binary/CPM3
distribution directory, <code>CPM3.SYS</code> is the “non-banked” version of CP/M
3. The <code>CPM3BNK.SYS</code> file is the “banked” version of CP/M 3. You almost
certainly want to transfer the banked <code>CPM3BNK.SYS</code> version.</p>
<p>After transferring the boot files to your RomWBW system, you will need
to use <code>SYSCOPY</code> to place <code>CPMLDR.SYS</code> on the boot track of the target
drive. <code>CPM3.SYS</code> and <code>CCP.COM</code> can be copied to the target drive using
any standard file copy tool such as <code>PIP</code> or <code>COPY</code>.</p>
<p>You do not need to be booted into CP/M 3 to create or update a CP/M 3
disk. The recommended approach is to boot CP/M 2.2 or Z-System from ROM.
Transfer the boot files to the RAM disk. Then simply copy the files onto
the CP/M 3 disk. Assuming the target CP/M 3 disk is F:, you can use the
following commands to place the files on the target drive:</p>
<pre><code>SYSCOPY F:=A:CPMLDR.SYS
COPY A:CPM3BNK.SYS F:CPM3.SYS
COPY A:CCP.COM F:
</code></pre>
<p>Note in the example above that <code>CPM3BNK.SYS</code> is renamed to <code>CPM3.SYS</code> in
the copy command.</p>
<h4 id="character-device-mapping_3">Character Device Mapping</h4>
<p>Character device mapping under CP/M 3 has 3 layers:</p>
<p>CP/M Logical Device –&gt; CP/M Physical Device –&gt; RomWBW HBIOS Device</p>
<p>The primary CP/M Logical Devices are:</p>
<table>
<thead>
<tr>
<th>Device</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CON:</code></td>
<td>Console input or output device</td>
</tr>
<tr>
<td><code>AUX:</code></td>
<td>Auxiliary Input or Output Device</td>
</tr>
<tr>
<td><code>LST:</code></td>
<td>List output device, usually the printer</td>
</tr>
</tbody>
</table>
<p>There are various aliases for these devices. Please refer to the CP/M 3
Users Guide for more information.</p>
<p>The mapping of CP/M 3 Logical Devices to Physical Devices is performed
using the <code>DEVICE</code> command.</p>
<p>CP/M 3 refers to Physical Character Devices using the <code>COM</code> device
label. These <code>COM</code> devices are mapped directly to the RomWBW HBIOS Char
devices as described below:</p>
<p><code>COM0:</code> –&gt; HBIOS Char 0<br />
<code>COM1:</code> –&gt; HBIOS Char 1<br />
<code>COM2:</code> –&gt; HBIOS Char 2<br />
      . . .<br />
<code>COMn:</code> –&gt; HBIOS Char n</p>
<h4 id="notes_3">Notes</h4>
<ul>
<li>
<p>The <code>COPYSYS</code> command described in the DRI CP/M 3 documentation is not
  provided with RomWBW. The RomWBW <code>SYSCOPY</code> command is used instead.</p>
</li>
<li>
<p>Although CP/M 3 is generally able to run CP/M 2.2 programs, this is
  not universally true. This is especially true of the utility programs
  included with the operating system. For example, the <code>SUBMIT</code> program
  of CP/M 3 is completely different/incompatible from the <code>SUBMIT</code>
  program of CP/M 2.2.</p>
</li>
<li>
<p>RomWBW fully supports CP/M 3 file date/time stamping, but this
  requires that the disk be properly initialized for it. This process
  has not been performed on the CP/M 3 disk image. Follow the CP/M 3
  documentation to complete this process, if desired.</p>
</li>
</ul>
<h2 id="z3plus-z-system-for-cpm-plus">Z3PLUS Z-System for CP/M-Plus</h2>
<p>Z3PLUS is a much further refined version of Z-System (ZCPR 3.4). Z3PLUS
was sold as an enhancement for existing users of CP/M 3. For this
reason, (by design) Z3PLUS does not provide a way to boot directly from
disk. Rather, it is loaded after the system boots into CP/M 3. A
<code>PROFILE.SUB</code> file is included which automatically launches Z3PLUS as
soon as CP/M 3 loads.</p>
<p>Z3PLUS is a companion product to NZ-COM, they are almost identical
having been written by the same team. The only difference is the base
operating system on which they run, but the architecture, the tools,
libraries, files, etc are all primarily the same.</p>
<p>Z3PLUS is highly configurable. The RomWBW distribution has been
configured in the most basic way possible. You should refer to the
documentation to customize your system.</p>
<p>Z3PLUS has substantially more functionality than CP/M 3 or the basic
Z-System. It is important to read the “Z3PLUS Users Manual.pdf” document
in order to use this operating system effectively.</p>
<h4 id="documentation_4">Documentation</h4>
<ul>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/Z3PLUS%20Users%20Manual.pdf">Z3PLUS Users
  Manual</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/Z-System%20Users%20Guide.pdf">Z-System Users
  Guide</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/ZCPR3.3%20User%20Guide.pdf">ZCPR3.3 User
  Guide</a></li>
</ul>
<h4 id="boot-disk_4">Boot Disk</h4>
<p>Since Z3PLUS boots via CP/M 3, you first must make the disk CP/M 3
bootable. This is not a simple process, as well as placing <code>CPMLDR.SYS</code>
on the system track of the disk there are several files that are
required on the disk itself.This is described in <a href="#digital-research-cpm-3">Digital Research CP/M
3</a> section above.</p>
<p>You will need to add a <code>PROFILE.SUB</code> file to auto-start Z3PLUS itself.</p>
<h4 id="character-device-mapping_4">Character Device Mapping</h4>
<p>Mapping of character devices to RomWBW HBIOS Character devices operates
exactly the same as described in <a href="#digital-research-cpm-3">Digital Research CP/M
3</a>. The CP/M 3 <code>DEVICE</code> command is used to
manipulate the device mappings.</p>
<h4 id="notes_4">Notes</h4>
<ul>
<li>
<p>All of the notes for <a href="#digital-research-cpm-3">Digital Research CP/M
  3</a> above generally apply to Z3PLUS.</p>
</li>
<li>
<p>Some applications in the Z3PLUS distribution have been upgraded with
  newer versions. This is done with in</p>
</li>
</ul>
<h2 id="zpm3">ZPM3</h2>
<p>Simeon Cran’s ZPM3 is an interesting combination of the features of both
CP/M 3 and ZCPR3. Essentially, it has the features of and compatibility
with both.</p>
<p>Due to this dual compatibility, the ZPM3 distribution image contains
most of the standard CP/M 3 files as well as a variety of common ZCPR3
applications. However, you will notice that user area 0 of the disk has
only a few files. Most of the files are distributed among other user
areas which is standard practice for ZCPR3. Most importantly, you will
see most of the applications in user area 15. The applications can be
executed from any user area because ZPM3 has a default search path that
includes User 15.</p>
<p>The ZPM3 distribution comes with essentially no utility programs at all.
In addition to the standard CP/M 3 utilities, RomWBW includes a variety
of common ZCPR3 utilities.</p>
<h4 id="documentation_5">Documentation</h4>
<p>ZPM3 has no real documentation. You are expected to understand both CP/M
3 and ZCPR 3. The best source of information is:</p>
<ul>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/CPM3%20Users%20Guide.pdf">CPM3 Users
  Guide</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/CPM3%20Command%20Summary.pdf">CPM3 Command
  Summary</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/CPM3%20Programmers%20Guide.pdf">CPM3 Programmers
  Guide</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/CPM3%20System%20Guide.pdf">CPM3 System
  Guide</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/Z-System%20Users%20Guide.pdf">Z-System Users
  Guide</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/ZCPR3.3%20User%20Guide.pdf">ZCPR3.3 User
  Guide</a></li>
</ul>
<h4 id="boot-disk_5">Boot Disk</h4>
<p>To create (or update) a ZPM3 boot drive, you must place <code>ZPMLDR.SYS</code> on
the system track of the disk. You must also place <code>CPM3.SYS</code>,
<code>ZCCP.COM</code>, <code>ZINSTAL.ZPM</code>, and <code>STARTZPM.COM</code> on the target drive as
regular files. Do <strong>not</strong> place CPM3.SYS on the boot track. <code>ZPMLDR.SYS</code>
chain loads <code>CPM3.SYS</code> which must exist as a regular file on the disk.
Subsequently, <code>CPM3.SYS</code> loads <code>CCP.COM</code>.</p>
<p>The CP/M 3 boot files are not included on the ROM disk due to space
constraints. You will need to transfer the following files to your
system from the RomWBW distribution directory Binary/ZPM3. You can use
XModem for this (or any of the mechanisms in <a href="#transferring-files">Transferring
Files</a>.</p>
<ul>
<li><code>ZPMLDR.SYS</code></li>
<li><code>CPM3.SYS</code></li>
<li><code>ZCCP.COM</code></li>
<li><code>ZINSTAL.ZPM</code></li>
<li><code>STARTZPM.COM</code></li>
</ul>
<p>You may be surprised to see the file called <code>CPM3.SYS</code>. This is not a
typo. Although it is called <code>CPM3.SYS</code>, it is ZPM and not the same as
<code>CPM3.SYS</code> in the CPM3 directory. Also, unlike CP/M 3, ZPM3 is always
banked, so you will not find two versions of the file. <code>CPM3.SYS</code> is a
banked implementation of ZPM3.</p>
<p>After transferring the boot files to your RomWBW system, you will need
to use <code>SYSCOPY</code> to place <code>ZPMLDR.SYS</code> on the boot track of the target
drive. The remaining boot files can be copied to the target drive using
any standard file copy tool such as <code>PIP</code> or <code>COPY</code>.</p>
<p>You do not need to be booted into ZPM3 to create or update a ZPM3 disk.
The recommended approach is to boot CP/M 2.2 or Z-System from ROM.
Transfer the boot files to the RAM disk. Then simply copy the files onto
the ZPM disk. Assuming the target ZPM3 disk is F:, you can use the
following commands to place the files on the target drive:</p>
<pre><code>SYSCOPY F:=A:ZPMLDR.SYS
COPY A:CPM3.SYS F:CPM3.SYS
COPY A:CCP.COM F:
COPY A:ZINSTAL.ZPM F:
COPY A:STARTZPM.COM F:
</code></pre>
<h4 id="character-device-mapping_5">Character Device Mapping</h4>
<p>Mapping of character devices to RomWBW HBIOS Character devices operates
exactly the same as described in <a href="#digital-research-cpm-3">Digital Research CP/M
3</a>. The CP/M 3 <code>DEVICE</code> command is used to
manipulate the device mappings.</p>
<h4 id="notes_5">Notes</h4>
<ul>
<li>
<p>The ZPM3 operating system is contained in the file called CPM3.SYS
  which is confusing, but this is as intended by the ZPM3 distribution.
  I believe it was done this way to make it easier for users to
  transition from CP/M 3 to ZPM3.</p>
</li>
<li>
<p>The command line editing key bindings were slightly modified by Jon
  Saxton when he applied a few ZPM3 fixes. This is explained in the file
  zpm3fix.txt in the distribution folder Source/ZPM3. The current key
  bindings are from the “New” column below.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Old</strong></th>
<th><strong>New</strong></th>
<th><strong>Function</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>^A</td>
<td>^A</td>
<td>one word left</td>
</tr>
<tr>
<td>^B</td>
<td>^B</td>
<td>to beginning/end of line</td>
</tr>
<tr>
<td>^C</td>
<td>^C</td>
<td>reboot if at start of line</td>
</tr>
<tr>
<td>^D</td>
<td>^D</td>
<td>right one char</td>
</tr>
<tr>
<td>^E</td>
<td>^E</td>
<td>get previous line</td>
</tr>
<tr>
<td>^F</td>
<td>^F</td>
<td>right one word</td>
</tr>
<tr>
<td>^G</td>
<td>^G</td>
<td>delete char at cursor</td>
</tr>
<tr>
<td>^H</td>
<td>^H</td>
<td>destructive backspace</td>
</tr>
<tr>
<td>^I</td>
<td>^I</td>
<td>(TAB) ignored here</td>
</tr>
<tr>
<td>^J</td>
<td>^J</td>
<td>(LF) exit editor</td>
</tr>
<tr>
<td>^K</td>
<td>^K</td>
<td>delete all to the right</td>
</tr>
<tr>
<td>^L</td>
<td>^L</td>
<td>ignored</td>
</tr>
<tr>
<td>^M</td>
<td>^M</td>
<td>(CR) exit editor</td>
</tr>
<tr>
<td>^N</td>
<td>^N</td>
<td>ignored</td>
</tr>
<tr>
<td>^O</td>
<td>^O</td>
<td>ignored</td>
</tr>
<tr>
<td>^P</td>
<td>^P</td>
<td>toggle printer echoing</td>
</tr>
<tr>
<td>^Q</td>
<td>^Q</td>
<td>toggle autoprompt (if enabled)</td>
</tr>
<tr>
<td>^R</td>
<td>^R</td>
<td>ignored</td>
</tr>
<tr>
<td>^S</td>
<td>^S</td>
<td>left one char</td>
</tr>
<tr>
<td>^T</td>
<td>^T</td>
<td>delete word at cursor</td>
</tr>
<tr>
<td>^U</td>
<td>^U</td>
<td>add line to history</td>
</tr>
<tr>
<td>^V</td>
<td>^V</td>
<td>clear line, delete from history</td>
</tr>
<tr>
<td>^W</td>
<td>^X</td>
<td>get next line from history</td>
</tr>
<tr>
<td>^X</td>
<td>^W</td>
<td>delete all to the left</td>
</tr>
<tr>
<td>^Y</td>
<td>^Y</td>
<td>clear line</td>
</tr>
</tbody>
</table>
<h2 id="qpm">QP/M</h2>
<p>QP/M is another OS providing compatibility with and enhancements to CP/M
2.2. It is provided as a bootable disk image for RomWBW.</p>
<p>Refer to the ReadMe.txt file in Source/Images/d_qpm for more details
regarding the RomWBW adaptation and customizations.</p>
<h4 id="documentation_6">Documentation</h4>
<ul>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/qpm27.pdf">QP/M 2.7 Installation Guide and
  Supplements</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/qdos27.pdf">QP/M 2.7 Interface
  Guide</a></li>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/CPM/qcp27.pdf">QP/M 2.7 Features and
  Facilities</a></li>
</ul>
<h4 id="boot-disk_6">Boot Disk</h4>
<p>To create or update a bootable QP/M Z-System disk, a special process is
required. QP/M is not provided in source format. You are expected to
install QP/M over an existing CP/M installation using the <code>QINSTALL.COM</code>
application.</p>
<p>To update an existing QP/M boot disk with the latest RomWBW CBIOS, you
must use 2 steps: apply the generic CP/M system track, then reinstall
the QP/M components. To do this, you can perform the following steps:</p>
<ol>
<li>
<p>Boot to the existing QP/M disk. At this point, drive A should be the
    QP/M disk that you wish to update. You may receive a warning about
    CBIOS/HBIOS version mismatch.</p>
</li>
<li>
<p>Use RomWBW <code>SYSCOPY</code> to place the stock RomWBW CP/M OS image onto
    the system tracks of the QP/M boot disk:</p>
<p><code>SYSCOPY A:=x:CPM.SYS</code></p>
<p>where x is the drive letter of your ROM Disk.</p>
</li>
<li>
<p>Run <code>QINSTALL</code> to overlay the QP/M OS components on your QP/M boot
    disk.</p>
</li>
</ol>
<p><strong>WARNING</strong>: <code>QINSTALL</code> has no mechanism for retaining previous
non-default settings. Any previous non-default settings you previously
made with <code>QINSTALL</code> will need to be reapplied. The pre-built RomWBW
QP/M disk image includes a couple of specific non-default settings to
optimize use with RomWBW. Please review the notes in the ReadMe.txt file
in Source/Images/d_qpm.</p>
<h4 id="character-device-mapping_6">Character Device Mapping</h4>
<p>Mapping of character devices to RomWBW HBIOS Character devices operates
exactly the same as described in <a href="#digital-research-cpm-2.2">Digital Research CP/M
2.2</a>. The mappings can be viewed or modified
using the QP/M <code>QSTAT</code> command which is analogous to the CP/M 2.2 <code>STAT</code>
command. Do <strong>not</strong> use the CP/M 2.2 <code>STAT</code> command under QP/M.</p>
<h4 id="notes_6">Notes</h4>
<ul>
<li>
<p>QPM is not available as source. This implementation was based on the
  QPM binary distribution and has been minimally customized for RomWBW.</p>
</li>
<li>
<p>When booted, the QPM startup banner will indicate CP/M 2.2. This is
  because QPM uses the CP/M 2.2 CBIOS code.</p>
</li>
<li>
<p>QINSTALL is used to customize QPM. It is included on the disk image.
  You should review the notes in the ReadMe.txt file in
  Source/Images/d_qpm before making changes.</p>
</li>
<li>
<p>In addition to the QPM disk image, all of the QPM distribution files
  can be found in the RomWBW distribution in the Source/Images/d_qpm/u0
  directory.</p>
</li>
<li>
<p>The QPM disk image is not included as one of the slices on the RomWBW
  Combo Disk Image. If you want to include QPM, you can do so by
  following the directions in Source/Images/Readme.txt.</p>
</li>
</ul>
<h2 id="ucsd-p-system">UCSD p-System</h2>
<p>This is a full implementation of the UCSD p-System IV.0 for Z80 running
under RomWBW. Unlike the OSes above, p-System uses its own unique
filesystem and is not interoperable with other OSes.</p>
<p>It was derived from the p-System Adaptable Z80 System. Unlike some other
distributions, this implements a native p-System Z80 Extended BIOS, it
does not rely on a CP/M BIOS layer.</p>
<p>The p-System is provided on a hard disk image file called psys.img. This
must be copied to its own dedicated hard disk media (CF Card, SD Card,
etc.). It is booted by selecting slice 0 of the corresponding hard disk
unit at the RomWBW Boot Loader prompt. Do not attempt to use CP/M slices
on the same disk.</p>
<p>Due to limitations in the p-System configuration mechanism, it does not
recognize the arrow keys of an ANSI Terminal. To work around this, the
following control keys have been defined:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Up</td>
<td>ctrl+E</td>
</tr>
<tr>
<td>Down</td>
<td>ctrl+X</td>
</tr>
<tr>
<td>Left</td>
<td>ctrl+S</td>
</tr>
<tr>
<td>Right</td>
<td>ctrl+D</td>
</tr>
</tbody>
</table>
<p>Refer to
<a href="https://github.com/wwarthen/RomWBW/raw/master/Source/pSys/ReadMe.txt">Source/pSys/ReadMe.txt</a>
for more details about the p-System adaptation.</p>
<h4 id="documentation_7">Documentation</h4>
<ul>
<li><a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/UCSD%20p-System%20Users%20Manual.pdf">UCSD p-System Users
  Manual</a></li>
</ul>
<h4 id="boot-disk_7">Boot Disk</h4>
<p>There is no mechanism provided to create a p-System boot disk from
scratch under RomWBW. This has already been done as part of the porting
process. You must use the provided p-System hard disk image file which
is bootable.</p>
<h4 id="character-device-mapping_7">Character Device Mapping</h4>
<p>RomWBW Character Devices are automatically assigned to p-System devices
at startup. The current HBIOS Console device is assigned to CONSOLE:.<br />
The next available HBIOS Char device is assigned to REMIN:/REMOUT:. The
next available HBIOS Char devices is assigned to PRINTER:</p>
<h4 id="notes_7">Notes</h4>
<ul>
<li>
<p>There is no floppy support at this time.</p>
</li>
<li>
<p>The hard disk image contains 6 p-System slices which are assigned to
  p-System unit numbers 4, 5, 9, 10, 11, and 12 which is standard for
  p-System. Slices 0-5 are assigned sequentially to these p-System unit
  numbers and it is not possible to reassign them. Unit #4 (slice 0) is
  bootable and contains all of the p-System distribution files. Unit #5
  (slice 1) is just a blank p-System filesystem. The other units (9-12)
  have not been initialized, but this can be done from Filer using the
  Zero command.</p>
</li>
<li>
<p>p-System relies heavily on the use of a full screen terminal. This
  implementation has been setup to expect an ANSI or DEC VT-100 terminal
  or emulator. The screen output will be garbled if no such terminal or
  emulator is used for console output.</p>
</li>
<li>
<p>There is no built-in mechanism to move files in and out of p-System.
  However, the .vol files in Source/pSys can be read and modified by
  CiderPress. CiderPress is able to add and remove individual files.</p>
</li>
</ul>
<p>Andrew Davidson has created a Python script that can extract p-System
  volumes from an existing disk image file. The script is also capable
  of inserting a modified volume back into the disk image file. This
  tool is available at <a href="https://github.com/robosnacks/psysimg">https://github.com/robosnacks/psysimg</a>.</p>
<h2 id="freertos">FreeRTOS</h2>
<p>Phillip Stevens has ported FreeRTOS to run under RomWBW. FreeRTOS is not
provided in the RomWBW distribution. FreeRTOS is available under the
<a href="https://www.freertos.org/a00114.html">MIT licence</a> and further general
information is available at
<a href="https://www.freertos.org/RTOS.html">FreeRTOS</a>.</p>
<p>Phillip may be contacted via his <a href="https://github.com/feilipu">GitHub
Page</a>.</p>
<h2 id="fuzix">Fuzix</h2>
<p>Fuzix is a Unix-ish operating system for small systems. It is the work
of Alan Cox and is hosted on GitHub at
<a href="https://github.com/EtchedPixels/FUZIX">https://github.com/EtchedPixels/FUZIX</a>. Fuzix itself is a stand-alone
operating system, but it frequently utilizes RomWBW to boot and launch
on RomWBW-supported platforms.</p>
<p>For those Fuzix platforms that leverage RomWBW for startup, you will
program your ROM with the normal RomWBW ROM – there is no Fuzix-specific
ROM. A Fuzix disk image for your system is then written to your disk
media. After booting your system via the normal RomWBW ROM, you start
Fuzix simply by choosing the disk device containing the Fuzix image at
the RomWBW Loader prompt.</p>
<p>To create a Fuzix disk image:</p>
<ul>
<li>
<p>Locate and download the Fuzix disk image for your system from
  <a href="https://www.fuzix.org/">https://www.fuzix.org/</a>. For each platform, you will typically find
  two image files. An emulator image (<code>emu-xxx.img</code>) and a disk image
  (<code>disk.img</code>). You want the disk image file.</p>
</li>
<li>
<p>Write the disk image file to your physical media (CF Card, SD Card,
  etc.) starting at the beginning of the media (first sector). Do not
  combine the Fuzix image with the RomWBW disk images – they are
  entirely separate.</p>
</li>
</ul>
<p>To boot into Fuzix:</p>
<ul>
<li>
<p>Insert your Fuzix disk media.</p>
</li>
<li>
<p>Power-up or reset your system. RomWBW should load normally and bring
  you to the RomWBW Boot Loader prompt.</p>
</li>
<li>
<p>Depending on the platform, Fuzix may be built to run at a different
  baud rate that the default RomWBW baud rate. If so, it is best to
  change your RomWBW baud rate prior to initiating the Fuzix startup.
  You can do this at the loader prompt with a command like this:</p>
</li>
</ul>
<p><code>I 0 38400</code></p>
<p>Replace 38400 with the desired baud rate for Fuzix. You will be
  prompted to change your terminal’s baud rate at this time.</p>
<ul>
<li>
<p>At the RomWBW Boot Loader prompt, enter the disk unit number of the
  Fuzix media. Fuzix should load and you will see device
  discovery/information messages that vary depending on your platform.
  This is a typical example:</p>
<p>RCBus [RCZ180_nat_wbw] Boot Loader
  FP Switches = 0x00</p>
<p>Boot [H=Help]: 2</p>
<p>Booting Disk Unit 2, Slice 0, Sector 0x00000000...</p>
<p>Volume "Fuzix 126 Loader" [0xF200-0xF400, entry @ 0xF200]...
  FUZIX version 0.4
  Copyright (c) 1988-2002 by H.F.Bower, D.Braun, S.Nitschke, H.Peraza
  Copyright (c) 1997-2001 by Arcady Schekochikhin, Adriano C. R. da Cunha
  Copyright (c) 2013-2015 Will Sowerbutts <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#119;&#105;&#46;&#46;&#46;&#64;&#115;&#111;&#119;&#101;&#114;&#98;&#117;&#116;&#116;&#115;&#46;&#99;&#111;&#109;">&#119;&#105;&#46;&#46;&#46;&#64;&#115;&#111;&#119;&#101;&#114;&#98;&#117;&#116;&#116;&#115;&#46;&#99;&#111;&#109;</a>
  Copyright (c) 2014-2023 Alan Cox <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#97;&#108;&#46;&#46;&#46;&#64;&#101;&#116;&#99;&#104;&#101;&#100;&#112;&#105;&#120;&#101;&#108;&#115;&#46;&#99;&#111;&#46;&#117;&#107;">&#97;&#108;&#46;&#46;&#46;&#64;&#101;&#116;&#99;&#104;&#101;&#100;&#112;&#105;&#120;&#101;&#108;&#115;&#46;&#99;&#111;&#46;&#117;&#107;</a>
  Devboot
  512kB total RAM, 448kB available to processes (15 processes max)
  Enabling interrupts ... ok.
  0000 : CF Card                                  - OK
  0001 :  - absent
  hda: hda1 hda2 (swap)
  bootdev:</p>
</li>
<li>
<p>At the <code>bootdev:</code> prompt, enter <code>hda1</code>. Fuzix should load and you will
  be prompted for a date/time. Here is a typical example:</p>
<p>bootdev: hda1
  Mounting root fs (root_dev=1, ro): OK
  Starting /init
  init version 0.9.1
  Checking root file system.
  Current date is Fri 2023-08-18
  Enter new date:
  Current time is 13:30:24
  Enter new time:</p>
<p>^ ^
   n n   Fuzix 0.4</p>
<blockquote>
<p>@&lt;
         Welcome to Fuzix
   m m</p>
</blockquote>
<p>login:</p>
</li>
<li>
<p>At the <code>login:</code> prompt, enter <code>root</code>. No password is required. You
  should then get a Fuzix <code>#</code> command prompt.</p>
<p>login: root</p>
<p>Welcome to FUZIX.
  #</p>
</li>
</ul>
<p>You may now use Fuzix as desired. The general operation and use of Fuzix
is outside of the scope of this document.</p>
<h1 id="custom-applications">Custom Applications</h1>
<p>The operation of the RomWBW hosted operating systems is enhanced through
several custom applications. You have already read about one of these –
the <code>ASSIGN</code> command. These applications are functional on all of the OS
variants included with RomWBW.</p>
<p>The applications discussed here are <strong>not</strong> the same as the built-in ROM
applications mentioned previously. These applications run as commands
within the operating systems provided by RomWBW. So, these commands are
only available at an operating system prompt after an operating system
has been loaded.</p>
<p>All of the RomWBW Custom Applications are built to function under all of
the RomWBW Operating Systems (except for p-System). In general, the
applications will automatically adapt as needed to the currently running
operating system. One exception is <code>FDU</code> – the Floppy Disk Utility. This
application requires that you pick the floppy disk interface you want to
interact with.</p>
<p>There is more complete documentation of all of these applications in the
related RomWBW manual “<a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>”
found in the Doc directory of the distribution.</p>
<p>The following custom applications are found on the ROM disk and are,
therefore, globally available.</p>
<table>
<thead>
<tr>
<th><strong>Application</strong></th>
<th>**Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASSIGN</td>
<td>Add, change, and delete drive letter assignments. Use ASSIGN /? for usage instructions.</td>
</tr>
<tr>
<td>SYSCOPY</td>
<td>Copy system image to a device to make it bootable. Use SYSCOPY with no parms for usage instructions.</td>
</tr>
<tr>
<td>MODE</td>
<td>Reconfigures serial ports dynamically.</td>
</tr>
<tr>
<td>FDU</td>
<td>Format and test floppy disks. Menu driven interface.</td>
</tr>
<tr>
<td>FORMAT</td>
<td>Will someday be a command line tool to format floppy disks. Currently does nothing!</td>
</tr>
<tr>
<td>XM</td>
<td>XModem file transfer program adapted to hardware. Automatically uses primary serial port on system.</td>
</tr>
<tr>
<td>FLASH</td>
<td>Will Sowerbutts’ in-situ ROM programming utility.</td>
</tr>
<tr>
<td>FDISK80</td>
<td>John Coffman’s Z80 hard disk partitioning tool. See documentation in Doc directory.</td>
</tr>
<tr>
<td>FAT</td>
<td>Access MS-DOS FAT filesystems from RomWBW (based on FatFs).</td>
</tr>
<tr>
<td>TALK</td>
<td>Direct console I/O to a specified character device.</td>
</tr>
<tr>
<td>RTC</td>
<td>Manage and test the Real Time Clock hardware.</td>
</tr>
<tr>
<td>TIMER</td>
<td>Display value of running periodic system timer.</td>
</tr>
<tr>
<td>CPUSPD</td>
<td>Change the running CPU speed and wait states of the system.</td>
</tr>
</tbody>
</table>
<p>Some custom applications do not fit on the ROM disk. They are found on
the disk image files or the individual files can be found in the
Binary/Apps directory of the distribution. They are also included on the
floppy disk and hard disk images.</p>
<table>
<thead>
<tr>
<th><strong>Application</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>TUNE</td>
<td>Play .PT2, .PT3, .MYM audio files.</td>
</tr>
<tr>
<td>INTTEST</td>
<td>Test interrupt vector hooking.</td>
</tr>
</tbody>
</table>
<h1 id="real-time-clock-datetime-stamping">Real Time Clock &amp; Date/Time Stamping</h1>
<p>RomWBW supports a variety of real time clock hardware. If your system
has this hardware, then it will be able to maintain the current date and
time even while your system is turned off.</p>
<p>Additionally, depending on the operating system being used, you may be
able to utilize date/time stamping of files. To facilitate this a CP/M
clock driver (WBWCLK) has been included inside <code>CLOCKS.DAT</code> that will
read the clock via a RomWBW HBIOS call</p>
<p>You can determine if your system has a real time clock present (and
functioning) by looking at the boot messages. Here is an example of a
boot message reflecting the detection of a valid real time clock module:</p>
<p><code>DSRTC: MODE=STD IO=0x8A Thu 2023-10-19 14:07:11 CHARGE=ON</code></p>
<p>This example is from a DSRTC clock module. You may have a different one,
but it will always display the current date/time.</p>
<p>In some cases, your real time clock will support charging of the battery
or super-capacitor while the system has power. The status of this
charging is displayed.</p>
<p>If the date/time of your RTC needs to be updated, you will need to do
this with one of the utilities described below. There is no ability to
update the date/time of the RTC in the RomWBW Boot Loader or Monitor.</p>
<h2 id="datetime-utilities">Date/Time Utilities</h2>
<p>RomwWBW includes two utilities for displaying or setting the date/time
stored by the RTC. They are both a bit different and are briefly
described below.</p>
<p>A third utility <code>TESTCLOK</code> is also included as part of ZSDOS</p>
<h3 id="wdate-utility">WDATE Utility</h3>
<p>The <code>WDATE</code> utility (contributed by Kevin Boone) is an application that
will display and/or update the current date/time. Its operation is
described in <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>.
This utility works with any of the supported RomWBW RTC hardware. Here
is an example of displaying and updating the date/time with this
utility:</p>
<pre><code>A&gt;wdate
Thursday 19 October 14:14:43 2023

A&gt;wdate 23 10 19 14 24 30

A&gt;wdate
Thursday 19 October 14:24:34 2023
</code></pre>
<p>Note that <code>WDATE</code> does not have anything to do with date/time stamping
of files. It merely displays and sets the real time clock value.</p>
<h3 id="rtc-utility">RTC Utility</h3>
<p>Like <code>WDATE</code>, the <code>RTC</code> utility (contributed by Andrew Lynch) will let
you display and set the current date/time. However, this utility only
works with the DSRTC hardware (DS1302 chip). It is a “direct to hardware
application”. Its operation is described in <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>.
Here is an example of displaying and updatting the date/time with this
utility:</p>
<pre><code>A&gt;rtc
Start RTC Program
RomWBW HBIOS, Mark 4 RTC Latch Port 0x8A

RTC: Version 1.9
Commands: E)xit T)ime st(A)rt S)et R)aw L)oop C)harge N)ocharge D)elay I)nit G)et P)ut B)oot W)arm-start H)elp

RTC&gt;t
Current time: 23-10-19 14:30:25-05

RTC&gt;i
Init date/time.

YEAR:23
MONTH:10
DATE:19
HOURS:14
MINUTES:31
SECONDS:00
DAY:05
</code></pre>
<p>The <code>RTC</code> utility is also capable of turning the charging feature of the
DS1320 chip on or off. Here is an example of turning if off and back on:</p>
<pre><code>A&gt;rtc
Start RTC Program
RomWBW HBIOS, Mark 4 RTC Latch Port 0x8A


RTC: Version 1.9
Commands: E)xit T)ime st(A)rt S)et R)aw L)oop C)harge N)ocharge D)elay I)nit G)et P)ut B)oot W)arm-start H)elp

RTC&gt;n
Trickle charger disabled.

RTC&gt;c
Trickle charger enabled.
</code></pre>
<p>Do <strong>not</strong> enable charging unless you are sure that your system supports
this. If your RTC is being powered by a normal battery, it would be
dangerous to enable charging.</p>
<h3 id="testclok-utility">TESTCLOK Utility</h3>
<p>The <code>TESTCLOK</code> utility is used to test a selected CPM clock driver
loaded from the CLOCKS.DAT file. After selecting the location of
CLOCKS.DAT and the clock driver (45. WBWCLK) it displays the currently
configured time until a key is pressed.</p>
<pre><code>A&gt;testclok

TESTCLOK V1.0    Copyright (C) 1988    H.F. Bower / C.W. Cotrill

Extract Clock from Library ([Y]/N) : Y
Location of CLOCKS.DAT [A0:] : &lt;RETURN&gt;

  1. ACTRIX             2. ALSPA              3. AMPRO-LB         
  4. ANLYTCL-PRD        5. AP2-CDZ180         6. AP2-THND/MT      
  7. AP2-TIMASTR        8. AP2E+PCP-TM        9. AP2E+PCPI        
 10. AP2E-THUNDR       11. AP2E-TMASTR       12. BIG-BD-II        
 13. BP-BIOS           14. CCS-WALLCLK       15. CPUPRO-SSB1      
 16. ELECTR-MFIO       17. EPSON-QX10        18. ETS180IO+        
 19. H19-SUPER19       20. H19-ULTRA         21. H19-WATZMAN      
 22. H89-BITZERO       23. H89-PC12          24. H89-WIDGET       
 25. H89-WISE          26. H89UTI            27. HEATH-BIOS       
 28. HOUSEMASTER       29. K83-HOLMES        30. KAYPRO-84        
 31. KENMOR-ZTIM       32. KPRO-ADVENT       33. KPRO-LEGACY      
 34. MD3-MACK          35. MTN100K-DAY       36. ONEAC-ON!        
 37. OTRANA-ATCH       38. P&amp;T-HEARTBT       39. QTSYS-S100       
 40. RELATIVE          41. S100-5832         42. SB180-HRTBT      
 43. SB180-XBIOS       44. SIMHCLOK          45. WBWCLK           
 46. XEROX-820         47. ZSDOS-BIOS

Enter Clock Driver Selection : 45

..Loading : WBWCLK      ... 
Linking Clock Module... OK
RomWBW HBIOS Clock      1.1

RomWBW Series HBIOS Clock

Press any key to quit...

 19 Oct 2023  14:24:34
</code></pre>
<p>Since this runs at the CPM driver level it is useful as an end-to-end
test to prove that date time stamping is able to read the correct time</p>
<p>The <code>TESTCLOK</code> utility is provided by ZSDOS, plese see the ZSDOS Manual
for further information</p>
<h2 id="datetime-file-stamping">Date/Time File Stamping</h2>
<p>If an RTC is available in your system, then most operating systems can
use it to date/time stamp files. This just means recording the date/time
of file creation, update, and or access in the directory. This
capability is available in all of the RomWBW operating system except the
original DRI CP/M 2.2.</p>
<p>Three types of date/time stamping are supported using realtime clock
supported by RomWBW HBIOS. DateStamper, NZT and P2DOS.</p>
<p>In some cases (such as ZSDOS), you must load an RSX (memory resident
utility) to enable date/time stamping of files. This could be automated
using a <code>PROFILE.SUB</code> file. Preconfigured loaders are provided,
bypassing the need to use SETUPZST.</p>
<p>Additionally, you will need to initialize the directory. The procedure
varies depending on the date/time stamping mechanism, so you must review
the associated documentation.</p>
<p>The date/time stamping mechanisms for each operating system are
generally not compatible. If you initialize a directory for a type of
stamping, you should be careful not to manipulate that directory with a
different operating system with a different date/time stamping
mechanism. Doing so may corrupt the directory.</p>
<p>The RomWBW disk images do not have date/time stamping initialized. This
is to avoid any chance of directory corruption.</p>
<h3 id="datestamper">DateStamper</h3>
<p>DateStamper datestamping follows the standard set by Plu*Perfect
Systems. This method stores stamps in a disk file named <code>!!!TIME&amp;.DAT</code>.
Only DateStamper stamping stores full time and date stamps for file
Creation, Last Modification, and Last Access, and may be used with any
CP/M diskette format. In addition, the DateStamper protocol is supported
by a mature set of compatible utilities.</p>
<p>Key Utilities</p>
<ul>
<li>LDDS.COM - Load DateStamper date/time stamping resident extension.
  (RomWBW Provided)</li>
<li>PUTDS.COM - Prepare disk for DateStamper date/time stamping.</li>
</ul>
<p>After using PUTDS to initialize a directory for ZDS date stamping, it
may be necessary to run RELOG before the stamping routines will actually
start working.</p>
<h3 id="p2dos-cpm-plus-compatible">P2DOS (CP/M Plus compatible)</h3>
<p>CP/M Plus-type datestamping is also widely used due to the popularity of
CP/M Plus (also know as CP/M 3). CP/M Plus-type file datestamping uses
directory sectors to store file datestamps which may be accessed more
quickly by programs, but there is no Last File Access stamp. Finally,
the range of utilities for this type of stamps is more limited than for
the DateStamper protocol.</p>
<p>Key Utilities</p>
<ul>
<li>LDP2D.COM - Load P2DOS date/time stamping resident extension. (RomWBW
  Provided)</li>
<li>INITDIR.COM - Prepares disks for P2DOS-type file stamping.</li>
</ul>
<h3 id="nzt">NZT</h3>
<p><em>The use of NZT needs to be further documented</em></p>
<p>Key Utilities</p>
<ul>
<li>LDNZT.COM - Load NZT date/time stamping resident extension. (RomWBW
  Provided)</li>
</ul>
<h3 id="additional-notes">Additional Notes</h3>
<p>The following files have been provided, customised and tested for for
use in RomWBW</p>
<ul>
<li><code>CLOCKS.DAT</code> - Library of clock drivers, which has been updated to
  include the RomWBW clock driver WBWCLK, and also includes the SIMHCLOK
  clock driver. The file is just a standard LU type library and is
  easily updated using NULU. The members are the relocatable binaries,
  but with the .REL extension removed.</li>
<li><code>STAMPS.DAT</code> - Library of available date/time stamping modules for
  SETUPZST. The file has been replaced with an updated version from the
  Walnut Creek CP/M CDROM. The original version has a bug that prevents
  RSX (resident system extension) mode to load properly.</li>
</ul>
<p>Additional Notes</p>
<ul>
<li><code>SETUPZST</code> (provided by ZSDOS) Should not normally be needed since the
  creation of the appropriate LDTIM loaders has already been performed.</li>
<li><code>FILEDATE</code> only works with DateStamper style date stamping. If you run
  it on a drive that is not initialized for DateStamper, it will
  complain <code>FILEDATE, !!!TIME&amp;.DAT missing</code>. This is normal and just
  means that you have not initialized that drive for DateStamper (using
  PUTDS).</li>
<li><code>ZXD</code> will handle either DateStamper or P2DOS type date stamping.
  However, it <strong>must</strong> be configured appropriately. As distributed, it
  will look for P2DOS date stamps. Use ZCNFG to reconfigure it for P2DOS
  if that is what you are using.</li>
</ul>
<h2 id="timezone">Timezone</h2>
<p>None of the operating systems distributed with RomWBW have any concept
of timezone. When files are date/time stamped, the date/time will simply
be whatever date/time the RTC currently has.</p>
<p>The normal practice is to set the RTC to your local time. This implies
that you would need to manually adjust the RTC for daylight savings time
and/or when you travel to a different time zone.</p>
<p>The date/time stamps of files in directories will also be stored in
local time. This includes files stored in a FAT filesystem. If you
subsequently view the directory from modern machines (Windows, Linux,
etc.), the date/time displayed will depend on the behavior of the modern
system.</p>
<p>For example, Linux assumes that the date/time of files is UTC. So, if
you create a file on a FAT filesystem with your RomWBW computer and then
use Linux to view the directory, the date/time stamps will seem “off” by
a few hours.</p>
<p>The only alternative you may consider is setting the date/time of your
RTC to UTC. Since UTC is consistent across all timezones and daylight
savings time, your file date/time stamps will also be consistent. Of
course, this will mean that your RomWBW computer will display a
date/time that seems wrong because it is not local time.</p>
<h1 id="cpnet-networking">CP/NET Networking</h1>
<p>Digital Research created a simple network file sharing system called
CP/NET. This allowed a network server running CP/NOS to host files
available to network attached CP/M computers. Essentially, the host
becomes a simple file sharing server.</p>
<p>RomWBW disk images include an adaptation of the DRI CP/NET client
software provided by Douglas Miller. RomWBW does not support operation
as a network server itself. However, Douglas has also developed a
Java-based implementation of the DRI network server that can be used to
provide host services from a modern computer.</p>
<p>Both CP/NET 1.2 and 3.0 clients are provided. Version 1.2 is for use
with CP/M 2.2 and compatible OSes. Version 3.0 is for use with CP/M 3
and compatible OSes.</p>
<p>The CP/NET client software provided with RomWBW requires a supported
ethernet interface module. At this time, the following are supported:</p>
<ul>
<li>RCBus MT011 w/ Ethernet Featherwing and (optionally) SPI FRAM (e.g.,
  Adafruit SPI Non-Volatile FRAM Breakout)</li>
<li>Duodyne Disk I/O w/ Wiz850IO and (optionally) SPI NVRAM (e.g.,
  25LC256)</li>
<li>Generic Serial Interface</li>
</ul>
<p><strong>NOTE:</strong> The Generic Serial Interface is supported by RomWBW, but is
not documented here. You must refer to the CP/NET documentation
referenced below.</p>
<p>The client software interacts directly with this hardware. In a future
version of RomWBW, I hope to add a generic networking API that will
allow a greater range of network hardware to be used.</p>
<p>To use CP/NET effectively, you will want to review the documentation
provided by Douglas on at his <a href="https://github.com/durgadas311/cpnet-z80">cpnet-z80 GitHub
Project</a>. Additionally, you
should consult the DRI documentation which is not included with RomWBW,
but is available on the
<a href="https://github.com/durgadas311/cpnet-z80">cpnet-z80</a> site.</p>
<p>Below, I will provide the general steps involved in setting up a network
using MT011 with RomWBW.</p>
<h2 id="cpnet-client-setup">CP/NET Client Setup</h2>
<p>The CP/NET client files are included on the RomWBW disk images, but they
are found in user area 4. They are placed there to avoid confusing
anyone that is not specifically trying to run a network client. They are
only found on the CPM 2.2 and CP/M 3 slices. Using CP/NET on alternative
OSes may work, but is not officially supported.</p>
<p>The CP/NET client files are packaged in <code>.LBR</code> library files. The
library files are found in user area 4.</p>
<table>
<thead>
<tr>
<th>File</th>
<th>CP/NET Version</th>
<th>OS</th>
<th>Hardware</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPN12MT.LBR</td>
<td>CP/NET 1.2</td>
<td>CP/M 2.2</td>
<td>RCBus w/ MT011</td>
</tr>
<tr>
<td>CPN3MT.LBR</td>
<td>CP/NET 3</td>
<td>CP/M 3</td>
<td>RCBus w/ MT011</td>
</tr>
<tr>
<td>CPN12DUO.LBR</td>
<td>CP/NET 1.2</td>
<td>CP/M 2.2</td>
<td>Duodyne w/ Disk I/O</td>
</tr>
<tr>
<td>CPN3DUO.LBR</td>
<td>CP/NET 3</td>
<td>CP/M 3</td>
<td>Duodyne w/ Disk I/O</td>
</tr>
<tr>
<td>CPN12SER.LBR</td>
<td>CP/NET 1.2</td>
<td>CP/M 2.2</td>
<td>RomWBW Serial Port</td>
</tr>
<tr>
<td>CPN3SER.LBR</td>
<td>CP/NET 3</td>
<td>CP/M 3</td>
<td>RomWBW Serial Port</td>
</tr>
</tbody>
</table>
<p>First, you need to merge the files from the correct library file into
user area 0. This is done by extracting the files using the <code>NULU</code>
library management utility application.</p>
<ol>
<li>
<p>Start NULU specifying desired CP/NET library for \&lt;filename&gt;:</p>
<p><code>A&gt;NULU 4:&lt;filename&gt;</code></p>
</li>
<li>
<p>At the NULU prompt, extract the files using the <code>-E *.*</code> command:</p>
<p><code>-READY A0:&gt;-E *.*</code></p>
</li>
<li>
<p>Exit NULU using the <code>-X</code> command:</p>
<p><code>-Extract members A0:&gt;-x</code></p>
</li>
</ol>
<p>Here is an example of extracting the CP/NET 1.2 client files for an
RCBus system w/ MT011. You should be in user area 0 when performing this
operation.</p>
<pre><code>A&gt;nulu 4:cpn12mt
NULU 1.52  (07/12/87)
Copyright (C) 1984, 1985 &amp; 1987 by Martin Murray
Bug fixes in version 1.52 by Mick Waters

TYPE -H FOR HELP

Library A4:CPN12MT.LBR open.
(Buffer size: 259 sectors)
Active entries: 27, Deleted: 0, Free: 5, Total: 32.
-READY A0:&gt;-e *.*
Extracting...
  CCP     .SPR to A0:CCP     .SPR
  CPM2NET .HLP to A0:CPM2NET .HLP
  CPNBOOT .COM to A0:CPNBOOT .COM
  CPNET12 .HLP to A0:CPNET12 .HLP
  CPNETLDR.COM to A0:CPNETLDR.COM
  CPNETSTS.COM to A0:CPNETSTS.COM
  DSKRESET.COM to A0:DSKRESET.COM
  ENDLIST .COM to A0:ENDLIST .COM
  LOCAL   .COM to A0:LOCAL   .COM
  LOGIN   .COM to A0:LOGIN   .COM
  LOGOFF  .COM to A0:LOGOFF  .COM
  MAIL    .COM to A0:MAIL    .COM
  NDOS    .SPR to A0:NDOS    .SPR
  NETDOWN .COM to A0:NETDOWN .COM
  NETSTAT .COM to A0:NETSTAT .COM
  NETWORK .COM to A0:NETWORK .COM
  NVRAM   .COM to A0:NVRAM   .COM
  PIPNET  .COM to A0:PIPNET  .COM
  RDATE   .COM to A0:RDATE   .COM
  SNIOS   .SPR to A0:SNIOS   .SPR
  SRVSTAT .COM to A0:SRVSTAT .COM
  TR      .COM to A0:TR      .COM
  WIZCFG  .COM to A0:WIZCFG  .COM
  WIZDBG  .COM to A0:WIZDBG  .COM
  WIZTEST .COM to A0:WIZTEST .COM
  XSUBNET .COM to A0:XSUBNET .COM
-Extract members A0:&gt;-x

Closing A4:CPN12MT.LBR...
</code></pre>
<p>At this point, you will need to configure your ethernet adapter for your
local network using <code>WIZCFG</code>. The definitive guide to the use of
<code>WIZCFG</code> is on the <a href="https://github.com/durgadas311/cpnet-z80">cpnet-z80</a>
site in the document called “CPNET-WIZ850io.pdf”. Here is an example of
the commands needed to configure the WizNet:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>wizcfg w n F0</code></td>
<td>set CP/NET node id</td>
</tr>
<tr>
<td><code>wizcfg w i 192.168.1.201</code></td>
<td>set WizNet IP address</td>
</tr>
<tr>
<td><code>wizcfg w g 192.168.1.1</code></td>
<td>set local network gateway IP address</td>
</tr>
<tr>
<td><code>wizcfg w s 255.255.255.0</code></td>
<td>set WizNet subnet mask</td>
</tr>
<tr>
<td><code>wizcfg w 0 00 192.168.1.3 31100</code></td>
<td>set server node ID, IP address, &amp; port</td>
</tr>
</tbody>
</table>
<p>You will need to use values appropriate for your local network. You can
use the command <code>wiznet w</code> to display the current values which is useful
to confirm they have been set as intended.</p>
<pre><code>A&gt;wizcfg w
Node ID:  F0H
IP Addr:  192.168.1.201
Gateway:  192.168.1.1
Subnet:   255.255.255.0
MAC:      98:76:B6:11:00:C4
Socket 0: 00H 192.168.1.3 31100 0
</code></pre>
<p>These values can be persisted across power-cycles if your system has
NVRAM storage. To program the values into your NVRAM, you would use the
same commands as above, but omit the <code>w</code> parameter. The
“CPNET-WIZ850io.pdf” document is highly recommended to understand the
operation of <code>WIZCFG</code>.</p>
<p>If you do not utilize NVRAM to persist your configuration, you will need
to reapply these commands every time you power cycle your RomWBW
computer, so I recommend putting them into a <code>SUBMIT</code> file.</p>
<p>After applying these commands, you should be able ping the WizNet from
another computer on the local network. If this works, then the
client-side is ready.</p>
<h2 id="cpnet-sever-setup">CP/NET Sever Setup</h2>
<p>These instructions will assume you are using Douglas Miller’s
CpnetSocketServer to implement a CP/NOS server on your network. The
definitive guide to this software is also on the [cpnet-z80]
(https://github.com/durgadas311/cpnet-z80) site and is called
“CpnetSocketServer.pdf”.</p>
<p>The software is a Java application, so it can generally run anywhere
there is a Java runtime environment available. I have normally used it
on a Linux system and have had good results with that.</p>
<p>You will need to download the application called “CpnetSocketServer.jar”
from the <a href="https://github.com/durgadas311/cpnet-z80">cpnet-z80</a> site. The
application uses a configuration file. My configuration file is called
“cpnet00.rc” and has these contents:</p>
<pre><code>cpnetserver_host = 192.168.1.3
cpnetserver_port = 31100
cpnetserver_temp = P
cpnetserver_sid = 00
cpnetserver_max = 16
cpnetserver_root_dir = /home/wayne/cpnet/root
</code></pre>
<p>You will also need to setup a directory structure with the drive letters
per the documentation.</p>
<p>To start the server, you would use a command like this:</p>
<p><code>java -jar CpnetSocketServer.jar conf=cpnet00.rc</code></p>
<p>At this point, the server should start and you should see the following:</p>
<pre><code>CpnetSocketServer v1.3
Using config in cpnet00.rc
Server 00 Listening on 192.168.1.3 port 31100 debug false
</code></pre>
<p>Your CP/NET server should now be ready to accept client connections.</p>
<h2 id="cpnet-usage">CP/NET Usage</h2>
<p>With both the client and server configured, you are ready to load and
use CP/NET on your RomWBW system. CP/NET documentation is available on
the <a href="https://github.com/durgadas311/cpnet-z80">cpnet-z80</a> site. The
document is called “dri-cpnet.pdf”.</p>
<p>Under CP/M 2.2, you will start the networking client using the command
<code>CPNETLDR</code>. Under CP/M 3, you use the command <code>NDOS3</code>. If that works,
you can map network drives as local drives using the <code>NETWORK</code> command.
The <code>CPNETSTS</code> command is useful for displaying the current status. Here
is a sample session from CP/M 2.2:</p>
<pre><code>A&gt;cpnetldr


CP/NET 1.2 Loader
=================

BIOS         E600H  1A00H
BDOS         D800H  0E00H
SNIOS   SPR  D400H  0400H
NDOS    SPR  C800H  0C00H
TPA          0000H  C800H

CP/NET 1.2 loading complete.

A&gt;network k:=c:[0]

A&gt;dir k:
K: TELNET   COM : ZDENST   COM : CLRDIR   COM : RTC      COM
K: DDTZ     COM : MBASIC   COM : XSUBNET  COM : NETWORK  COM
K: WGET     COM : UNCR     COM : FLASH    COM : PIP      COM
K: TIMEZONE COM : COMPARE  COM : ZAP      COM

A&gt;cpnetsts

CP/NET 1.2 Status
=================
Requester ID = F0H
Network Status Byte = 10H
Disk device status:
  Drive A: = LOCAL
  Drive B: = LOCAL
  Drive C: = LOCAL
  Drive D: = LOCAL
  Drive E: = LOCAL
  Drive F: = LOCAL
  Drive G: = LOCAL
  Drive H: = LOCAL
  Drive I: = LOCAL
  Drive J: = LOCAL
  Drive K: = Drive C: on Network Server ID = 00H
  Drive L: = LOCAL
  Drive M: = LOCAL
  Drive N: = LOCAL
  Drive O: = LOCAL
  Drive P: = LOCAL
Console Device = LOCAL
List Device = LOCAL
</code></pre>
<p>If you are using CpSocketServer to provide the CP/NOS server, then you
will see some messages on your server console when clients connect. Here
are the messages issued by the server in the above example:</p>
<pre><code>Connection from 192.168.1.201 (31100)
Remote 192.168.1.201 is f0
Creating HostFileBdos 00 device with root dir /home/wayne/cpnet/root
</code></pre>
<p>At this point CP/NET is ready for general use. You should be able to
access files on the network mapped drives just like files on your local
drives.</p>
<h2 id="network-boot">Network Boot</h2>
<p>It is possible to boot your RomWBW system directly from a network server
if it has the required hardware. This means that the operating system
will be loaded directly from the network server and all of your drive
letters will be provided by the network server. The supported hardware
is:</p>
<ul>
<li>RCBus System w/ MT011 including:</li>
<li>Featherwing WizNet W5500</li>
<li>SPI FRAM on secondary SPI interface (CS2)</li>
<li>Doudyne Disk I/O Board including:</li>
<li>WIZ850io Module</li>
<li>25LCxxx Serial SPI EEPROM</li>
</ul>
<p>Unlike the CP/NET Client, the presence of dedicated non-volatile storage
is required to hold the network configuration. This will be FRAM (for
MT011) or Serial SPI EEPROM (Duodyne). The NVRAM is used to store your
WizNet configuration values so they do not need to be re-entered every
time you power-cycle your system.</p>
<p>It is important to understand that the operating system that is loaded
in this case is <strong>not</strong> a RomWBW enhanced operating system. Some
commands (such as the <code>ASSIGN</code> command) will not be possible. Also, you
will only have access to drives provided by the network server – no
local disk drives will be available.</p>
<p>Using the same values from the previous example, you would issue the
<code>WIZCFG</code> commands:</p>
<pre><code>wizcfg n F0
wizcfg i 192.168.1.201
wizcfg g 192.168.1.1
wizcfg s 255.255.255.0
wizcfg 0 00 192.168.1.3 31100
</code></pre>
<p>Note that the ‘w’ parameter is now omitted which causes these values to
be written to NVRAM.</p>
<p>As before, your network server will need to be running
CpnetSocketServer. However, you will need to setup a directory that
contains some files that will be sent to your RomWBW system when the
Network boot is performed. By default the directory will be <code>~/NetBoot</code>.
In this directory you need to place the following files:</p>
<ul>
<li><code>cpnos.sys</code></li>
<li><code>ndos.spr</code></li>
<li><code>snios.spr</code></li>
</ul>
<p>You also need to make sure CpnetSocketServer is configured with an ‘A’
drive and that drive must contain (at an absolute minimum) the following
file:</p>
<ul>
<li><code>ccp.spr</code></li>
</ul>
<p>All of these files are found in the Binary/CPNET/NetBoot directory of
the RomWBW distribution. You will find 2 sub-directories named MT and
DUO. Get the files from the sub-directory corresponding to your specific
hardware.</p>
<p>Finally, you need to add the following line to your CpnetSocketServer
configuration file:</p>
<p><code>netboot_default = cpnos.sys</code></p>
<p>To perform the network boot, you start your RomWBW system normally which
should leave you at the Boot Loader prompt. The ‘N’ command will
initiate the network boot. Here is an example of what this looks like:</p>
<pre><code>RCBus [RCZ180_nat_wbw] Boot Loader

Boot [H=Help]: n

Loading Network Boot...
MT011 WizNET Network Boot

WBWBIOS  SPR  FD00 0100
COBDOS   SPR  FA00 0300
SNIOS    SPR  F600 0400
NDOS     SPR  EA00 0C00

58K TPA

A&gt;
</code></pre>
<p>The CP/M operating system and the CP/NET components have been loaded
directly from the network server. All of your drive letters are
automatically mapped directly to the drive letters configured with
CpnetSocketServer.</p>
<pre><code>A&gt;cpnetsts

CP/NET 1.2 Status
=================
Requester ID = F0H
Network Status Byte = 10H
Disk device status:
  Drive A: = Drive A: on Network Server ID = 00H
  Drive B: = Drive B: on Network Server ID = 00H
  Drive C: = Drive C: on Network Server ID = 00H
  Drive D: = Drive D: on Network Server ID = 00H
  Drive E: = Drive E: on Network Server ID = 00H
  Drive F: = Drive F: on Network Server ID = 00H
  Drive G: = Drive G: on Network Server ID = 00H
  Drive H: = Drive H: on Network Server ID = 00H
  Drive I: = Drive I: on Network Server ID = 00H
  Drive J: = Drive J: on Network Server ID = 00H
  Drive K: = Drive K: on Network Server ID = 00H
  Drive L: = Drive L: on Network Server ID = 00H
  Drive M: = Drive M: on Network Server ID = 00H
  Drive N: = Drive N: on Network Server ID = 00H
  Drive O: = Drive O: on Network Server ID = 00H
  Drive P: = Drive P: on Network Server ID = 00H
Console Device = LOCAL
List Device = LOCAL
</code></pre>
<p>At this point you can use CP/M and CP/NET normally, but all disk access
will be to/from the network drives. There is no access to your local
disk drives in this boot mode.</p>
<h1 id="transferring-files">Transferring Files</h1>
<p>Transferring files between your modern computer and your RomWBW system
can be achieved in a variety of ways. The most common of these are
described below. All of these have a certain degree of complexity and I
encourage new users to use the available community forums to seek
assistance as needed.</p>
<h2 id="serial-port-transfers">Serial Port Transfers</h2>
<p>RomWBW provides an serial file transfer program called XModem that has
been adapted to run under RomWBW hardware. The program is called <code>XM</code>
and is on your ROM disk as well as all of the pre-built disk images.</p>
<p>You can type <code>XM</code> by itself to get usage information. In general, you
will run <code>XM</code> with parameters to indicate you want to send or receive a
file on your RomWBW system. Then, you will use your modern computers
terminal program to complete the process.</p>
<p>The <code>XM</code> application generally tries to detect the hardware you are
using and adapt to it. However, you must ensure that you have a reliable
serial connection. You must also ensure that the speed of the connection
is not too fast for XModem to service. If your file transfer attempts
are failing, try either of the following:</p>
<ul>
<li>Check that hardware flow control is enabled in your terminal emulation
  software.</li>
<li>Reduce the speed of your serial port connection.</li>
</ul>
<p>There is an odd interaction between XModem and partner terminal programs
that can occur. Essentially, after launching <code>XM</code>, you must start the
protocol on your modern computer fairly quickly (usually in about 20
seconds or so). So, if you do not pick a file on your modern computer
quickly enough, you will find that the transfer completes about 16K,
then hangs. The interaction that causes this is beyond the scope of this
document.</p>
<h2 id="disk-image-transfers">Disk Image Transfers</h2>
<p>It is possible to pass disk images between your RomWBW system and your
modern computer. This assumes you have an appropriate media slot on your
modern computer for the media you want to use (CF Card, SD Card, floppy
drive, etc.).</p>
<p>The general process to get files from your modern computer to a RomWBW
computer is:</p>
<ol>
<li>
<p>Use <code>cpmtools</code> on your modern computer to create a RomWBW CP/M
    filesystem image.</p>
</li>
<li>
<p>Insert your RomWBW media (CF Card, SD Card, floppy disk, etc.) in
    your modern computer.</p>
</li>
<li>
<p>Use a disk imaging tool to copy the RomWBW filesystem image onto the
    media.</p>
</li>
<li>
<p>Move the media back to the RomWBW computer.</p>
</li>
</ol>
<p>This process is a little complicated, but it has the benefit of allowing
you to get a lot of files over to your RomWBW system quickly and with
little chance of corruption.</p>
<p>The process can be run in reverse to get files from your RomWBW computer
to a modern computer.</p>
<p>The exact use of these tools is a bit too much for this document, but
the tools are all included in the RomWBW distribution along with usage
documents.</p>
<p>Note that the build scripts for RomWBW create the default disk images
supplied with RomWBW. It is relatively easy to customize the contents of
the disk images that are part of RomWBW. This is described in more
detail in the Source/Images directory of the distribution.</p>
<h2 id="fat-filesystem-transfers">FAT Filesystem Transfers</h2>
<p>The FAT filesystem format that originated with MS-DOS is almost
ubiquitous across modern computers. Virtually all operating systems now
support reading and writing files to a FAT filesystem. For this reason,
RomWBW now has the ability to read and write files on FAT filesystems.</p>
<p>This capability means that you can generally use your modern computer to
make an SD Card, CF Card, or USB Drive with a standard FAT filesystem on
it, then place that media in your RomWBW computer and access the files.</p>
<ul>
<li>
<p>Files can be copied between a FAT filesystem and a CP/M filesystem,
  but you cannot execute files directly from a FAT filesystem.</p>
</li>
<li>
<p>FAT12, FAT16, and FAT32 formats are supported.</p>
</li>
<li>
<p>Long filenames are not supported. Files with long filenames will show
  up with their names truncated into the older 8.3 convention. If you
  have files on your modern computer with long filenames, it is usually
  easiest to rename them on the modern computer.</p>
</li>
<li>
<p>A FAT filesystem can be located on floppy or hard disk media. For hard
  disk media, a valid FAT Filesystem partition must exist.</p>
</li>
</ul>
<p>Some additional <strong>Notes</strong> and <strong>WARNINGS</strong> Things to be careful about</p>
<ul>
<li>CP/M (and compatible) OSes do not support all of the filename
  characters that a modern computer does. The following characters are
  <strong>not permitted</strong> in a CP/M filename:</li>
</ul>
<p><code>&lt; &gt; . , ; : = ? * [ ] _ % | ( ) / \</code></p>
<p>The FAT application does not auto-rename files when it encounters
  invalid filenames. It will just issue an error and quit. Additionally,
  the error message is not very clear about the problem.</p>
<ul>
<li>Microsoft Windows will sometimes suggest <strong>reformatting</strong> partitions
  that it does not recognize (e.g. RomWBW). If you are using media that
  contains both a FAT partition and a RomWBW partition you may prompted
  to format a partition of your SD/CF/USB Media when inserting the card
  into a Windows computer, you probably want to select Cancel.</li>
</ul>
<h3 id="fat-filesystem-preparation">FAT Filesystem Preparation</h3>
<p>In general, you can create media formatted with a FAT filesystem on your
RomWBW computer or on your modern computer. We will only be discussing
the RomWBW-based approach here.</p>
<h4 id="floppy-disk">Floppy Disk</h4>
<p>In the case of a floppy disk, you can use the <code>FAT</code> application to
format the floppy disk. The floppy disk must already be physically
formatted using RomWBW FDU or equivalent. If your floppy disk is on
RomWBW disk unit 2, you could use <code>FAT FORMAT 2:</code>. This will overwrite
the floppy with a FAT filesystem and all previous contents will be lost.
Once formatted this way, the floppy disk can be used in a floppy drive
attached to a modern computer or it can be used on RomWBW using the
other <code>FAT</code> tool commands.</p>
<h4 id="hard-disk">Hard Disk</h4>
<p>In the case of hard disk media, it is necessary to have a FAT partition.
If you prepared your RomWBW hard disk media using the disk image
process, then this partition will already be defined and you do not need
to recreate it. This default FAT partition is located at approximately
512MB from the start of your disk and it is 384MB in size. So, your hard
disk media must be 1GB or greater to use this default FAT partition.</p>
<p>You can confirm the existence of the FAT partition with <code>FDISK80</code> by
using the ‘P’ command to show the current partition table. Here is an
example of a partition table listing from <code>FDISK80</code> that includes the
FAT partition (labelled “FAT16”):</p>
<pre><code>Capacity of disk 4:  (  4G)  7813120      Geom 77381010
Nr  ---Type- A --      Start         End   LBA start  LBA count  Size
 1    RomWBW   2e      8:0:1  1023:15:16        2048    1048576  512M
 2     FAT16   06   1023:0:1  1023:15:16     1050624     786432  384M
 3             00       *** empty ***
 4             00       *** empty ***
</code></pre>
<p>If your hard disk media does not have a FAT partition already defined,
you will need to define one using FDISK80 by using the ‘N’ command.
Ensure that the location and size of the FAT partition does not overlap
any of the CP/M slice area and that it fits within the size of your
media.</p>
<p>Once the partition is defined, you will still need to format it. Just as
with a floppy disk, you use the <code>FAT</code> tool to do this. If your hard disk
media is on RomWBW disk unit 4, you would use <code>FAT FORMAT 4:</code>. This will
look something like this:</p>
<pre><code>E&gt;fat format 4:

About to format FAT Filesystem on Disk Unit #4.
All existing FAT partition data will be destroyed!!!

Continue (y/n)?

Formatting... Done
</code></pre>
<p>Your FAT filesystem is now ready to use.</p>
<p>If your RomWBW system has multiple disk drives/slots, you can also just
create a disk with your modern computer that is a dedicated FAT
filesystem disk. You can use your modern computer to format the disk
(floppy, CF Card, SD Card, etc.), then insert the disk in your RomWBW
computer and access it using <code>FAT</code> based on its RomWBW unit number.</p>
<h3 id="fat-application-usage">FAT Application Usage</h3>
<p>Transferring files is accomplished by running a RomWBW custom
application called <code>FAT</code>. This application understands both FAT
filesystems as well as CP/M filesystems.</p>
<p>To copy files from your modern computer to your RomWBW computer, start
by putting the disk media with the FAT filesystem in your modern
computer. The modern computer should recognize it. Then copy the files
you want to get to your RomWBW computer onto this media. Once done,
remove the media from your modern computer and insert it in the RomWBW
computer.</p>
<p>Finally, use the <code>FAT</code> tool to copy the files onto a CP/M drive. This
process works just fine in reverse if you want to copy files from a CP/M
filesystem to your modern computer.</p>
<p>Complete instructions for the <code>FAT</code> application are found in <a href="https://github.com/wwarthen/RomWBW/raw/master/Doc/RomWBW%20Applications.pdf">RomWBW
Applications</a>.
Here, we will just provide a couple of simple examples. Note that the
FAT application is not on the ROM disk because it is too large to
include there.</p>
<p>The most important thing to understand about the <code>FAT</code> application is
how it refers to FAT filesystems vs. CP/M filesystems. It infers this
based on the file specification provided. If you use a specification
like <code>C:SAMPLE.TXT</code>, it will use the C: drive of your CP/M operating
system. If you use a specification like <code>4:SAMPLE.TXT</code>, it will use the
FAT filesystem on the disk in RomWBW disk unit 4. Basically, if you
start your file or directory specification with a number followed by a
colon, it means FAT filesystem. Anything else will mean CP/M filesystem.</p>
<p>Here are a few examples. This first example shows how to get a FAT
directory listing from RomWBW disk unit 4:</p>
<pre><code>E&gt;fat dir 4:

Directory of 4:


E&gt;
</code></pre>
<p>As you can see, there are currently no files there. Now let’s copy a
file from CP/M to the FAT directory:</p>
<pre><code>E&gt;fat copy sample.txt 4:

Copying...

SAMPLE.TXT ==&gt; 4:/SAMPLE.TXT ... [OK]

    1 File(s) Copied
</code></pre>
<p>If we list the FAT directory again, you will see the file:</p>
<pre><code>E&gt;fat dir 4:

Directory of 4:

01/30/2023  17:50:14         29952  ---A  SAMPLE.TXT
</code></pre>
<p>Now let’s copy the file from the FAT filesystem back to CP/M. This time
we will get a warning about overwriting the file. For this example, we
don’t want to do that, so we abort and reissue the command specifying a
new filename to use:</p>
<pre><code>E&gt;fat copy 4:sample.txt e:

Copying...

4:/SAMPLE.TXT ==&gt; E:SAMPLE.TXT Overwrite? (Y/N) [Skipped]

    0 File(s) Copied

E&gt;fat copy 4:sample.txt e:sample2.txt

Copying...

4:/SAMPLE.TXT ==&gt; E:SAMPLE2.TXT ... [OK]

    1 File(s) Copied
</code></pre>
<p>Finally, let’s try using wildcards:</p>
<pre><code>E&gt;fat copy sample*.* 4:

Copying...

SAMPLE.TXT ==&gt; 4:/SAMPLE.TXT Overwrite? (Y/N) ... [OK]
SAMPLE2.TXT ==&gt; 4:/SAMPLE2.TXT ... [OK]

    2 File(s) Copied
</code></pre>
<h1 id="customizing-romwbw">Customizing RomWBW</h1>
<h2 id="startup-command-processing">Startup Command Processing</h2>
<p>Most of the operating systems supported by RomWBW provide a mechanism to
run commands at boot. This is similar to the AUTOEXEC.BAT files from
MS-DOS.</p>
<p>With the exception of ZPM3 and p-System, all operating systems will look
for a file called <code>PROFILE.SUB</code> on the system drive at boot. If it is
found, it will be processed as a standard CP/M submit file. You can read
about the use of the SUBMIT facility in the CP/M manuals included in the
RomWBW distribution. Note that the boot disk must also have a copy of
<code>SUBMIT.EXE</code>.</p>
<p>Note that the automatic startup processing generally requires booting to
a disk drive. Since the ROM disk is not writable, there is no simple way
to add/edit a <code>PROFILE.SUB</code> file there. If you want to customize your
ROM and add a <code>PROFILE.SUB</code> file to the ROM Disk, it will work, but is a
lot harder than using a boot disk.</p>
<p>In the case of ZPM3, the file called <code>STARTZPM.COM</code> will be run at boot.
To customize this file, you use the ZCPR ALIAS facility. You will need
to refer to ZCPR documentation for more information on the ALIAS
facility.</p>
<p>p-System has its own startup command processing mechanism that is
covered in the p-System documentation.</p>
<h2 id="nvram-configuration">NVRAM Configuration</h2>
<p>See section <a href="#setting-nvram-options">Setting NVRAM Options</a> for
information about how to apply NVRAM configuration.</p>
<h2 id="rom-customization">ROM Customization</h2>
<p>The pre-built ROM images are configured for the basic capabilities of
each platform. Additionally, some of the typical add-on hardware for
each platform will be automatically detected and used. If you want to go
beyond this, RomWBW provides a very flexible configuration mechanism
based on configuration files. Creating a customized ROM requires running
a build script, but it is quite easy to do.</p>
<p>Essentially, the creation of a custom ROM is accomplished by updating a
small configuration file, then running a script to compile the software
and generate the custom ROM and disk images. There are build scripts for
Windows, Linux, and MacOS to accommodate virtually all users. All
required build tools (compilers, assemblers, etc.) are included in the
distribution, so it is not necessary to setup a build environment on
your computer.</p>
<p>RomWBW can be built on modern Windows, Linux, or MacOS computers. The
process for building a custom ROM is documented in the ReadMe.txt file
in the Source directory of the distribution. Any modern version of
Windows (32-bit or 64-bit), MacOS, or Linux released in the last 10
years should be able to run the build process.</p>
<p>For those who are interested in more than basic system customization,
note that all source code is provided (including the operating systems).
Modification of the source code is considered an expert level task and
is left to the reader to pursue.</p>
<p>Note that the ROM customization process does not apply to UNA. All UNA
customization is performed within the ROM setup script that is built
into the ROM.</p>
<h2 id="rom-user-application">ROM User Application</h2>
<p>The User App is provided as a way to access a custom written ROM
application. In the pre-built ROMs, selecting User App will just return
to the Boot Loader menu. If you are interested in creating a custom
application to run instead, review the “usrrom.asm” file in the
Source/HBIOS folder of the distribution.</p>
<h1 id="upgrading">Upgrading</h1>
<p>Upgrading to a newer release of RomWBW is essentially just a matter of
updating the ROM chip in your system. If you have spare ROM chips for
your system and a ROM programmer, it is always safest to retain your
existing, working ROM chip and program a new one with the new firmware.
If the new one fails to boot, you can easily return to the known working
ROM.</p>
<p>For each ROM that comes with the RomWBW distribution, you will find that
there are actually 3 different variants:</p>
<ul>
<li><code>.rom</code> contains the complete ROM chip image</li>
<li><code>.upd</code> contains the system code, but omits the ROM Disk contents</li>
<li><code>.com</code> contains a CP/M executable version of the ROM code</li>
</ul>
<p>So, for example, RCZ80_std contains the following files:</p>
<ul>
<li><code>SBC_std.rom</code></li>
<li><code>SBC_std.upd</code></li>
<li><code>SBC_std.com</code></li>
</ul>
<p>The use of the <code>.com</code> variant is described below in <a href="#application-boot">Application
Boot</a>.</p>
<p>As previously discussed, the ROM in most RomWBW systems contains both
the system code as well as a ROM Disk with files on it. The <code>.rom</code>
variant of the ROM contains a full ROM chip image including both the
system code and the Rom Disk contents. The <code>.upd</code> variant of the ROM
contains only the system code portion of the ROM. If you apply the
<code>.upd</code> variant to your system, it will overlay the system code, but will
not overlay the ROM Disk contents (they remain intact). You may use
either the <code>.rom</code> or the <code>.upd</code> file when updating your ROM chip (this
does not apply to Application Boot). It is best to use the <code>.rom</code> file
for your upgrade because the files on your ROM Disk should be updated
whenever you update your system code. The advantage of the <code>.upd</code>
variant is that is much smaller, so you can upload and apply it faster.
The ROM update instructions below generally refer to using the <code>.rom</code>
variant. However, you may substitute the <code>.upd</code> variant if desired.</p>
<h2 id="application-boot">Application Boot</h2>
<p>Prior to attempting to reprogram your actual ROM chip, you may wish to
“try” the update to ensure it will work on your system. With RomWBW, you
can upload a new ROM image executable and load it from the command line.
For each ROM image file (.rom) in the Binary directory, you will find a
corresponding application file (.com). For example, for SBC_std.rom,
there is also an SBC_std.com file.</p>
<p>You can upload the <code>.com</code> file to your system using XModem, then simply
run the <code>.com</code> file. You will see your system go through the normal
startup process just like it was started from ROM. However, your
physical ROM has not been updated and the next time you boot your
system, it will revert to the system image contained in ROM.</p>
<p>Using this <code>.com</code> version of a ROM is an excellent way to confirm that
the new ROM code you intend to program will work correctly. If it does
not, then you can just reboot and your old ROM will be loaded.</p>
<p>When the <code>.com</code> file is loaded, you will be taken to the normal Boot
Loader menu. However, you will find that the only OS that is available
to boot from ROM is ZSDOS. There is only room for a single OS in the
.com file. Even if you don’t normally use ZSDOS, this will still confirm
that your system operates well under the new ROM code.</p>
<h2 id="upgrading-via-flash-utility">Upgrading via Flash Utility</h2>
<p>If you do not have easy access to a ROM programmer, it is usually
possible to reprogram your system ROM using the FLASH utility from Will
Sowerbutts. This application, called FLASH.COM, can be found on the ROM
drive of any running system. In this case, you would need to transfer
the new ROM image (.rom) over to your system using XModem (or one of the
other mechanisms described in the <a href="#transferring-files">Transferring
Files</a> section). The ROM image is too large to fit
on your RAM drive, so you will need to transfer it to a larger storage
drive. Once the ROM image is on your system, you can use the FLASH
application to update your ROM. The following is a typical example of
transferring ROM image using XModem and flashing the chip in-situ.</p>
<p><strong>NOTE</strong>: The FLASH utility <strong>can not</strong> determine the type of your ROM
chip if it is write protected. Additionally, it has no way to determine
if it is write protected. If the FLASH utility indicates it does not
recognize your ROM chip, check to ensure the chip is not write
protected.</p>
<pre><code>E&gt;xm r rom.rom

XMODEM v12.5 - 07/13/86
RBC, 28-Aug-2019 [WBW], ASCI

Receiving: E0:ROM.IMG
7312k available for uploads
File open - ready to receive
To cancel: Ctrl-X, pause, Ctrl-X

Thanks for the upload

E&gt;flash write rom.rom
FLASH4 by Will Sowerbutts &lt;will@sowerbutts.com&gt; version 1.2.3

Using RomWBW (v2.6+) bank switching.
Flash memory chip ID is 0xBFB7: 39F040
Flash memory has 128 sectors of 4096 bytes, total 512KB
Write complete: Reprogrammed 2/128 sectors.
Verify (128 sectors) complete: OK!
</code></pre>
<p>Obviously, there is some risk to this approach since any issues with the
programming or ROM image could result in a non-functional system.</p>
<p>To confirm your ROM chip has been successfully updated, restart your
system and boot an operating system from ROM. Do not boot from a disk
device yet. Review the boot messages to see if any issues have occurred.</p>
<h2 id="upgrading-via-xmodem-flash-updater">Upgrading via XModem Flash Updater</h2>
<p>Similar to using the Flash utility, the system ROM can be updated or
upgraded through the ROM-based updater utility. This works by
reprogramming the flash ROM as the file is being transferred.</p>
<p>Using the ROM-based updater has the advantage that secondary storage is
not required to hold the new image. In other words, it is not necessary
to have a mass storage device available to store the ROM image.</p>
<p>From the Boot Loader menu select X (Xmodem Flash Updater) and then U
(Begin Update). Then initiate the Xmodem transfer of the <code>.rom</code> file.
Since the XModem Flash Updater will be relatively slow, you may wish to
use the <code>.upd</code> varient of the ROM.</p>
<p>More information can be found in the ROM Applications document.</p>
<h2 id="post-upgrade-update">Post Upgrade Update</h2>
<p>Once you are satisfied that the ROM is working well, you will need to
update the system images and RomWBW custom applications on your disk
drives. The system images and custom applications are matched to the
RomWBW ROM firmware in use. If you attempt to boot a disk or run
applications that have not been updated to match the current ROM
firmware, you are likely to have odd problems.</p>
<p>The simplest way to update your disk media is to just use your modern
computer to overwrite the entire media with the latest disk image of
your choice. This process is described below in the <a href="#disk-images">Disk
Images</a> section. If you wish to update existing disk media
in your system, you need to perform the following steps.</p>
<p>If the disk is bootable, you need to update the system image on the disk
using the procedure described in the <a href="#operating-systems">Operating
Systems</a> section of this document.</p>
<p>Finally, if you have copies of any of the RomWBW custom applications on
your hard disk, you need to update them with the latest copies. The
following applications are found on your ROM disk. Use COPY to copy them
over any older versions of the app on your disk:</p>
<ul>
<li>ASSIGN.COM</li>
<li>SYSCOPY.COM</li>
<li>MODE.COM</li>
<li>FDU.COM</li>
<li>FORMAT.COM</li>
<li>XM.COM</li>
<li>FLASH.COM</li>
<li>FDISK80.COM</li>
<li>TALK.COM</li>
<li>RTC.COM</li>
<li>TIMER.COM</li>
<li>FAT.COM</li>
</ul>
<p>For example: <code>B&gt;COPY ASSIGN.COM C:</code></p>
<p>Some RomWBW custom applications are too large to fit on the ROM disk. If
you are using any of these you will need to transfer them to your system
and then update all copies. These applications are found in the
Binary/Apps directory of the distribution and in all of the disk images.</p>
<ul>
<li>TUNE.COM</li>
</ul>
<p>The files normally contained on the standard ROM Disk is based on a 512K
ROM. If your system has a smaller size ROM, then not all of these files
will be included on your ROM Disk. You will need to copy them to your
system from the /Binary/Apps folder of the RomWBW distribution.</p>
<p><strong>WARNING</strong>: If you run a RomWBW-specific application that is not the
appropriate for the version of RomWBW you are running, the application
will generate an error message and abort.</p>
<h2 id="system-update">System Update</h2>
<p>As previously described, a RomWBW ROM contains ROM applications as well
as a ROM disk image. If you are upgrading your ROM with a new patch
level release, you may wish to upgrade just the application portion of
the ROM. This is referred to as a System Update.</p>
<p>If the system running ROMWBW utilizes the SST39SF040 Flash chip then it
is possible to do a System Update in place of a System Upgrade in some
cases. A System Update would involve only updating the BIOS, ROM
applications and ROM-hosted operating systems.</p>
<p>A System Update may be more favorable than a System Upgrade in cases
such as:</p>
<ul>
<li>Overwriting of the ROM drive contents is not desired.</li>
<li>Temporary disk space is unavailable to hold a full ROM image.</li>
<li>To reduce the time taken to transfer and flash a full ROM.</li>
<li>Configuration changes are only minor and do not impact disk
  applications.</li>
</ul>
<p>The RomWBW build process generates a system update file along with the
normal ROM image and can be identified by the extension “.upd”. It will
be 128Kb in size. In comparison the normal ROM image will have the
extension “.rom” and be 512Kb or 1024Kb in size.</p>
<p>Transferring and flashing the System Update is accomplished in the same
manner as described above in <a href="#upgrading-via-flash-utility">Upgrading via Flash
Utility</a> with the required difference
being that the flash application needs to be directed to complete a
partial flash using the /P command line switch.</p>
<p><code>E&gt;FLASH WRITE ROM.UPD /P</code></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
