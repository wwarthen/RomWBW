; ALTAIR 8800 BIOS with 8800 disk drives - 256 files each
;
;
;	02-May-2009, P. Schorn,	removed DJNZ, bug found by Michael Rychlik
;	19-Apr-2009, P. Schorn,	added automatic disk parameter block creation
;				for disks with sector length 128
;	15-Jan-2007, P. Schorn,	added PSH and PHM in DPB for BIOS3 compatibility
;	05-Nov-2006, P. Schorn,	configurable initial command after booting
;	14-Oct-2006, P. Schorn,	made patching and Z80 check configurable
;	09-Oct-2002, P. Schorn,	added support for simulated hard disk
;	01-Oct-2002, P. Schorn,	changed computation for memory configuration (proposed
;				by Scott LaBombard)
;	28-Apr-2002, P. Schorn,	updated for new boot ROM
;	15-Apr-2002, P. Schorn,	code clean up and simplification
;				sanity check of (cdisk) to avoid loop on "Select" error
;	03-Apr-2002, P. Schorn,	added CCP patches to allow SUBMIT
;				on non-A boot drive as well
;				moved lower case patch into BIOS
;	01-Apr-2002, P. Schorn,	fixed bug in 'gotoit'
;	31-Mar-2002, P. Schorn,	added BDOS patch to reboot in case of
;				Bad Sector message and ^C typed
;	29-Mar-2002, P. Schorn,	added symbol at end
;				warm boot now uses the correct drive
;	23-Mar-2002, P. Schorn,	added some CEO patches to BDOS

false	equ	0
true	equ	not false

initCmd	equ	false		; if true then cold boot invokes a command
sleepol	equ	true		; if true then sleep a bit while status polling
				; Note: requires SIMH

	.8080
jpopcod	equ	(jmp)		; jp op-code
jpzopcd	equ	(jz)		; jp z op-code

	.Z80
	aseg
	org	100h
	maclib	MEMCFG.LIB	; define configuration parameters

	.phase	biosph
ccp	equ	ccpph		; ccp start address
bdos	equ	bdosph + 6	; bdos start address
bios	equ	biosph		; bios start address

; default values in case configuration parameters are left undefined
	ifndef	nhdisks
nhdisks	equ	0
	endif

	ifndef	needZ80
needZ80	equ	false
	endif

	ifndef	patchOS
patchOS	equ	false
	endif

wbotloc	equ	0000h		; warm boot location
bdosloc	equ	0005h		; BDOS entry location
bioserr	equ	1		; 1 indicates BIOS error
cdisk	equ	0004h		; current disk location
ndisks	equ	8		; total number of Altair disks
tracks	equ	254		; number of tracks for regular drives
track1	equ	tracks+1	; indicator for unknown track position
asecsiz	equ	137		; sector size Altair
csecsiz	equ	0080h		; sector size CP/M
rom	equ	0ff00h		; address of Altair bootstrap loader in ROM
bootdr1	equ	rom+0037h	; taken from dskboot (offset unitnooffset1)
bootdr2	equ	rom+00b4h	; taken from dskboot (offset unitnooffset2)

;	Address		Mode	Function
;	-------		----	--------
;	selout		Out	Selects and enables controller and drive
;	statin		In	Indicates status of drive and controller
;	dskcon		Out	Controls disk function
;	secpos		In	Indicates current sector position of disk
;	dskwrit		Out	Write data
;	dskread		In	Read data

selout	equ	8		; port to select and enable controller and drive (OUT)
;	+---+---+---+---+---+---+---+---+
;	| C | X | X | X |   Device      |
;	+---+---+---+---+---+---+---+---+
;
;	C	= If this bit is 1, the disk controller selected by 'device' is
;		  cleared. If the bit is zero, 'device' is selected as the
;		  device being controlled by subsequent I/O operations.
;	X	= not used
;	Device	= value zero thru 15, selects drive to be controlled.

statin	equ	8		; port indicating status of drive and controller (IN)
;	+---+---+---+---+---+---+---+---+
;	| R | Z | I | X | X | H | M | W |
;	+---+---+---+---+---+---+---+---+
;
;	W - When 0, write circuit ready to write another byte.
;	M - When 0, head movement is allowed
;	H - When 0, indicates head is loaded for read/write
;	X - not used (will be 0)
;	I - When 0, indicates interrupts enabled (not used this simulator)
;	Z - When 0, indicates head is on track 0
;	R - When 0, indicates that read circuit has new byte to read

dskcon	equ	9		; port to control disc function (OUT)
;	+---+---+---+---+---+---+---+---+
;	| W | C | D | E | U | H | O | I |
;	+---+---+---+---+---+---+---+---+
;
;	I - When 1, steps head IN one track
;	O - When 1, steps head OUT one track
;	H - When 1, loads head to drive surface
;	U - When 1, unloads head
;	E - Enables interrupts (ignored by this simulator)
;	D - Disables interrupts (ignored by this simulator)
;	C - When 1 lowers head current (ignored by this simulator)
;	W - When 1, starts Write Enable sequence:
;	    W bit on device 'statin' (see above) will go 1 and data will be read from
;	    port 'dskread' until 137 bytes have been read by the controller from
;	    that port. The W bit will go off then, and the sector data will be written
;	    to disk. Before you do this, you must have stepped the track to the desired
;	    number, and waited until the right sector number is presented on
;	    device 'secpos', then set this bit.

secpos	equ	9		; port to indicate current sector position of disk (IN)
;	As the sectors pass by the read head, they are counted and the
;	number of the current one is available in this register.
;
;	+---+---+---+---+---+---+---+---+
;	| X | X |  Sector Number    | T |
;	+---+---+---+---+---+---+---+---+
;
;	X		= Not used
;	Sector number	= binary of the sector number currently under the head, 0-31.
;	T		= Sector True, is a 1 when the sector is positioned to read or write.

dskwrit	equ	10		; port to write data (OUT)
dskread	equ	10		; port to read data (IN)

;	All I/O is via programmed I/O. Each device has a status port
;	and a data port. A write to the status port can select
;	some options for the device although the simulator only
;	recognizes the reset command (0x03).
;	A read of the status port gets the port status:
;
;	+---+---+---+---+---+---+---+---+
;	| X | X | X | X | X | X | O | I |
;	+---+---+---+---+---+---+---+---+
;
;	I - A 1 in this bit position means a character has been received
;		on the data port and is ready to be read.
;	O - A 1 in this bit means the port is ready to receive a character
;		on the data port and transmit it out over the serial line.
;
;	A read to the data port gets the buffered character, a write
;	to the data port writes the character to the device.
constat	equ	16		; sio port 1 status port
condata	equ	17		; sio port 1 data port
punstat	equ	18		; sio port 2 status port
pundata	equ	19		; sio port 2 data port

; masks for disk controller (statin)
mhm	equ	02h		; head movement mask
mtzero	equ	40h		; head on track zero mask
mall	equ	0ffh		; everything ok mask

; commands for disk controller (dskcon)
cstepin	equ	01h		; step in command
cstepot	equ	02h		; step out command
cload	equ	04h		; load head to drive surface command
cuload	equ	08h		; unload head from drive surface command
cwrseq	equ	80h		; 'start write enable sequence' command

; masks for SIO controller (constat, punstat)
mout	equ	02h		; output allowed mask

; commands for SIO controller (constat, punstat)
creset	equ	3		; reset command

	if	nhdisks gt 0
; constants for hard disk port
hdskReset	equ	1		; command to reset controller
hdskRead	equ	2		; read command
hdskWrite	equ	3		; write command
hdskParam	equ	4		; param command
hdskport	equ	0fdh		; control port for simulated hard disk
firstSector	equ	17		; first sector to load
firstTrack	equ	0		; from this track
firstDiskAddr	equ	256*firstTrack+firstSector
sectors		equ	(ccplen+bdoslen)/csecsiz
	endif

dirent	equ	255		; number of directory entries
restrk	equ	6		; reserved tracks
dsm06	equ	1efh		; maximum data block number for disks 0 to 6
dsm07	equ	254		; maximum data block number for disk 7
spt	equ	32		; sectors per track
sptmask	equ	spt-1		; mask corresponding to 'spt'
cks	equ	(dirent+1)/4
cr	equ	13		; Carriage Return
lf	equ	10		; Line Feed

	jp	boot		; cold start
wboote:	jp	wboot		; warm start (reboot)
	jp	const		; console status
	jp	conin		; console input
	jp	conout		; console output
	jp	list		; list character out
	jp	punch		; punch character out
	jp	reader		; read character in
	jp	home		; move disk head to home
	jp	seldsk		; select disk drive
	jp	settrk		; set track number
	jp	setsec		; set sector number
	jp	setdma		; set disk memory read/write address
	jp	read		; read sector
	jp	write		; write sector
	jp	listst		; list dev status test
	jp	sectrn		; sector translate

; The BOOT entry point gets control from the cold start loader and is
; responsible for basic system initialization, including sending a sign-on
; message, which can be omitted in the first version. If the IOBYTE function
; is implemented, it must be set at this point. The various system parameters
; that are set by the WBOOT entry point must be initialized, and control is
; transferred to the CCP at 3400 + b for further processing. Note that
; register C must be set to zero to select drive A.
boot:	ld	sp,chk02
	ld	a,(bootdr1)	; load current disk with boot drive
	ld	(cdisk),a
	ld	de,msg1		; print welcome message
	call	msg

	if	needZ80
entcpm:	xor	a
	dec	a
	jp	po,ent2		; all eight bits set means parity even for 8080, po is Z80
	ld	de,msg2		; got an 8080 which is no good
	call	msg		; warn user
	halt			; wait for processor to be changed
	jp	entcpm		; and try again
ent2	equ	$
	else
entcpm	equ	$
	endif

	ld	a,jpopcod	; jp instruction code
	ld	(wbotloc),a	; store at entry to warm boot
	ld	hl,wboote	; get jump location
	ld	(wbotloc+1),hl	; and store it after jp instruction
	ld	(bdosloc),a	; jp instruction code for entry to BDOS
	ld	hl,bdos		; get jump location
	ld	(bdosloc+1),hl	; and store it after jp instruction

	if	patchOS
; begin patch CCP and BDOS
	ld	b,low ((patche-patchs) shr 2)	; number of entries in patch table
	ld	hl,patchs	; start of patch table
patch1:	ld	e,(hl)		; <E> is lower byte of address for jp instruction
	inc	hl		; point to upper byte
	ld	d,(hl)		; <DE> points to address for jp instruction
	inc	hl		; <HL> points to lower byte of source jp address
	ld	a,jpopcod	; jp op code
	ld	(de),a		; store jp op-code to appropriate location
	inc	de		; <DE> points to lower byte of destination jp address
	ld	a,(hl)		; get lower byte of address
	ld	(de),a		; store it
	inc	hl		; point to upper byte source jp address
	inc	de		; point to upper byte destination jp address
	ld	a,(hl)		; get upper byte of address
	ld	(de),a		; store it
	inc	hl		; point to next table pair
	dec	b		; entry done
	jp	nz,patch1	; if more to do

;	patch bdos to perform a ROM reboot in case of Bad Sector error
;	is detected and user has typed ^C. This is to make sure that one
;	can recover from errors due to non-existing drives.
	ld	hl,rom
	ld	(bdos+009ch),hl	; at bdos+9bh we now have jp z,rom instead of jp z,0

;       patch ccp to look on ipl drive if file not found
	ld	a,jpzopcd	; replace jp opcode with jp z opcode
	ld	(ccp+06dbh),a	; plug into ccp at intercept point

	ld	hl,lctabs
	ld	c,low ((lctabe-lctabs) / 3)	; number of table entries
;precondition: <HL> points to table with structure (byte length, word address)*
;at 'address' starts a character string of length 'length' which is to be translated to
;lower case
tolc:	ld	b,(hl)		; <HL> points to length byte
	inc	hl		; <HL> points to lower byte of address
	ld	e,(hl)		; E := lower byte of address
	inc	hl		; <HL> points to upper byte of address
	ld	d,(hl)		; D := upper byte of address
	inc	hl		; <HL> points to next length byte
	ex	de,hl
tolc1:	ld	a,(hl)		; get character to be transformed
	cp	'A'
	jp	c,tolc2		; next character if less than 'A'
	cp	'Z'+1
	jp	nc,tolc2	; next character if greater than 'Z'
	add	a,'a'-'A'	; to lower case
	ld	(hl),a		; store back
tolc2:	inc	hl		; point to next character
	dec	b		; count down length
	jp	nz,tolc1	; repeat if necessary
	ex	de,hl		; <HL> points to next length byte
	dec	c		; update number of table entries processed
	jp	nz,tolc		; if not equal to zero, continue
;end patch CCP and BDOS
	endif


	if	initCmd
	ld	de,ccp+7	; destination in CCP
	ld	hl,cmdBeg	; command length, command, 0
movCmd:	ld	a,(hl)		; get byte
	ld	(de),a		; store at destination
	or	a		; check byte
	jp	z,doneMv	; zero byte is the last, done
	inc	hl		; next source
	inc	de		; next destination
	jp	movCmd		; repeat
doneMv:	ld	(cmdBeg),a	; execute only once
	endif

	ld	a,creset	; reset command
	out	(constat),a	; reset console device
	out	(punstat),a	; and list/punch device
	ld	bc,0080h
	call	setdma
	ld	a,(cdisk)	; get current disk
	cp	ndisks+nhdisks	; does it exist?
	jp	c,ent1		; yes, proceed
	ld	a,(bootdr1)	; get boot drive
	ld	(cdisk),a	; and make it current disk
ent1:	ld	c,a		; inform CCP
	ei
	jp	ccp

	if	initCmd
cmdBeg:	db	cmdEnd-cmdBeg-2,'DO INITMAKE',0
cmdEnd	equ	$
	endif


	if	patchOS
;  DD40    3A E3EF               ld	a,(cdisk)
;  DD43    B7                    or	a
;  DD44    3E 00                 ld	a,0
;  DD46    C4 DCBD               call	nz,select
;  DD49    11 E3AC               ld	de,subfcb
;DD43:	jp	ccpp1
ccpp1:	ld	e,a		; <E> := current disk
	ld	a,(bootdr1)	; <A> := boot drive
	cp	e		; compare boot drive with current disk
	jp	ccp+0146h	; a select of boot drive occurs iff current disk <> boot drive

;  DD7D    3A E3EF               ld	a,(cdisk)
;  DD80    B7                    or	a
;  DD81    C4 DCBD               call	nz,select
;  DD84    21 DC08               ld	hl,combuf
;DD7D:	jp	ccpp2
ccpp2:	ld	a,(bootdr1)	; <A> := boot drive
	ld	e,a		; <E> := boot drive
	ld	a,(ccp+07efh)	; <A> := current disk
	cp	e		; compare boot drive with current disk
	jp	ccp+0181h	; a select of current disk occurs iff current disk <> boot drive

;  DDE3    36 00                	ld	(hl),0		;submit flag is set to false
;  DDE5    AF                   	xor	a
;  DDE6    CD DCBD              	call	select		;on drive a to erase file
;  DDE9    11 E3AC              	ld	de,subfcb
;DDE3:	jp	ccpp3
ccpp3:	ld	(hl),0		; patched over
	ld	a,(bootdr1)	; <A> := boot drive
	jp	ccp+01e6h	; go select boot drive

;	patch bdos to change the drive selected by
;	BDOS Function 13 (Reset Disk System).
f13pat:	ld	a,(bootdr1)	; get boot drive
	ld	(bdos+033ch),a	; store into curdsk (BDOS)
	jp	bdos+0c8ah

;       patch ccp to look on ipl drive if file not found
ccpat:	ld	hl,ccp+07f0h	; look at drive spec in command
	or	(hl)		; zero means default was taken
	jp	nz,ccp+076bh	; if nonzero don't change it
	ld	a,(bootdr1)	; take boot drive and increment it since
	inc	a		; for a FCB A=1, B=2, ...
	ld	(hl),a		; modify command line
	ld	de,ccp+07d6h	; setup for retry
	jp	ccp+06cdh	; go retry command

;       patch ccp to show current user number in prompt
propat:	call	ccp+0113h	; get current user no
	or	a
	jp	z,prono		; do not show it if it's 0
	cp	10		; see if 1 or 2 digits
	jp	nc,pro2
	add	a,'0'
pro1:	call	ccp+008ch	; output a character
prono:	ld	a,'>'		; prompt character
	call	ccp+008ch	; output it
	jp	ccp+0395h	; resume !
pro2:	add	a,'0' - 10
	push	af
	ld	a,'1'
	call	ccp+008ch
	pop	af
	jp	pro1

;       patch bdos to look at user 0 if file not found in current user #
pubpat:	ld	a,b		; get char count
	or	a		; looking at first byte?
	jp	nz,pubno	; no, skipit
	ld	a,(de)		; get user # from directory
	cp	0e5h		; active dir entry?
	jp	z,pubno		; no
	ld	a,(hl)		; get user# from dir entry
	or	a		; is it user # 0?
	jp	z,bdos+0776h	; yes, force char match regardless
pubno:	ld	a,b
	cp	13
	jp	bdos+075bh
	endif

; print the message pointed to by <DE> and terminated by '$' to the console
; leaves <B> unchanged
msg:	ld	a,(de)		; get character
	cp	'$'		; is is the terminating character?
	ret	z		; yes, we are done
	ld	c,a		; 'conout' expects the character in <C>
	call	conout		; disply it on console
	inc	de		; point to next character
	jp	msg		; and repeat

; The WBOOT entry point gets control when a warm start occurs. A warm
; start is performed whenever a user program branches to location 0000H, or
; when the CPU is reset from the front panel. The CP/M system must be
; loaded from the first two tracks of drive A up to, but not including, the
; BIOS, or CBIOS, if the user has completed the patch. System parameters
; must be initialized as follows:
;	location 0,1,2	Set to JMP WBOOT for warm starts
;			(000H: JMP 4A03H + b)
;	location 3	Set initial value of IOBYTE, if implemented in the
;			CBIOS
;	location 4	High nibble = current user no; low nibble current
;			drive
;	location 5,6,7	Set to JMP BDOS, which is the primary entry point
;			to CP/M for transient programs. (0005H: JMP 3C06H + b)
; Upon completion of the initialization, the WBOOT program must branch to the
; CCP at 3400H + b to restart the system. Upon entry to the CCP, register C
; is set to the drive to select after system initialization. The WBOOT
; routine should read location 4 in memory, verify that is a legal drive, and
; pass it to the CCP in register C.
wboot:	ld	sp,chk02
	ld	a,(bootdr1)	; make sure that ccp and bdos are loaded from correct disk

	if	nhdisks gt 0
	cp	ndisks
	jp	c,altdsk
	ld	b,32			; reset hard disk controller
	ld	a,hdskReset		; by issuing the reset command 32 times
rhdsk:	out	(hdskPort),a
	dec	b
	jp	nz,rhdsk		; post condition is <B> := 0
	ld	de,firstDiskAddr	; <D> := 0 (Track), <E> := 8 (Sector)
	ld	hl,ccp			; DMA address
	ld	c,sectors		; <C> is loop counter
again:	ld	a,hdskRead
	out	(hdskport),a		; send read command to hard disk port
	ld	a,(bootdr1)		; in real life take disk number from boot ROM
	sub	ndisks			; correct for Altair disks
	out	(hdskport),a		; send drive to boot from to hard disk port
	ld	a,e
	out	(hdskport),a		; send sector
	ld	a,d
	out	(hdskport),a		; send lower byte of track
	xor	a
	out	(hdskport),a		; send higher byte of track which is always 0
	ld	a,l
	out	(hdskport),a		; send lower byte of DMA address
	ld	a,h
	out	(hdskport),a		; send upper byte of DMA address
	in	a,(hdskport)		; perform operation and get result
	or	a
	jp	z,cont			; continue if no error
	halt				; halt otherwise
cont:	ld	a,c			; save <C> in <A>
	ld	c,csecsiz		; <BC> is now 128 since <B> always zero
	add	hl,bc			; get next DMA address
	ld	c,a			; restore <C> from <A>
	dec	c			; decrement loop counter
	jp	z,entcpm
	inc	e			; Sector := Sector + 2
	inc	e
	ld	a,e
	cp	spt			; is new Sector equal to 32
	jp	z,switch		; yes, need to go to odd sectors
	cp	spt+1			; is new Sector equal to 33
	jp	nz,again		; no, proceed with read
	ld	e,0			; Sector := 0
	inc	d			; Track := Track + 1
	jp	again			; proceed with read
switch:	ld	e,1			; Sector := 1
	jp	again			; proceed with read
altdsk	equ	$
	endif

	out	(selout),a	; select it
	ld	a,cload		; load head command
	out	(dskcon),a	; load head to drive surface
	call	dhome		; position disk head on track zero
	ld	de,ccp		; destination load address
	ld	b,17		; first sector to read on track zero
nextsc:	push	bc		; save current sector to read, <C> is undefined
	push	de		; save current destination load address
	call	seclp2		; position to sector in <B>
	call	blread		; read the sector
	pop	de		; restore current destination load address, <DE> is destination
	ld	hl,altbuf+3	; ignore first three byte of buffer, <HL> is source
	call	ldir		; <BC> has been set by 'blread'
	pop	bc		; <B> is current sector, <C> is undefined
	ld	hl,bios		; when <DE> reaches this address we are done
	ld	a,d
	cp	h
	jp	nz,decide
	ld	a,e
	cp	l
decide:	jp	nc,gotoit	; jump if everything loaded
	inc	b		; compute next sector number
	inc	b
	ld	a,b
	cp	spt		; compare new sector number with sectors per track
	jp	c,nextsc	; continue if less
	ld	b,1		; otherwise prepare for odd numbered sectors
	jp	z,nextsc	; if old sector number was equal to sectors per track
	call	whmove		; loop until head movement is allowed
	ld	a,cstepin	; step in one track command
	out	(dskcon),a	; step in one track
	ld	b,0		; start with even sectors
	jp	nextsc
gotoit:	ld	a,(bootdr2)	; clear disk controller of correct disk
	out	(selout),a	; do it
	ld	hl,ontrk0	; start address of table for current track positions
	ld	b,ndisks	; number of disks
resett:	ld	(hl),track1	; reset entry for disk
	inc	hl		; point to next entry
	dec	b		; decrement counter for disks to go
	jp	nz,resett	; jump if not yet done
	jp	entcpm

; You should sample the status of the currently assigned console device and
; return 0FFH in register A if a character is ready to read and 00H in register
; A if no console characters are ready.
;
; console in/out routines - use sio port 1
;
const:	in	a,(constat)	; get console status
	rra			; I bit into carry
	ld	a,0		; prepare no character available
	ret	nc		; I bit clear means no character, done
	dec	a		; character available, result is 0ffh
	ret			; done

; The next console character is read into register A, and the parity bit is set,
; high-order bit, to zero.  If no console character is ready, wait until a
; character is typed before returning.
	if	sleepol

conin:	in	a,(constat)	; get console status
	rra			; I bit into carry
	jp	c,getchr	; get character
	ld	a,27		; otherwise sleep for SIMHSleep microseconds
	out	(0feh),a	; execute command
	jp	conin		; try again
getchr:	in	a,(condata)	; read character
	and	7fh		; clear bit 8
	ret

	else

conin:	in	a,(constat)	; get console status
	rra			; I bit into carry
	jp	nc,conin	; jump back if no character available
	in	a,(condata)	; read character
	and	7fh		; clear bit 8
	ret

	endif

; The character is sent from register C to the console output device. The
; character is in ASCII, with high-order parity bit set to zero. You might
; want to include a time-out on a line-feed or carriage return, if the console
; device requires some time interval at the end of the line (such as a TI Silent
; 700 terminal). You can filter out control characters that cause the console
; device to react in a strange way (CTRL-Z causes the Lear-Siegler terminal
; to clear the screen, for example).
conout:	in	a,(constat)	; get console status
	and	mout		; mask output bit
	jp	z,conout	; jump back if not ready for output
	ld	a,c		; prepare character for output
	out	(condata),a	; do it
	ret

;
; reader/punch routines use sio port 2
;
; The character is sent from register C to the currently assigned listing
; device. The character is in ASCII with zero parity bit.
list:				; list aliased to punch
; The character is sent from register C to the currently assigned punch
; device. The character is in ASCII with zero parity.
punch:	in	a,(punstat)	; get punch status
	and	mout		; mask output bit
	jp	z,punch		; jump back if not ready for output
	ld	a,c		; prepare character for output
	out	(pundata),a	; do it
	ret

; The next character is read from the currently assigned reader device into
; register A with zero parity (high-order bit must be zero); an end-of-file
; condition is reported by returning an ASCII CTRL-Z(1AH).
reader:	in	a,(punstat)	; get reader status
	rra			; I bit into carry
	jp	nc,reader	; jump back if no character available
	in	a,(pundata)	; read character
	ret

; The disk drive given by register C is selected for further operations, where
; register C contains 0 for drive A, 1 for drive B, and so on up to 15 for
; drive P (the standard CP/M distribution version supports four drives). On
; each disk select, SELDSK must return in HL the base address of a 16-byte
; area, called the Disk Parameter Header, described in Section 6.10. For
; standard floppy disk drives, the contents of the header and associated
; tables do not change; thus, the program segment included in the sample
; CBIOS performs this operation automatically.
; If there is an attempt to select a nonexistent drive, SELDSK returns HL =
; 0000H as an error indicator. Although SELDSK must return the header
; address on each call, it is advisable to postpone the physical disk select
; operation until an I/O function (seek, read, or write) is actually performed,
; because disk selects often occur without ultimately performing any disk
; I/O, , and many controllers unload the head of the current disk before
; selecting the new drive. This causes an excessive amount of noise and disk
; wear. The least significant bit of register E is zero if this is the first
; occurrence of the drive select since the last cold or warm start.
seldsk:	ld	hl,0		; select disk number
	ld	a,c
	ld	(diskno),a
	cp	ndisks+nhdisks	; number of disk drives
	ret	nc		; error - disk number too high
	ld	l,a		; <HL> := disk number
	ld	h,0
	add	hl,hl		; disk number * 2
	add	hl,hl		; disk number * 4
	add	hl,hl		; disk number * 8
	add	hl,hl		; disk number * 16
	ld	de,dpbase	; dpbase entries have size of 16 bytes
	add	hl,de		; <HL> = 16 * disknumber + dpbase

    if	nhdisks gt 0
	ld	a,(diskno)
	cp	ndisks		; is it a hard disk?
	ret	c		; no
	push	hl		; Preserve pointer to disk descriptor
	ld	bc,10		; offset to disk parameter block address
	add	hl,bc
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a		; point at disk dpb
	push	hl		; save this pointer
	ld	a,hdskParam
	out	(hdskPort),a	; send 'get parameters' command
	ld	a,(diskno)
	sub	ndisks
	out	(hdskPort),a	; send selected HDSK number
	ld	b,17
hdskpl:	in	a,(hdskPort)	; read 17-bytes of DPB
	ld	(hl), a
	inc	hl
	dec	b
	jp	nz,hdskpl
	in	a,(hdskPort)	; read LSB of disk's physical sector size.
	cp	128		; is it 128?
	jp	nz,secnok1	; no, fail
	in	a,(hdskPort)	; read MSB of disk's physical sector size.
	or	a		; is it 0?
	jp	nz,secnok2	; no, sector size is not 128, fail
	pop	hl		; restore disk parameter block
	ld	bc,11		; offset to CKS
	add	hl,bc		; <HL> points to CKS
	ld	a,(hl)		; get lower byte
	inc	hl
	or	(hl)		; or with higher byte 
	jp	z,secok		; success if zero
	ld	de,secmsg3	; otherwise not a hard disk
	jp	prmsg		; print error message
secok:	pop	hl		; restore pointer to disk descriptor
	ret
secnok1:
	in	a,(hdskPort)	; get and drop MSB
secnok2:
	ld	de,secmsg2	; physical sector is not 128
prmsg:	call	msg		; print error message
	halt
	jp	rom
secmsg2:
	db	cr, lf, 'Physical sector size must be 128 bytes.', cr, lf, '$'
	
secmsg3:
	db	cr, lf, 'Must be a hard disk.', cr, lf, '$'
	
    else
	ret
    endif

; The disk head of the currently selected disk (initially disk A) is moved to
; the track 00 position.  If the controller allows access to the track 0 flag
; from the drive, the head is stepped until the track 0 flag is detected. If the
; controller does not support this feature, the HOME call is translated into a
; call to SETTRK with a parameter of 0.
home:	ld	bc,0		; move to track 00
				; fall into settrk

; Register BC contains the track number for subsequent disk accesses on the
; currently selected drive. The sector number in BC is the same as the
; number returned from the SECTRAN entry point. You can choose to seek
; the selected track at this time or delay the seek until the next read or write
; actually occurs.  Register BC can take on values in the range 0-76
; corresponding to valid track numbers for standard floppy disk drives and
; 0-65535 for nonstandard disk subsystems.
settrk:	ld	l,c		; save track
	ld	h,b
	ld	(track),hl
	ret

; Register BC contains the sector number, 1 through 26, for subsequent disk
; accesses on the currently selected drive. The sector number in BC is the
; same as the number returned from the SECTRAN entry point. You can
; choose to send this information to the controller at this point or delay
; sector selection until a read or write operation occurs.
setsec:	ld	a,c		; set sector
	ld	(sector),a
	ret

; Logical-to-physical sector translation is performed to improve the overall
; response of CP/M. Standard CP/M systems are shipped with a skew factor
; of 6, where six physical sectors are skipped between each logical read
; operation. This skew factor allows enough time between sectors for most
; programs to load their buffers without missing the next sector. In particular
; computer systems that use fast processors, memory, and disk subsystems,
; the skew factor might be changed to improve overall response. However,
; the user should maintain a single-density IBM-compatible version of CP/M
; for information transfer into and out of the computer system, using a skew
; factor of 6.
; In general, SECTRAN receives a logical sector number relative to zero in
; BC and a translate table address in DE. The sector number is used as an
; index into the translate table, with the resulting physical sector number in
; HL. For standard systems, the table and indexing code is provided in the
; CBIOS and need not be changed.
sectrn:
	if	nhdisks gt 0
	ld	l,c		; <HL> := BC, prepration for <DE> = 0
	ld	h,b		; load upper byte
	inc	hl		; rebase to one
	ld	a,e		; get lower byte of translate table address
	or	d		; or with upper byte
	ret	z		; if equal to zero, no translation necessary
	endif
	ex	de,hl		; <HL> := translate table address
	add	hl,bc		; add sector number
	ld	l,(hl)		; get pointed to byte
	ld	h,0		; set upper byte to zero
	ret			; done

; Register BC contains the DMA (Disk Memory Access) address for
; subsequent read or write operations. For example, if B = 00H and C = 80H
; when SETDMA is called, all subsequent read operations read their data
; into 80H through 0FFH and all subsequent write operations get their data
; from 80H through 0FFH, until the next call to SETDMA occurs. The initial
; DMA address is assumed to be 80H. The controller need not actually
; support Direct Memory Access. If, for example, all data transfers are
; through I/O ports, the CBIOS that is constructed uses the 128byte area
; starting at the selected DMA address for the memory buffer during the
; subsequent read or write operations.
setdma:	ld	l,c		; set dma address
	ld	h,b
	ld	(dmaad),hl
	ret

;
; altair disk read/write drivers
;
; Assuming the drive has been selected, the track has been set, and
; the DMA address has been specified, the READ subroutine attempts to
; read eone sector based upon these parameters and returns the following
; error codes in register A:
;
;	0	no errors occurred
;
;	1	nonrecoverable error condition occurred
;
; Currently, CP/M responds only to a zero or nonzero value as the return
; code. That is, if the value in register A is 0, CP/M assumes that the disk
; operation was completed properly. IF an error occurs the CBIOS should
; attempt at least 10 retries to see if the error is recoverable. When an error
; is reported the BDOS prints the message BDOS ERR ON x: BAD
; SECTOR. The operator then has the option of pressing a carriage return to
; ignore the error, or CTRL-C to abort.
	if	nhdisks gt 0
read:	ld	a,(diskno)	; get disk number
	cp	ndisks		; compare with number of Altair disks
	jp	c,aread		; carry means we got an Altair disk
	ld	a,hdskRead	; otherwise perform hard disk read
	jp	shdpar		; send hard disk parameters
aread	equ	$
	else
read	equ	$
	endif
	call	poshed		; select disk 'diskno' and position disk head to 'track'
	call	secget		; position head to desired sector
	di
	call	blread
	ld	a,cuload	; unload head command
	out	(dskcon),a	; do it
	ei
	ld	de,altbuf+3	; address of sector just read
	ld	hl,(dmaad)	; destination address
	ex	de,hl		; prepare for ldir
	call	ldir		; move

; You return the ready status of the list device used by the DESPOOL
; program to improve console response during its operation. The value 00 is
; returned in A if the list device is not ready to accept a character and 0FFH
; if a character can be sent to the printer.  A 00 value should be returned if
; LIST status is not implemented.
listst:	xor	a		; <A> := 0 means no error
	ret

; Data is written from the currently selected DMA address to the currently
; selected drive, track, and sector. For floppy disks, the data should be
; marked as nondeleted data to maintain compatibility with other CP/M
; systems. The error codes given in the READ command are returned in
; register A, with error recovery attempts as described above.
	if	nhdisks gt 0
write:	ld	a,(diskno)	; get disk number
	cp	ndisks		; compare with number of Altair disks
	jp	c,awrite	; carry means we got an Altair disk
	ld	a,hdskWrite	; otherwise perform hard disk write
shdpar:	out	(hdskPort),a	; send command
	ld	a,(diskno)	; get disk number
	sub	ndisks		; rebase
	out	(hdskPort),a	; send rebased disk number
	ld	a,(sector)	; get sector
	dec	a		; rebase to 0
	out	(hdskPort),a	; send rebased sector number
	ld	a,(track)	; get lower byte of track
	out	(hdskPort),a	; send lower byte of track
	ld	a,(track+1)	; get upper byte of track
	out	(hdskPort),a	; send upper byte of track
	ld	a,(dmaad)	; get lower byte DMA address
	out	(hdskPort),a	; send lower byte of DMA address
	ld	a,(dmaad+1)	; get upper byte of DMA address
	out	(hdskPort),a	; send upper byte of DMA address
	in	a,(hdskPort)	; perform command and get result
	ret
awrite	equ	$
	else
write	equ	$
	endif
	call	poshed		; select desired disk and position to desired track
	call	secget		; position head to desired sector
	ld	hl,(dmaad)	; source of sector is in 'dmaad'
	ld	de,altbuf+3	; destination inside local buffer
	ld	bc,csecsiz	; sector size is 128
	call	ldir		; block move
	ld	a,cwrseq	; command for 'start write enable sequence'
	out	(dskcon),a	; do it
	di
	ld	hl,altbuf	; point to first byte in local buffer
	ld	b,asecsiz+1	; number of bytes to write (additional byte triggers 'real' write)
wready:	in	a,(statin)	; get status
	rra			; get bit for ready for write
	jp	c,wready	; loop until ready for write
	ld	a,(hl)		; byte to write
	out	(dskwrit),a	; write byte
	inc	hl		; point to next byte
	dec	b		; decrement counter of bytes
	jp	nz,wready	; jp if not done
	ld	a,cuload	; unload head command
	out	(dskcon),a	; do it
	ei
	xor	a		; <A> := 0 means no error
	ret

; Postcondition: 'altbuf' contains 'asecsiz' many bytes, <BC> is set to 'csecsiz'
blread:	ld	hl,altbuf	; address of sector buffer
	ld	e,asecsiz	; number of bytes to read
blrd1:	in	a,(statin)	; get disk status
	or	a		; set sign of byte
	jp	m,blrd1		; loop until disk has new byte to read
	in	a,(dskread)	; read byte of sector
	ld	(hl),a		; store into buffer
	inc	hl		; point to next position in buffer
	dec	e		; decrement size counter
	jp	nz,blrd1	; if not zero, we need to continue
	ld	bc,csecsiz	; sector size in preparation for call to 'ldir'
	ret

; position disk on track zero, <A> == 0 at the end
dhome:	in	a,(statin)	; position disk to track 0
	and	mtzero		; mask for 'head is on track zero'
	ret	z		; track zero reached, done
	call	whmove		; loop until head movement is allowed
	ld	a,cstepot	; command for 'step head out one track'
	out	(dskcon),a	; do it
	jp	dhome		; try again

; Select disk 'diskno' and position disk head to 'track'
poshed:	call	calcd		; position altair disk head
	ld	a,d		; select disk <D>, cur track in <B>
	out	(selout),a	; select disk
	in	a,(statin)	; get status of selected drive
	cp	mall		; ok?
	jp	z,selerr	; no!
	ld	a,b		; <B> := track of selected disk
	cp	track1		; compare with non-existing track
	jp	nz,alseek	; if a regular track, proceed to seek
	call	dhome		; position disk to track 0
	ld	b,a		; <B> := 0 (current track)
;Input:		location 'track' contains desired track
;		<B> contains current track
;Output:	desired track is reached and stored in track array
alseek:	ld	a,(track)	; seek to 'track' (cur track in b)
	ld	e,a		; <E> := desired track
	ld	a,b		; <A> := current track
	sub	e		; <A> := current track - desired track
	ret	z		; we are already at desired track
	ld	e,a		; e is the number of "step in" or "step out"
	jp	c,stpin		; current track < desired track
	ld	c,cstepot	; command for step head out one track
	jp	aseek		; perform steps
stpin:	ld	c,cstepin	; command for step head in one track
	cpl			; <A> := ~(current track - desired track)
	inc	a		; <A> := desired track - current track (positive)
	ld	e,a		; <E> is positive number of tracks to move
aseek:	call	whmove		; loop until head movement is allowed
	ld	a,c		; get command (step in or step out)
	out	(dskcon),a	; perform it
	dec	e		; next iteration
	jp	nz,aseek	; loop if not done
	call	calcd		; get pointer to 'track' of 'diskno'
	ld	a,(track)	; this is the current track
	ld	(hl),a		; update 'track' of 'diskno'
	ret
selerr:	pop	hl		; discard return address
	ld	a,bioserr	; <A> := 1 means error
	ret

; loop until head movement is allowed
whmove:	in	a,(statin)	; get status
	and	mhm		; mask for 'head movement allowed'
	jp	nz,whmove	; loop until movement allowed
	ret

; Input:	<none> - implicit input is location 'diskno'
; Output:	<B> contains the current track of 'diskno'
;		<A>, <D> and <E> contain 'diskno'
;		<HL> points to 'track' of 'diskno'
calcd:	ld	a,(diskno)	; get 'diskno'
	ld	e,a		; <E> := 'diskno'
	ld	hl,ontrk0
	ld	d,0
	add	hl,de		; <HL> points to 'track' of 'diskno'
	ld	b,(hl)		; <B> := 'track' of 'diskno'
	ld	d,e		; <E> := 'diskno'
	ret

; Input:	'sector' contains desired sector number
; Output:	head is positioned at desired sector
secget:	ld	a,cload		; command to load head to drive surface
	out	(dskcon),a	; do it
	ld	a,(sector)	; <A> := desired sector
	dec	a		; adjust to range 0..(spt-1)
	ld	b,a		; <B> := adjusted, desired sector
	cp	spt		; compare with sectors per track
	jp	c,seclp2	; desired sector is less than total sectors per track, ok
	ld	de,secmsg	; prepare error message
	call	msg		; print it
	halt			; not much we can do
seclp2:	in	a,(secpos)	; get sector position
	rra			; rotate T bit into carry
	jp	c,seclp2	; loop until sector is positioned to read or write
	and	sptmask		; <A> now contains the sector under the head
	cp	b		; compare with desired sector
	jp	nz,seclp2	; repeat if not equal
	ret

;	Move <BC> bytes from start address <HL> to destination <DE>.
;	This is equivalent to the Z80 instruction 'LDIR'.
;	This subroutine dynamically determines the processor.
ldir:	xor	a		; <A> := 0
	dec	a		; <A> := 1111'1111b
	jp	pe,ldir1	; on an 8080 this means parity is even
	ldir			; otherwise we have a Z80
	ret
ldir1:	ld	a,(hl)		; get byte from source
	ld	(de),a		; put byte to destination
	inc	hl		; point to next source address
	inc	de		; point to next destination address
	dec	bc		; decrement number of bytes to move
	ld	a,c		; <A> := (<B> or <C>)
	or	b
	jp	nz,ldir1	; not zero, move again
	ret

	if	patchOS
lctabs:	db	9		; (R)EAD ERROR
	dw	ccp+03e0h	; DFE0
	db	6		; (N)O FILE
	dw	ccp+03f1h	; DFF1
	db	2		; (A)LL
	dw	ccp+0553h	; E153
	db	7		; (N)O SPACE
	dw	ccp+0608h	; E208
	db	10		; (F)ILE EXISTS
	dw	ccp+0683h	; E283
	db	7		; (B)AD LOAD
	dw	ccp+077bh	; E37B
lctabe	equ	$

patchs:	dw	ccp+0143h,	ccpp1	; DD43:	jp	ccpp1
	dw	ccp+017dh,	ccpp2	; DD7D:	jp	ccpp2
	dw	ccp+01e3h,	ccpp3	; DDE3:	jp	ccpp3
	dw	ccp+0392h,	propat
	dw	ccp+06dbh,	ccpat
	dw	bdos+0c86h,	f13pat
	dw	bdos+0758h,	pubpat
patche	equ	$
	endif

; In general, each disk drive has an associated (16-byte) disk parameter
; header that contains information about the disk drive and provides a
; scratch pad area for certain BDOS operations. The format of the disk
; parameter header for each drive is shown below, where each element is a
; word (16-bit) value.
;
;			DISK PARAMETER HEADER
;	+-------+------+------+------+----------+-------+-------+-------+
;	| XLT  | 0000 | 0000 | 0000 |DIRBUF| DPB  | CSV  | ALV  |
;	+------+------+------+-------+----------+-------+-------+-------+
;	  16B    16B    16B    16B    16B    16B    16B    16B
;
; XLT	Address of the logical-to-physical translation vector, if used
; for this particular drive, or the value 0000H if no sector translation
; takes place (that is, the physical and logical sector numbers are the
; same). Disk drives with identical sector skew factors share the same
; translate tables.
;
; 0000	Scratch pad values for use within the BDOS, initial value is
; unimportant. DIRBUF Address of a 128-byte scratch pad area for directory
; operations within BDOS. All DPHs address the same scratch pad area.
;
; DPB	Address of a disk parameter block for this drive. Drives
; withidentical disk characteristics address the same disk parameter block.
;
; CSV	Address of a scratch pad area used for software check for
; changed disks. This address is different for each DPH.
;
; ALV	Address of a scratch pad area used by the BDOS to keep disk
; storage allocation information. This address is different for each DPH.
;
; Given n disk drives, the DPHs are arranged in a table whose first row of 16
; bytes corresponds to drive 0, with the last row corresponding to drive n-1.
; In the following figure the label DPBASE defines the base address of the
; DPH table.
;
; DPBASE:
; 00     XLT00 0000  0000  0000  DIRBUF  DBP00 CSV00  ALV00
; 01     XLT01 0000  0000  0000  DIRBUF  DBP01 CSV01  ALV01
;                     (and so on through)
; n-1    XLTn-1 0000  0000  0000 DIRBUF  DBPn-1 CSVn-1 ALVn-1

;
; The translation vectors, XLT00 through XLTn-1, are located elsewhere in the
; BIOS, and simply correspond one-for-one with the logical sector numbers
; zero through the sector count 1. The Disk Parameter Block (DPB) for each
; drive is more complex. As shown below, particular DPB, that is addressed by
; one or more DPHS, takes the general form:
;
;	+---+---+---+---+---+---+---+---+---+---+
;	|SPT|BSH|BLM|EXM|DSM|DRM|AL0|AL1|CKS|OFF|
;	+---+---+---+---+---+---+---+---+---+---+
;	 16B 8B  8B  8B  16B 16B 8B  8B  16B 16B
;
; where each is a byte or word value, as shown by the 8b or 16b indicator
; below the field.
;
; The following field abbreviations are used in the figure above:
;	SPT	is the total number of sectors per track.
;	BSH	is the data allocation block shift factor, determined by
;		the data block allocation size.
;	BLM	is the data allocation block mask (2[BSH-1]).
;	EXM	is the extent mask, determined by the data block
;		allocation size and the number of disk blocks.
;	DSM	determines the total storage capacity of the disk drive.
;	DRM	determines the total number of directory entries that
;		can be stored on this drive.
;	AL0, AL1	determine reserved directory blocks.
;	CKS	is the size of the directory check vector.
;
;	OFF	is the number of reserved tracks at the beginning of the
;		(logical) disk.
;
; The values of BSH and BLM determine the data allocation size BLS, which is
; not an entry in the DPB. Given that the designer has selected a value for
; BLS, the values of BSH and BLM are shown in the following table.
;
;	   BLS	BSH	BLM
;	 1,024	  3	  7
;	 2,048	  4	 15
;	 4,096	  5	 31
;	 8,192	  6	 63
;	16,384	  7	127
;
; where all values are in decimal. The value of EXM depends upon both the BLS
; and whether the DSM value is less than 256 or greater than 255, as shown in
; the table below.
;
;	EXM values
;	   BLS	DSM<256		DSM>255
;	 1,024	   0		N/A
;	 2,048	   1		0
;	 4,096	   3		1
;	 8,192	   7		3
;	16,384	  15		7
;
; The value of DSM is the maximum data block number supported by this
; particular drive, measured in BLS units. The product (DSM + 1) is the total
; number of bytes held by the drive and must be within the capacity of the
; physical disk, not counting the reserved operating system tracks.
;
; The DRM entry is the one less than the total number of directory entries
; that can take on a 16-bit value. The values of AL0 and AL1, however, are
; determined by DRM. The values AL0 and AL1 can together be considered a
; string of 16-bits, as shown below.
;
;      |--------- AL0 ---------|-------- AL1 ----------|
;       00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
;
; Position 00 corresponds to the high-order bit of the byte labeled AL0 and
; 15 corresponds to the low-order bit of the byte labeled AL1. Each bit
; position reserves a data block for number of directory entries, thus
; allowing a total of 16 data blocks to be assigned for directory entries
; (bits are assigned starting at 00 and filled to the right until position
; 15). Each directory entry occupies 32 bytes, resulting in the following
; tabulation:
;
;	   BLS		Directory Entries
;	 1,024		32 times # bits
;	 2,048		64 times # bits
;	 4,096		128 times # bits
;	 8,192		256 times # bits
;	16,384		512 times # bits
;
; Thus, if DRM = 127 (128 directory entries) and BLS = 1024, there are 32
; directory entries per block, requiring 4 reserved blocks. In this case, the
; 4 high-order bits of AL0 are set, resulting in the values AL0 = 0F0H and
; AL1 = 00H.
;
; The CKS value is determined as follows: if the disk drive media is
; removable, then CKS = (DRM + 1)/4, where DRM is the last directory entry
; number. If the media are fixed, then set CKS = 0 (no directory records are
; checked in this case).
;
; Finally, the OFF field determines the number of tracks that are skipped at
; the beginning of the physical disk. This value is automatically added
; whenever SETTRK is called and can be used as a mechanism for skipping
; reserved operating system tracks or for partitioning a large disk into
; smaller segmented sections.
;
; To complete the discussion of the DPB, several DPHs can address the same
; DPB if their drive characteristics are identical.  Further, the DPB can be
; dynamically changed when a new drive is addressed by simply changing the
; pointer in the DPH; because the BDOS copies the DPB values to a local area
; whenever the SELDSK function is invoked.
;
; Returning back to DPH for a particular drive, the two address values CSV
; and ALV remain. Both addresses reference an area of uninitialized memory
; following the BIOS. The areas must be unique for each drive, and the size
; of each area is determined by the values in the DPB.
;
; The size of the area addressed by CSV is CKS bytes, which is sufficient to
; hold the directory check information for this particular drive. If CKS =
; (DRM + 1)/4, you must reserve (DRM + 1)/4 bytes for directory check use. If
; CKS = 0, no storage is reserved.
;
; The size of the area addressed by ALV is determined by the maximum number
; of data blocks allowed for this particular disk and is computed as (DSM/8)
; + 1.

;
; diskette drives
;
dpbase	equ	$
	dw	atrans,0,0,0,dirbf,mits2,chk00,all00
	dw	atrans,0,0,0,dirbf,mits2,chk01,all01
	dw	atrans,0,0,0,dirbf,mits2,chk02,all02
	dw	atrans,0,0,0,dirbf,mits2,chk03,all03
	dw	atrans,0,0,0,dirbf,mits2,chk04,all04
	dw	atrans,0,0,0,dirbf,mits2,chk05,all05
	dw	atrans,0,0,0,dirbf,mits2,chk06,all06
	dw	atrans,0,0,0,dirbf,mits, chk07,all07

	if	nhdisks gt 0
defdw	macro	?value
	dw	all0&?value
	endm

defdp	macro	?number
	local	?hdi
?hdi	defl	8
	rept	?number
	dw	0,0,0,0,dirbf,simhd,0
	defdw	%?hdi
?hdi	defl	?hdi+1
	endm
	endm

	defdp	nhdisks

simhd:	dw	spt		; SPT, sectors per track
	db	5		; BSH, data allocation block shift factor, for BLS=4,096
	db	31		; BLM, data allocation block mask, for BLS=4,096
	db	1		; extent mask for BLS=4,096 and DSM>255
	dw	2047-restrk	; DSM, maximum data block number
	dw	1023		; DRM, number of directory entries - 1
	db	0ffh,0		; AL0, AL1, 8 blocks reserved to hold all entries
	; (number of directory entries)*32 = (number of reserved blocks)*(block size BLS)
				; 1024 * 32 = 8 * 4096
	dw	0		; CKS, set 0 since hard disk is fixed
	dw	restrk		; OFF, number of tracks skipped at beginning of disk
	db	0		; PSH
	db	0		; PHM
	endif

; copylib (default) format
mits:	dw	spt		; spt, sectors per track
	db	3		; allocation block shift factor, bsh
	db	7		; data allocation block mask, blm, allocation size (bls) = 1024
	db	0		; extent mask
	dw	dsm07		; dsm, maximum data block number
	dw	dirent		; drm, number of directory entries - 1
	db	0ffh,0		; al0, al1, 8 blocks reserved to hold all entries
				; 256 * 32 = 8 * 1024
				; (drm+1) * 32 = (number of bits in al0 and al1) * bls
	dw	cks		; cks = (drm + 1)/4
	dw	restrk		; off, number of tracks skipped at beginning of disk
	db	0		; PSH
	db	0		; PHM

mits2:	dw	spt		; spt, sectors per track
	db	4		; allocation block shift factor, bsh
	db	15		; data allocation block mask, blm, allocation size (bls) = 2048
	db	0		; extent mask
	dw	dsm06		; dsm, maximum data block number
	dw	dirent		; drm, number of directory entries - 1
	db	0f0h,0		; al0, al1, 4 blocks reserved to hold all entries
				; 256 * 32 = 4 * 2048
				; (drm+1) * 32 = (number of bits in al0 and al1) * bls
	dw	cks		; cks = (drm + 1)/4
	dw	restrk		; off, number of tracks skipped at beginning of disk
	db	0		; PSH
	db	0		; PHM

; speedball (copylib) skewtable
atrans:	db	01,18,03,20,05,22,07,24
	db	09,26,11,28,13,30,15,32
	db	17,02,19,04,21,06,23,08
	db	25,10,27,12,29,14,31,16

msg1:	db	cr, lf
	db	'0' + (msize/10)
	db	'0' + (msize MOD 10)
	db	'K Dougs CP/M Version 2.2 (SIMH ALTAIR 8800, BIOS V1.27, '

	if	nhdisks gt 0
	db	'0' + nhdisks
	db	' HD, '
	endif

	db	'02-May-2009)'
	db	cr, lf, '$'

	if	needZ80
msg2:	db	cr, lf, '8080 CPU detected. Need Z80.', cr, lf, '$'
	endif

secmsg:	db	cr, lf, 'Cannot find sector in register <B>', cr, lf, '$'

; position disk drive head
ontrk0:	db	track1		; current track# drive 0 (logical 1)
	db	track1		; current track# drive 1 (logical 2)
	db	track1		; current track# drive 2 (logical 3)
	db	track1		; current track# drive 3 (logical 4)
	db	track1		; current track# drive 4 (logical 5)
	db	track1		; current track# drive 5 (logical 6)
	db	track1		; current track# drive 6 (logical 7)
	db	track1		; current track# drive 7 (logical 8)

diskno:	db	0
sector:	db	0
track:	dw	0
dmaad:	dw	0

; begin scratch area for bdos
dirbf:	ds	128		; directory work space
all00:	ds	((dsm06+1)/8)+1
all01:	ds	((dsm06+1)/8)+1
all02:	ds	((dsm06+1)/8)+1
all03:	ds	((dsm06+1)/8)+1
all04:	ds	((dsm06+1)/8)+1
all05:	ds	((dsm06+1)/8)+1
all06:	ds	((dsm06+1)/8)+1
all07:	ds	((dsm07+1)/8)+1

	if	nhdisks gt 0

deflab	macro	?value
all0&?value	equ	$
	endm

defall	macro	?number
	local	?hdi
?hdi	defl	8
	rept	?number
	deflab	%?hdi
	ds	256
?hdi	defl	?hdi+1
	endm
	endm

	defall	nhdisks
	endif

chk00:	ds	cks
chk01:	ds	cks
chk02:	ds	cks
chk03:	ds	cks
chk04:	ds	cks
chk05:	ds	cks
chk06:	ds	cks
chk07:	ds	cks
altbuf:	ds	asecsiz+1

biosend	equ	$
biossiz	equ	biosend-bios

; fill remainder with 0

fillmod	equ	biossiz AND 00ffh
	if	fillmod gt 0
fillsiz	equ	100h-fillmod
	ds	fillsiz
	endif

    if2
padjust	macro	?newsiz
	.printx	/Adjust bioslen in MEMCFG.LIB to ?newsiz/
	endm

psize	macro	?val1,?val2,?val3,?val4
	.printx	/BIOS extends from ?val1 to ?val2 (Size ?val3, bioslen = ?val4)/
	endm

psave	macro	?value
	.printx	/SAVE ?value CPMBOOT.COM/
	endm

	.radix	16
	psize	%bios,%biosend,%biossiz,%bioslen
	if	biossiz gt bioslen
	padjust	%(100h*((biossiz + 0ffh) / 100h))
	endif
	.radix	10
	if	biosend gt 0ff00h
	.printx	/Warning: BIOS extends into Altair ROM/
	endif

    	psave	%(9+(ccplen + bdoslen + bioslen) / 100h)

	endif

	.dephase

	end
