<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (Win95; U) [Netscape]">
   <META NAME="Author" CONTENT="Thomas Anderson">
   <META NAME="KeyWords" CONTENT="Cross Assembler, Software Development, 6502, 8048, Z80, 8051, 8080">
   <TITLE>The Telemark Assembler (TASM) User Manual</TITLE>
<!--$Revision: 1.4 $-->
</HEAD>
<BODY>

<CENTER>
<H1>
<A NAME="Top"></A>The Telemark Assembler (TASM) User Manual</H1></CENTER>

<CENTER><FONT SIZE=+2>Version 3.2</FONT><BR>
<BR></CENTER>

<CENTER>Thomas N. Anderson</CENTER>

<CENTER>Squak Valley Software</CENTER>

<CENTER>837 Front Street South</CENTER>

<CENTER>Issaquah, WA 98027</CENTER>

<CENTER>email: andersontn@acm.org</CENTER>

<CENTER>www.halcyon.com/squakvly/<BR>
<BR></CENTER>

<CENTER><I>Copyright (C) 1985-2000 by Thomas N. Anderson. All rights reserved.</I></CENTER>

<HR>
<H1>
<A NAME="TABLE_OF_CONTENTS"></A>TABLE OF CONTENTS</H1>

<UL>
<LI>
<A HREF="#INTRODUCTION">INTRODUCTION</A></LI>

<LI>
<A HREF="#SHAREWARE">SHAREWARE</A></LI>

<LI>
<A HREF="#INVOCATION">INVOCATION</A></LI>

<LI>
<A HREF="#ENVIRONMENT_VARIABLES">ENVIRONMENT VARIABLES</A></LI>

<LI>
<A HREF="#EXIT_CODES">EXIT CODES</A></LI>

<LI>
<A HREF="#SOURCE_FILE_FORMAT">SOURCE FILE FORMAT</A></LI>

<LI>
<A HREF="#EXPRESSIONS">EXPRESSIONS</A></LI>

<LI>
<A HREF="#ASSEMBLER_DIRECTIVES">ASSEMBLER DIRECTIVES</A></LI>

<LI>
<A HREF="#OBJECT_FILE_FORMATS">OBJECT FILE FORMATS</A></LI>

<LI>
<A HREF="#LISTING_FILE_FORMAT">LISTING FILE FORMAT</A></LI>

<LI>
<A HREF="#PROM_PROGRAMMING">PROM PROGRAMMING</A></LI>

<LI>
<A HREF="#ERROR_MESSAGES">ERROR MESSAGES</A></LI>

<LI>
<A HREF="#LIMITATIONS">LIMITATIONS</A></LI>
</UL>

<HR>
<H1>
<A NAME="INTRODUCTION"></A>INTRODUCTION</H1>
The Telemark Assembler (TASM) is a table driven cross assembler for the
MS-DOS and LINUX environments. Assembly source code, written in the appropriate
dialect (generally very close to the manufacturers assembly language),
can be assembled with TASM, and the resulting object code transferred to
the target microprocessor system via PROM or other mechanisms.

<P>The microprocessor families supported by TASM are:
<UL>
<LI>
6502</LI>

<LI>
6800/6801/68HC11</LI>

<LI>
6805</LI>

<LI>
8048</LI>

<LI>
8051</LI>

<LI>
8080/8085, Z80</LI>

<LI>
TMS32010, TMS320C25</LI>

<LI>
TMS7000</LI>

<LI>
8096/80196</LI>
</UL>
The user so inclined may build tables for other microprocessors. The descriptions
of the various existing tables and instructions on building new tables
are not in this document but can be found in the TASMTABS.HTM file on the
TASM distribution disk.

<P>TASM characteristics include:
<OL>
<LI>
Powerful expression parsing (17 operators).</LI>

<LI>
Supports a subset of the 'C' preprocessor commands.</LI>

<LI>
Macro capability (through use of DEFINE directive).</LI>

<LI>
Multiple statements per line.</LI>

<LI>
Four object file formats: Intel hex, MOS Technology hex, Motorola hex,
binary.</LI>

<LI>
Absolute code generation only.</LI>

<LI>
Source code available (in C).</LI>

<LI>
Uniform syntax across versions for different target machines.</LI>

<LI>
Features in support of PROM programming (preset memory, contiguous block).</LI>

<LI>
Supports extended instructions for many of the supported microprocessor
families.</LI>

<LI>
Tables read at run time - single TASM executable for all table versions.</LI>

<LI>
Symbol table export for inclusion in subsequent assemblies.</LI>

<LI>
Symbol table export file for import with some simulator products.</LI>
</OL>

<HR>
<H1>
<A NAME="SHAREWARE"></A>SHAREWARE</H1>
TASM is distributed as shareware. TASM is not in the public domain. The
TASM distribution files may be freely copied (excluding the source code
files) and freely used for the purpose of evaluating the suitability of
TASM for a given purpose. Use of TASM beyond a reasonable evaluation period
requires registration. Prolonged use without registration is unethical.&nbsp;
<HR>
<H1>
<A NAME="INVOCATION"></A>INVOCATION</H1>
TASM can be invoked as follows (optional fields shown in brackets, symbolic
fields in italics):
<PRE>&nbsp; tasm -pn [-options ...] <I>src_file</I> [<I>obj_file</I> [<I>lst_file</I> [<I>exp_file</I> [<I>sym_file</I>]]]]</PRE>
Where <I>options</I> can be one or more of the following:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP>-<I>table</I>&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Specify version (<I>table</I> = table designation)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-t<I>table</I>&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Table (alternate form of above)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-a<I>amask</I>&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Assembly control (optional error checking)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-b&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Produce object in binary (.COM) format&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-c&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Object file written as a contiguous block&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-d<I>macro</I>&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Define a macro (or just a macro label)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-e&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Show source lines after macro expansion&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-f<I>fillbyte</I>&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Fill entire memory space with fillbyte (hex)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-g<I>objtype</I>&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Object file (0=Intel Hex, 1=MOS Tech, 2=Motorola,
3=binary,4=Intel Hex (Word))&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-h&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Produce hex table of the assembled code (in list
file)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-i&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Ignore case for labels&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-l[al]&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Produce a label table in the listing&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-m&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Produce object in MOS Technology format&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-o<I>obytes</I>&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Bytes per object record (for hex obj formats)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-p[<I>lines</I>]&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Page the listing file (lines per page. default=60)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-q&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Quiet, disable the listing file&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-s&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Write a symbol table file&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-x[<I>xmask</I>]&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Enable extended instruction set (if any)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>-y&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Time the assembly&nbsp;</TD>
</TR>
</TABLE>
<P>The filename parameters are defined as follows:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><I>src_file&nbsp;</I></TD>

<TD ALIGN=LEFT VALIGN=TOP>Source file name&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><I>obj_file&nbsp;</I></TD>

<TD ALIGN=LEFT VALIGN=TOP>Object code file name&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><I>lst_file&nbsp;</I></TD>

<TD ALIGN=LEFT VALIGN=TOP>Listing file name&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><I>exp_file&nbsp;</I></TD>

<TD ALIGN=LEFT VALIGN=TOP>Symbol export file (only if the EXPORT directive
is used).</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><I>sym_file&nbsp;</I></TD>

<TD ALIGN=LEFT VALIGN=TOP>Symbol table file (only if the <B>-s</B> option
or the SYM/AVSYM directives are used).&nbsp;</TD>
</TR>
</TABLE>
<P>The source file must be specified. If not, some usage information is displayed.
Default file names for all the other files are generated if they are not
explicitly provided. The filename is formed by taking the source filename
and changing the extension to one of the following:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><B>Extension&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>File type&nbsp;</B></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>.OBJ&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Object file&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>.LST&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Listing file&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>.EXP&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Symbol export file&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>.SYM&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Symbol table file&nbsp;</TD>
</TR>
</TABLE>
<P>TASM has no built-in instruction set tables. Instruction set definition
files are read at run time. TASM determines which table to use based on
the '-<I>table'</I> field shown above. For example, to assemble the code
in a file called <I>source.asm</I>, one would enter
<BR>&nbsp;
<TABLE>
<TR>
<TD ALIGN=LEFT><TT>tasm -48 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT>for an 8048 assembly&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT><TT>tasm -65 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT>for a 6502 assembly&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT><TT>tasm -51 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT>for an 8051 assembly.&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT><TT>tasm -85 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT>for an 8085 assembly.&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT><TT>tasm -80 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT>for a Z80 assembly.&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT><TT>tasm -05 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT>for a 6805 assembly.&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT><TT>tasm -68 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT>for a 6800/6801/68HC11 assembly.&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT><TT>tasm -70 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT>for a TMS7000 assembly.&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT><TT>tasm -3210 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT>for a TMS32010 assembly.&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><TT>tasm -3225 source.asm&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>for a TMS320C25 assembly.&nbsp;</TD>
</TR>

<TR>
<TD><TT>tasm -96 source.asm&nbsp;</TT></TD>

<TD>for a 8096/80196 assembly</TD>
</TR>
</TABLE>
<P>
Tables are read from a file named by taking the digits specified after
the '-' and appending it to 'TASM' then appending the '.TAB' extension.
Thus, the <B>-48</B> flag would cause the tables to be read from the file
'TASM48.TAB'.

<P>It is possible to designate tables by non numeric part numbers if the
<B>-t</B> flag is used. For example, if a user built a table called TASMF8.TAB
then TASM could be invoked as follows:
<PRE>&nbsp;&nbsp;&nbsp; tasm -tf8 source.asm</PRE>
Each option flag must be preceded by a dash. Options need not precede the
file names. The various options are described in the sections that follow.
<H2>
<A NAME="Assembly_Control"></A>a - Assembly Control</H2>
TASM can provide additional error checking by specifying the <I>-a</I>
option at the time of execution. If the <I>-a</I> is provided without a
digit following, then all the available error checking is done. If a digit
follows, then it is used as a mask to determine the error checks to be
made. The bits of the mask are defined as follows:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=CENTER VALIGN=TOP><B>Bit&nbsp;</B></TD>

<TD ALIGN=CENTER VALIGN=TOP><B>Option&nbsp;</B></TD>

<TD ALIGN=CENTER VALIGN=TOP><B>Default&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Description&nbsp;</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>0&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>-a1&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>OFF&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Check for apparent illegal use of indirection&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>1&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>-a2&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>ON&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Check for unused data in the arguments&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>2&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>-a4&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>ON&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Check for duplicate labels&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>3&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>-a8&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>OFF&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Check for non-unary operators at start of expression.&nbsp;</TD>
</TR>
</TABLE>
<P>Combinations of the above bits can also be used. For example, <I>-a5</I>
would enable the checking for illegal indirection and duplicate labels.

<P>Illegal indirection applies to micros that use parenthesis around an
argument to indicate indirection. Since it is always legal to put an extra
pair of parenthesis around any expression (as far as the expression parser
is concerned), the user may think that he/she is indicating indirection
for an instruction that has no indirection and TASM would not complain.
Enabling this checking will result in an error message (warning) whenever
an outer pair of parenthesis is used and the instruction set definition
table does not explicitly indicate that to be a valid form of addressing.

<P>Unused data in arguments applies to cases where a single byte of data
is needed from an argument, but the argument contains more than one byte
of data. If a full sixteen bit address is used in a 'Load Immediate' type
instruction that needs only a single byte, for example, an error message
would be generated. Here is an example (6502 code):
<PRE>&nbsp;&nbsp;&nbsp; 0001&nbsp;&nbsp; 1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .org $1234
&nbsp;&nbsp;&nbsp; test.asm line 0002: Unused data in MS byte of argument.
&nbsp;&nbsp;&nbsp; 0002&nbsp;&nbsp; 1234 A9 34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start&nbsp; lda&nbsp; #start</PRE>
To make the above checks occur whenever you do an assembly, add a line
like this to your AUTOEXEC.BAT file:
<PRE>&nbsp;&nbsp;&nbsp; SET TASMOPTS=-a</PRE>

<H2>
b - Binary Object Format</H2>
This option causes the object file to be written in binary - one byte for
each byte of code/data. Note that no address information is included in
the object file in this format. The contiguous block (-c) output mode is
forced when this option is invoked. This flag is equivalent to <I>-g3</I>.
<H2>
c - Contiguous Block Output</H2>
If this option is specified, then all bytes in the range from the lowest
used byte to the highest will be defined in the object file. Normally,
with the default Intel Hex object format enabled, if the Program Counter
(PC) jumps forward because of an .<A HREF="#ORG">ORG</A> directive, the
bytes skipped over will not have any value assigned them in the object
file. With this option enabled, no output to the object file occurs until
the end of the assembly at which time the whole block is written. This
is useful when using TASM to generate code that will be put into a PROM
so that all locations will have a known value. This option is often used
in conjunction with the -f option to ensure all unused bytes will have
a known value.
<H2>
d - Define a Macro</H2>
Macros are defined on the command line generally to control the assembly
of various IFDEF's that are in the source file. This is a convenient way
to generate various versions of object code from a single source file.
<H2>
e - Expand Source.</H2>
Normally TASM shows lines in the listing file just as they are in the source
file. If macros are in use (via the <A HREF="#DEFINE">DEFINE</A> directive)
it is sometimes desirable to see the source lines after expansion. Use
the '-e' flag to accomplish this.
<H2>
f - Fill Memory.</H2>
This option causes the memory image that TASM maintains to be initialized
to the value specified by the two hex characters immediately following
the 'f'. TASM maintains a memory image that is a full 64K bytes in size
(even if the target processor cannot utilize that memory space). Invocation
of this option introduces a delay at start up time.
<H2>
g - Object File Format.</H2>
TASM can generate object code in the formats indicated below:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD><B>Option&nbsp;</B></TD>

<TD><B>Description</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g0&nbsp;</TD>

<TD ALIGN=LEFT>Intel hex (default)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g1&nbsp;</TD>

<TD ALIGN=LEFT>MOS Technology hex (same as <B>-m</B>)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g2&nbsp;</TD>

<TD ALIGN=LEFT>Motorola hex&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g3&nbsp;</TD>

<TD ALIGN=LEFT>binary (same as <B>-b</B>)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g4&nbsp;</TD>

<TD ALIGN=LEFT>Intel hex with word addresses</TD>
</TR>
</TABLE>
<P>The <B>-m</B> and <B>-b</B> flags may also be used, as indicated above.
If both are used the right-most option on the command line will be obeyed.

<P>See the section on <B>OBJECT FILE FORMATS</B> for descriptions of each
of the above.
<H2>
h - Hex Object Code Table.</H2>
This option causes a hex table of the produced object code to appear in
the listing file. Each line of the table shows sixteen bytes of code.
<H2>
i - Ignore Case in Labels.</H2>
TASM is normally case sensitive when dealing with labels. For those that
prefer case insensitivity, the '-i' command line option can be employed.
<H2>
l - Label Table.</H2>
This option causes a label table to appear in the listing file. Each label
is shown with its corresponding value. Macro labels (as established via
the DEFINE directives) do not appear.

<P>Two optional suffixes may follow the <B>-l</B> option:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><B>Suffix&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Description&nbsp;</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>l&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Use long form listing&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>a&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Show all labels (including local labels)&nbsp;</TD>
</TR>
</TABLE>
<P>The suffix should immediately follow the '-l'. Here are some examples:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><TT>-l&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>to show non-local labels in the short form&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><TT>-la&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>to show all labels in the short form&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><TT>-ll&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>to show non-local labels in the long form&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><TT>-lal&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>to show all labels in the long form&nbsp;</TD>
</TR>
</TABLE>

<H2>
m - MOS Technology Object Format.</H2>
This option causes the object file to be written in MOS Technology hex
format rather than the default Intel hex format. See section on <A HREF="#OBJECT_FILE_FORMATS">OBJECT
FILE FORMATS</A> for a description of the format.
<H2>
o - Set Number of Bytes per Object Record.</H2>
When generating object code in either the MOS Technology format or the
Intel hex format, a default of 24 (decimal) bytes of object are defined
on each record. This can be altered by invoking the '-o' option immediately
followed by two hex digits defining the number of bytes per record desired.
For example, if 32 bytes per record are desired, one might invoke TASM
as:
<PRE>&nbsp;&nbsp;&nbsp; tasm -48 -o20 source.asm</PRE>

<H2>
p - Page Listing File.</H2>
This option causes the listing file to have top of page headers and form
feeds inserted at appropriate intervals (every sixty lines of output).
To override the default of sixty lines per page, indicate the desired number
of lines per page as a decimal number immediately following the '-p'. Here
is an example:
<PRE>&nbsp;&nbsp;&nbsp; tasm -48 -p56 source.asm</PRE>

<H2>
q - Disable Listing File.</H2>
This option causes all output to the listing file to be suppressed, unless
a .LIST directive is encountered in the source file (see <A HREF="#LIST">LIST/NOLIST</A>
directives).
<H2>
s - Enable Symbol File Generation.</H2>
If this flag is set, a symbol file is generated at the end of the assembly.
The format of the file is one line per label, each label starts in the
first column and is followed by white space and then four hexadecimal digits
representing the value of the label. The following illustrates the format:
<PRE>&nbsp;&nbsp;&nbsp; label1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFFE
&nbsp;&nbsp;&nbsp; label2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFFF
&nbsp;&nbsp;&nbsp; label3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1000</PRE>
The symbol file name can be provided as the fifth file name on the command
line, or the name will be generated from the source file name with a '.SYM'
extension. The symbol table file can also be generated by invoking the
SYM directive. The AVSYM directive also generates the symbol file but in
a different format (see section on <A HREF="#ASSEMBLER_DIRECTIVES">ASSEMBLER
DIRECTIVES</A>).
<H2>
t - Table Name.</H2>
As an alternative to specifying the instruction set table as two decimal
digits, the table indication may be proceeded by the '-t' option. This
is useful if the desired table name starts with a non-numeric. Thus, a
table for an F8 might be selected as:
<PRE>&nbsp;&nbsp;&nbsp; tasm -tf8 source.asm</PRE>
TASM would expect to read the instruction set definition tables from a
file named TASMF8.TAB.
<H2>
x - Enable Extended Instruction Set.</H2>
If a processor family has instructions that are valid for only certain
members, this option can be used to enable those beyond the basic standard
instruction set. A hex digit may follow the 'x' to indicate a mask value
used in selecting the appropriate instruction set. Bit 0 of the mask selects
the basic instruction set, thus a '-x1' would have no effect. A '-x3' would
enable the basic set plus whatever instructions have bit 1 set in their
class mask. A '-x' without a digit following is equivalent to a '-xf' which
sets all four of the mask bits. The following table indicates the current
extended instruction sets available in the TASM tables:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><B>Base Table&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Base Family&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Ext 1 (-x3)&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Ext 2 (-x7)&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Ext 3 (-x5)&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Ext 4 (-x9)&nbsp;</B></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>48&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>8048&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>8041A&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>8022&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>8021&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>65&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>6502&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>R65C02&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>R65C00/21&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>05&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>6805&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>M146805 CMOS&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>HC05C4&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>80&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Z80&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>HD64180&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>68&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>6800&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>6801/6803&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>68HC11&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>51&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>8051&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>85&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>8080&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>3210&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>TMS32010&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>3225&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>TMS320C25&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>TMS320C26&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>70&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>TMS7000&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>
</TABLE>
&nbsp;
<BR>&nbsp;

<P>The above table does not attempt to show the many microprocessor family
members that may apply under a given column.

<P>See the TASMTABS.HTM on-line document for details on each specific table.
<H2>
y - Enable Assembly Timing</H2>
If this option is enabled TASM will generate a statement of elapsed time
and assembled lines per second at the end of the assembly.
<H1>

<HR WIDTH="100%"><A NAME="ENVIRONMENT_VARIABLES"></A>ENVIRONMENT VARIABLES</H1>
The TASM environment can be customized by using the environment variables
listed below:
<H2>
<A NAME="TASMTABS"></A>TASMTABS</H2>
The TASMTABS variable specifies the path to be searched for TASM instruction
set definition tables. If it is not defined then the table(s) must exist
in the current working directory. The following examples illustrate possible
usage:
<BR>&nbsp;
<TABLE>
<TR>
<TD>For MSDOS&nbsp;</TD>

<TD><TT>set TASMTABS=C:\TASM</TT></TD>
</TR>

<TR>
<TD>For LINUX&nbsp;</TD>

<TD><TT>TASMTABS=/tasm</TT></TD>
</TR>
</TABLE>

<H2>
<A NAME="TASMOPTS"></A>TASMOPTS</H2>
This variable specifies TASM command line options that are to be invoked
every time TASM is executed. For example, if TASM is being used for 8048
assemblies with binary object file output desired, the following statement
would be appropriate in the AUTOEXEC.BAT file:
<PRE>&nbsp;&nbsp;&nbsp; set TASMOPTS=-48 -b</PRE>

<H2>
<A NAME="TASMERRFORMAT"></A>TASMERRFORMAT</H2>
The TASMERRFORMAT variable provides user control of the format of error
messages.&nbsp; The format string must be a valid printf format string
for ANSI C.&nbsp; The default value is:
<UL>
<PRE>"%s line %04d: %s %s"</PRE>
</UL>
Which provides error messages like this:
<UL>
<PRE>Main.asm line 1234: No such label: Start</PRE>
</UL>
The four fields associated with an error message are:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD><B>Field Description</B></TD>

<TD><B>Associated Data Type (ANSI C)</B></TD>
</TR>

<TR>
<TD>File name</TD>

<TD>char *</TD>
</TR>

<TR>
<TD>Line number within file</TD>

<TD>int</TD>
</TR>

<TR>
<TD>Error description</TD>

<TD>char *</TD>
</TR>

<TR>
<TD>Error data (optional)</TD>

<TD>char *</TD>
</TR>
</TABLE>


<P>No user control of the order of the error message fields is provided.
<BR>Here are sample usages:

<P>For MSDOS:
<UL>
<PRE>set TASMERRFORMAT=”%s(%d) %s %s”</PRE>
</UL>
For LINUX:
<UL>
<PRE>TASMERRFORMAT=”%s(%d) %s %s”</PRE>
</UL>

<HR>
<H1>
<A NAME="EXIT_CODES"></A>EXIT CODES</H1>
When TASM terminates, it will return to the OS the following exit codes:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><B>Exit Code&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Definition</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>0&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Normal completion, no assembly errors&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>1&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Normal completion, with assembly errors&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>2&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Abnormal completion, insufficient memory&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>3&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Abnormal completion, file access error&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>4&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Abnormal completion, general error&nbsp;</TD>
</TR>
</TABLE>
<P>Exit codes 2 and above will also be accompanied by messages to the console
concerning the error.
<BR>
<HR>
<H1>
<A NAME="SOURCE_FILE_FORMAT"></A>SOURCE FILE FORMAT</H1>
Statements in the source file must conform to a format as follows (except
for assembler directive statements which are described in a subsequent
section):
<BR>&nbsp;
<UL><I>label operation operand comment</I></UL>
All of the fields are optional, under appropriate circumstances. An arbitrary
amount of white space (space and tabs) can separate each field (as long
as the maximum line length of 255 characters is not exceeded). Each of
the fields are described in the following sections.
<H2>
Label Field.</H2>
If the first character of the line is alphabetic, it is assumed to be the
start of a label. Subsequent characters are accepted as part of that label
until a space, tab, or ':' is encountered. The assembler assigns a value
to the label corresponding to the current location counter. Labels can
be a maximum of 32 characters long. Labels can contain upper and lower
case letters, digits, underscores, and periods (the first character must
be alphabetic). Labels are case sensitive - the label 'START' is a different
label from 'start' - unless the '-i' (ignore case) option is enabled.
<H2>
Operation Field.</H2>
The operation field contains an instruction mnemonic which specifies the
action to be carried out by the target processor when this instruction
is executed. The interpretation of each mnemonic is dependent on the target
microprocessor (as indicated by the selected TASM table). The operation
field may begin in any column except the first. The operation field is
case insensitive.
<H2>
Operand Field.</H2>
The operand field specifies the data to be operated on by the instruction.
It may include expressions and/or special symbols describing the addressing
mode to be used. The actual format and interpretation is dependent on the
target processor. For a description of the format for currently supported
processors, see the TASMTABS.DOC file on the TASM distribution disk.
<H2>
Comment Field.</H2>
The comment field always begins with a semicolon. The rest of the line
from the semicolon to the end of the line is ignored by TASM, but passed
on to the listing file for annotation purposes. The comment field must
be the last field on a line, but it may be the only field, starting in
column one, if desired.
<H2>
Multiple Statement Lines.</H2>
If the backslash character is encountered on a source line, it is treated
as a newline. The remainder of the line following the backslash will be
processed as an independent line of source code. This allows one to put
multiple statements on a line. This facility is not so useful of itself,
but when coupled with the capability of the DEFINE directive, powerful
multiple statement macros can be constructed (see section on <B><A HREF="#ASSEMBLER_DIRECTIVES">ASSEMBLER
DIRECTIVES</A></B>). Note that when using the statement separator, the
character immediately following it should be considered the first character
of a new line, and thus must either be a start of a label or white space
(not an instruction). As the examples show, a space is put between the
backslash and the start of the next instruction.
<H2>
Sample Source Listing.</H2>
Some examples of valid source statements follow (6502 mnemonics shown):
<PRE>&nbsp; lab1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda&nbsp;&nbsp;&nbsp; byte1&nbsp;&nbsp; ;get the first byte
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec&nbsp;&nbsp;&nbsp; byte1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne&nbsp;&nbsp;&nbsp; label1
&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; lab2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sta&nbsp;&nbsp;&nbsp; byte2,X
&nbsp; ;&nbsp; a multiple statement line follows
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda&nbsp;&nbsp;&nbsp; byte1\ sta byte1+4\ lda byte2\ sta byte2+4</PRE>

<HR>
<H1>
<A NAME="EXPRESSIONS"></A>EXPRESSIONS</H1>
Expressions are made up of various syntactic elements combined according
to a set of syntactical rules. Expressions can be comprised of the following
elements:
<UL>
<LI>
Labels</LI>

<LI>
Constants</LI>

<LI>
Location Counter Symbol</LI>

<LI>
Operators</LI>

<LI>
Parenthesis</LI>
</UL>

<H2>
<A NAME="Labels"></A>Labels</H2>
Labels are strings of characters that have a numeric value associated with
them, generally representing an address. Labels can contain upper and lower
case letters, digits, underscores, and periods. The first character must
be a letter or the local label prefix (default '_'). The value of a label
is limited to 32 bit precision. Labels can contain up to 32 characters,
all of which are significant (none are ignored when looking at a label's
value, as in some assemblers). Case is significant unless the '-i' command
line option is invoked.

<P>Local labels must only be unique within the scope of the current module.
Modules are defined with the <A HREF="#MODULE">MODULE</A> directive. Here
is an example:
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .MODULE xxx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda regx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne _skip
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec
&nbsp;&nbsp; _skip&nbsp; rts
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .MODULE yyy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda regy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne _skip
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec
&nbsp;&nbsp; _skip&nbsp; rts</PRE>
In the above example, the<I> _skip</I> label is reused without harm. As
a default, local labels are not shown in the label table listing (resulting
from the '-l' command line option). See also sections on <A HREF="#MODULE">MODULE</A>
and <A HREF="#LOCALLABELCHAR">LOCALLABELCHAR</A> directives.
<H2>
Numeric Constants</H2>
Numeric constants must always begin with a decimal digit (thus hexadecimal
constants that start with a letter must be prefixed by a '0' unless the
'$' prefix is used). The radix is determined by a letter immediately following
the digit string according to the following table:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><B>Radix&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Suffix&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Prefix&nbsp;</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>2&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>B or b&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>%&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>8&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>O or o&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>@&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>10&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>D or d (or nothing)&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>16&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>H or h&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>$&nbsp;</TD>
</TR>
</TABLE>

<P>Decimal is the default radix, so decimal constants need no suffix or prefix.

<P>The following representations are equivalent:
<PRE>&nbsp;&nbsp;&nbsp; 1234H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp; $1234
&nbsp;&nbsp;&nbsp; 100d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp; 100
&nbsp;&nbsp;&nbsp; 177400o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp; @177400
&nbsp;&nbsp;&nbsp; 01011000b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp; %01011000</PRE>
The prefixes are provided for compatibility with some other source code
formats but introduce a problem of ambiguity. Both '%' and '$' have alternate
uses ('%' for modulo, '$' for location counter symbol). The ambiguity is
resolved by examining the context. The '%' character is interpreted as
the modulo operator only if it is in a position suitable for a binary operator.
Similarly, if the first character following a '$' is a valid hexadecimal
digit, it is assumed to be a radix specifier and not the location counter.
<H2>
Character Constants</H2>
Character constants are single characters surrounded by single quotes.
The ASCII value of the character in the quotes is returned. No escape provision
exists to represent non-printable characters within the quotes, but this
is not necessary since these can be just as easily represented as numeric
constants (or using the <A HREF="#TEXT">TEXT</A> directive which does allow
escapes).
<H2>
String Constants.</H2>
String constants are one or more characters surrounded by double quotes.
Note that string constants are not allowed in expressions. They are only
allowable following the <A HREF="#TITLE">TITLE</A>, <A HREF="#BYTE">BYTE</A>,
<A HREF="#DB">DB</A>, and <A HREF="#TEXT">TEXT</A> assembler directives.
The quoted strings may also contain escape sequences to put in unprintable
values. The following escape sequences are supported:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><B>Escape Sequence&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Description</B>&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>\n&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Line Feed&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>\r&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Carriage return&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>\b&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Backspace&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>\t&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Tab&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>\f&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Formfeed&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>\\&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Backslash&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>\"&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Quote&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>\000&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Octal value of character&nbsp;</TD>
</TR>
</TABLE>

<H2>
Location Counter Symbol</H2>
The current value of the location counter (PC) can be used in expressions
by placing a '$' in the desired place. The Location Counter Symbol is allowable
anywhere a numeric constant is. (Note that if the '$' is followed by a
decimal digit then it is taken to be the hexadecimal radix indicator instead
of the Location Counter symbol, as mentioned above). The '*' may also be
used to represent the location counter, but is less preferred because of
its ambiguity with the multiplicative operator.
<H2>
Operators</H2>
Expressions can optionally contain operators to perform some alterations
or calculations on particular values. The operators are summarized as follows:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=CENTER VALIGN=TOP><B>Operator&nbsp;</B></TD>

<TD ALIGN=CENTER VALIGN=TOP><B>Type&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Description&nbsp;</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>+&nbsp;</TD>

<TD ALIGN=CENTER VALIGN=TOP>Additive&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>addition&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>-&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>subtraction&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>*&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Multiplicative&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>multiplication&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>/&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>division&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>%&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>modulo&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>&lt;&lt;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>logical shift left&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>>>&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>logical shift right&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>~&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Unary&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>bit inversion (one's complement)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>-&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>unary negation&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>=&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Relational&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>equal&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>==&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>equal&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>!=&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>not equal&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>&lt;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>less than&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>></TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>greater than&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>&lt;=&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>less than or equal&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>>=&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>greater than or equal&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>&amp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Binary&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>binary 'and'&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>|&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>binary 'or'&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>^&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP></TD>

<TD ALIGN=LEFT VALIGN=TOP>binary 'exclusive or'&nbsp;</TD>
</TR>
</TABLE>

<P>The syntax is much the same as in ANSI C with the following notes:

<OL>
<LI>
No operator precedence is in effect. Evaluation is from left to right unless
grouped by parenthesis (see example below).</LI>

<LI>
All evaluations are done with 32 bit signed precision.</LI>

<LI>
Both '=' and '==' are allowable equality checkers. This is allowed since
the syntax does not provide assignment capability (as '=' would normally
imply).</LI>
</OL>
The relational operators return a value of 1 if the relation is true and
0 if it is false. Thirty-two bit signed arithmetic is used.

<P>It is always a good idea to explicitly indicate the desired order of
evaluation with parenthesis, especially to maintain portability since TASM
does not evaluate expressions in the same manner as many other assemblers.
To understand how it does arrive at the values for expressions, consider
the following example:
<PRE>&nbsp;&nbsp;&nbsp; 1 + 2*3 + 4</PRE>
TASM would evaluate this as:
<PRE>&nbsp;&nbsp;&nbsp; (((1 + 2) * 3) + 4) = 13</PRE>
Typical rules of precedence would cause the (2*3) to be evaluated first,
such as:
<PRE>&nbsp;&nbsp;&nbsp; 1 + (2*3) + 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 11</PRE>
To make sure you get the desired order of evaluation, use parenthesis liberally.
Here are some examples of valid expressions:
<PRE>&nbsp;&nbsp;&nbsp; (0f800H + tab)
&nbsp;&nbsp;&nbsp; (label_2 >> 8)
&nbsp;&nbsp;&nbsp; (label_3 &lt;&lt; 8) &amp; $f000
&nbsp;&nbsp;&nbsp; $ + 4
&nbsp;&nbsp;&nbsp; 010010000100100b + 'a'
&nbsp;&nbsp;&nbsp; (base + ((label_4 >> 5) &amp; (mask &lt;&lt; 2))</PRE>

<HR>
<H1>
<A NAME="ASSEMBLER_DIRECTIVES"></A>ASSEMBLER DIRECTIVES</H1>
Most of the assembler directives have a format similar to the machine instruction
format. However, instead of specifying operations for the processor to
carry out, the directives cause the assembler to perform some function
related to the assembly process. TASM has two types of assembler directives
- those that mimic the 'C' preprocessor functions, and those that resemble
the more traditional assembler directive functions. Each of these will
be discussed.

<P>The ANSI C preprocessor style directives are invoked with a '#' as the
first character of the line followed by the appropriate directive (just
as in 'C'). Thus, these directives cannot have a label preceding them (on
the same line). Note that in the examples directives are shown in upper
case, however, either upper or lower case is acceptable.
<H2>
<A NAME="ADDINSTR"></A>ADDINSTR</H2>
The ADDINSTR directive can be used to define additional instructions for
TASM to use in this assembly. The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>] .ADDINSTR <I>inst args opcode nbytes rule class shift binor</I></PRE>
The fields are separated by white space just as they would appear in an
instruction definition file. See the TASMTABS.HTM file on the TASM distribution
disk for more detail.
<H2>
<A NAME="AVSYM"></A>AVSYM</H2>
See SYM/AVSYM.
<H2>
<A NAME="BLOCK"></A>BLOCK</H2>
The BLOCK directive causes the Instruction Pointer to advance the specified
number of bytes without assigning values to the skipped over locations.
The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>] .BLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>expr</I></PRE>
Some valid examples are:
<PRE>&nbsp;&nbsp;&nbsp; word1&nbsp;&nbsp; .BLOCK&nbsp;&nbsp;&nbsp;&nbsp; 2
&nbsp;&nbsp;&nbsp; byte1&nbsp;&nbsp; .block&nbsp;&nbsp;&nbsp;&nbsp; 1
&nbsp;&nbsp;&nbsp; buffer&nbsp; .block&nbsp;&nbsp;&nbsp;&nbsp; 80</PRE>

<H2>
<A NAME="BSEG"></A>BSEG/CSEG/DSEG/NSEG/XSEG</H2>
These directives can be invoked to indicate the appropriate address space
for symbols and labels defined in the subsequent code. The invocation of
these directives in no way affects the code generated, only provides more
information in the symbol table file if the AVSYM directive is employed.
Segment control directives such as these are generally supported by assemblers
that generate relocatable object code. TASM does not generate relocatable
object code and does not support a link phase, so these directives have
no direct effect on the resulting object code. The segments are defined
as follows:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=CENTER VALIGN=TOP><B>Directive&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Segment Description&nbsp;</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>BSEG&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Bit address&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>CSEG&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Code address&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>DSEG&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Data address (internal RAM)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>NSEG&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>Number or constant (EQU)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP>XSEG&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>External data address (external RAM)&nbsp;</TD>
</TR>
</TABLE>

<H2>
<A NAME="BYTE"></A>BYTE</H2>
The BYTE directive allows a value assignment to the byte pointed to by
the current Instruction Pointer. The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>] .BYTE&nbsp;&nbsp; <I>expr</I> [, <I>expr</I> ...]</PRE>
Only the lower eight bits of <I>expr</I> are used. Multiple bytes may be
assigned by separating them with commas or (for printable strings) enclosed
in double quotes. Here are some examples:
<PRE>&nbsp;&nbsp;&nbsp; label1&nbsp;&nbsp; .BYTE&nbsp;&nbsp;&nbsp;&nbsp; 10010110B
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .byte&nbsp;&nbsp;&nbsp;&nbsp; 'a'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .byte&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .byte&nbsp;&nbsp;&nbsp;&nbsp; 100010110b,'a',0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .byte&nbsp;&nbsp;&nbsp;&nbsp; "Hello", 10, 13, "World"</PRE>

<H2>
<A NAME="CHK"></A>CHK</H2>
The CHK directive causes a checksum to be computed and deposited at the
current location. The starting point of the checksum calculation is indicated
as an argument. Here is the format:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>]&nbsp;&nbsp;&nbsp; .CHK&nbsp;&nbsp;&nbsp; <I>starting_addr</I></PRE>
Here is an example:
<PRE>&nbsp;&nbsp;&nbsp; start: NOP
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LDA #1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .CHK start</PRE>
The checksum is calculated as the simple arithmetic sum of all bytes starting
at the <I>starting_addr</I> up to but not including the address of the
<A HREF="#CHK">CHK</A> directive. The least significant byte is all that
is used.
<H2>
<A NAME="CODES"></A>CODES/NOCODES</H2>
The CODES/NOCODES directives can be used to alternately turn on or off
the generation of formatted listing output with line numbers, opcodes,
data, etc. With NOCODES in effect, the source lines are sent to the listing
file untouched. This is useful around blocks of comments that need a full
80 columns of width for clarity.
<H2>
<A NAME="DB"></A>DB</H2>
This is alternate form of the <A HREF="#BYTE">BYTE</A> directive.
<H2>
<A NAME="DW"></A>DW</H2>
This is alternate form of the <A HREF="#WORD">WORD</A> directive.
<H2>
<A NAME="DEFINE"></A>DEFINE</H2>
The DEFINE directive is one of the most powerful of the directives and
allows string substitution with optional arguments (macros). The format
is as follows:
<PRE>&nbsp;&nbsp;&nbsp; #DEFINE&nbsp; <I>macro_label</I>[(<I>arg_list</I>)]&nbsp; [<I>macro_definition</I>]</PRE>
Where:
<DL>
<DT>
<I>macro_label</I></DT>

<DD>
character string to be expanded when found in the source file</DD>

<DT>
<I>arg_list</I></DT>

<DD>
optional argument list for variable substitution in macro expansion</DD>

<DT>
<I>macro_def</I></DT>

<DD>
string to replace the occurrences of <I>macro_label</I> in the source file.</DD>
</DL>
The simplest form of the DEFINE directive might look like this:
<PRE>&nbsp;&nbsp;&nbsp; #DEFINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MLABEL</PRE>
Notice that no substitutionary string is specified. The purpose of a statement
like this would typically be to define a label for the purpose of controlling
some subsequent conditional assembly (<A HREF="#IFDEF">IFDEF</A> or <A HREF="#IFNDEF">IFNDEF</A>).

<P>A more complicated example, performing simple substitution, might look
like this:
<PRE>&nbsp;&nbsp;&nbsp; #DEFINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VAR1_LO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (VAR1 &amp; 255)</PRE>
This statement would cause all occurrences of the string 'VAR1_LO' in the
source to be substituted with '(VAR1 &amp; 255)'.

<P>As a more complicated example, using the argument expansion capability,
consider this:
<PRE>&nbsp;&nbsp;&nbsp; #DEFINE&nbsp; ADD(xx,yy)&nbsp;&nbsp;&nbsp; clc\ lda xx\ adc yy\ sta xx</PRE>
If the source file then contained a line like this:
<PRE>&nbsp;&nbsp;&nbsp; ADD(VARX,VARY)</PRE>
It would be expanded to:
<PRE>&nbsp;&nbsp;&nbsp; clc\ lda VARX\ adc VARY\ sta VARX</PRE>
The above example shows the use of the backslash ('\') character as a multiple
instruction statement delimiter. This approach allows the definition of
fairly powerful, multiple statement macros. The example shown generates
6502 instructions to add one memory location to another.

<P>Some rules associated with the argument list:
<OL>
<LI>
Use a maximum of 10 arguments.</LI>

<LI>
Each argument should be a maximum of 15 characters.</LI>
</OL>
Note that macros can be defined on the TASM command line, also, with the
<B>-d</B> option flag.
<H2>
<A NAME="DEFCONT"></A>DEFCONT</H2>
The DEFCONT directive can be used to add to the last macro started with
a <A HREF="#DEFINE">DEFINE</A> directive. This provides a convenient way
to define long macros without running off the edge of the page. The ADD
macro shown above could be defined as follows:
<PRE>&nbsp;&nbsp;&nbsp; #DEFINE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ADD(xx,yy)&nbsp;&nbsp;&nbsp;&nbsp; clc
&nbsp;&nbsp;&nbsp; #DEFCONT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ lda xx
&nbsp;&nbsp;&nbsp; #DEFCONT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ adc yy
&nbsp;&nbsp;&nbsp; #DEFCONT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ sta xx</PRE>

<H2>
<A NAME="ECHO"></A>ECHO</H2>
The ECHO directive can be used to send output to the console (stderr).
It can accept either a quoted text string (with the standard escape sequences
allowed) or a valid expression. It can accept only one or the other, however.
Multiple instances of the directive may be used to create output that contains
both. Consider the following example:
<PRE>&nbsp;&nbsp;&nbsp; .ECHO "The size of the table is "
&nbsp;&nbsp;&nbsp; .ECHO (table_end - table_start)
&nbsp;&nbsp;&nbsp; .ECHO " bytes long.\n"</PRE>
This would result in a single line of output something like this:
<PRE>&nbsp;&nbsp;&nbsp; The size of the table is 196 bytes long.</PRE>

<H2>
<A NAME="EJECT"></A>EJECT</H2>
The EJECT directive can be used to force a top-of-form and the generation
of a page header on the list file. It has no effect if the paging mode
is off (see PAGE/NOPAGE). The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>]&nbsp;&nbsp;&nbsp; .EJECT</PRE>

<H2>
<A NAME="ELSE"></A>ELSE</H2>
The ELSE directive can optionally be used with IFDEF, IFNDEF and IF to
delineate an alternate block of code to be assembled if the block immediately
following the IFDEF, IFNDEF or IF is not assembled.

<P>Here are some examples of the use of IFDEF, IFNDEF, IF, ELSE, and ENDIF:
<PRE>&nbsp;&nbsp;&nbsp; #IFDEF&nbsp;&nbsp; label1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte2
&nbsp;&nbsp;&nbsp; #ENDIF&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; #ifdef&nbsp;&nbsp; label1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte1
&nbsp;&nbsp;&nbsp; #else&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte2
&nbsp;&nbsp;&nbsp; #endif&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; #ifndef&nbsp; label1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte2
&nbsp;&nbsp;&nbsp; #else&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte1
&nbsp;&nbsp;&nbsp; #endif&nbsp;&nbsp;&nbsp;

&nbsp;&nbsp;&nbsp; #if ($ >= 1000h)
&nbsp;&nbsp;&nbsp; ; generate an invalid statement to cause an error
&nbsp;&nbsp;&nbsp; ;&nbsp; when we go over the 4K boundary.
&nbsp;&nbsp;&nbsp; !!! PROM bounds exceeded.
&nbsp;&nbsp;&nbsp; #endif</PRE>

<H2>
<A NAME="END"></A>END</H2>
The END directive should follow all code/data generating statements in
the source file. It forces the last record to be written to the object
file. The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .END [<I>addr</I>]</PRE>
The optional <I>addr</I> will appear in the last object record (Motorola
S9 record type) if the object format is Motorola hex. The <I>addr</I> field
is ignored for all other object formats.
<H2>
<A NAME="ENDIF"></A>ENDIF</H2>
The ENDIF directive must always follow an IFDEF, IFNDEF, or IF directive
and signifies the end of the conditional block.
<H2>
<A NAME="EQU"></A>EQU</H2>
The EQU directive can be used to assign values to labels. The labels can
then be used in expressions in place of the literal constant. The format
is:
<PRE>&nbsp;&nbsp;&nbsp; <I>label</I>&nbsp;&nbsp; .EQU&nbsp;&nbsp; <I>expr</I></PRE>
Here is an example:
<PRE>&nbsp;&nbsp;&nbsp; MASK&nbsp;&nbsp; .EQU&nbsp; 0F0H
&nbsp;&nbsp;&nbsp; ;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda&nbsp;&nbsp; IN_BYTE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp; MASK
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sta&nbsp;&nbsp; OUT_BYTE</PRE>
An alternate form of the EQU directive is '='. The previous example is
equivalent to any of the following:
<PRE>&nbsp;&nbsp;&nbsp; MASK&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp; 0F0H
&nbsp;&nbsp;&nbsp; MASK&nbsp;&nbsp;&nbsp; =0F0H
&nbsp;&nbsp;&nbsp; MASK&nbsp;&nbsp;&nbsp; =$F0</PRE>
White space must exist after the <I>label</I>, but none is required after
the '='.
<H2>
<A NAME="EXPORT"></A>EXPORT</H2>
The EXPORT directive can be used to define labels (symbols) that are to
be written to the export symbol file. The symbols are written as equates
(using the .EQU directive) so that the resulting file can be included in
a subsequent assembly. This feature can help overcome some of the deficiencies
of TASM due to its lack of a relocating linker. The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>]&nbsp; .EXPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>label</I> [,<I>label</I>...]</PRE>
The following example illustrates the use of the EXPORT directive and the
format of the resulting export file:

<P>Source file:
<PRE>&nbsp;&nbsp;&nbsp; EXPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read_byte
&nbsp;&nbsp;&nbsp; EXPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write_byte, open_file</PRE>
Resulting export file:
<PRE>&nbsp;&nbsp;&nbsp; read_byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .EQU&nbsp;&nbsp; $1243
&nbsp;&nbsp;&nbsp; write_byte&nbsp;&nbsp;&nbsp;&nbsp; .EQU&nbsp;&nbsp; $12AF
&nbsp;&nbsp;&nbsp; open_file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .EQU&nbsp;&nbsp; $1301</PRE>

<H2>
<A NAME="FILL"></A>FILL</H2>
The FILL directive can be used to fill a selected number of object bytes
with a fixed value. Object memory is filled from the current program counter
forward. The format is as follows:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>]&nbsp; .FILL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>number_of_bytes</I> [,<I>fill_value</I>]</PRE>
The <I>number_of_bytes</I> value can be provided as any valid expression.
The optional fill_value can also be any valid expression. If <I>fill_value</I>
is not provided, a default value of 255 ($FF) is used.
<H2>
<A NAME="IFDEF"></A>IFDEF</H2>
The IFDEF directive can be used to optionally assemble a block of code.
It has the following form:
<PRE>&nbsp;&nbsp;&nbsp; #IFDEF&nbsp; macro_label</PRE>
When invoked, the list of macro labels (established via <A HREF="#DEFINE">DEFINE</A>
directives) is searched. If the label is found, the following lines of
code are assembled. If not found, the input file is skipped until an ENDIF
or ELSE directive is found.

<P>Lines that are skipped over still appear in the listing file, but a
'~' will appear immediately after the current PC and no object code will
be generated (this is applicable to IFDEF, IFNDEF, and IF).
<H2>
<A NAME="IFNDEF"></A>IFNDEF</H2>
The IFNDEF directive is the opposite of the IFDEF directive. The block
of code following is assembled only if the specified <I>macro_label</I>
is undefined. It has the following form:
<PRE>&nbsp;&nbsp;&nbsp; #IFNDEF&nbsp; <I>macro_label</I></PRE>
When invoked, the list of macro labels (established via DEFINE directives)
is searched. If the label is not found, the following lines of code are
assembled. If it is found, the input file is skipped until an ENDIF or
ELSE directive is found.
<H2>
<A NAME="IF"></A>IF</H2>
The IF directive can be used to optionally assemble a block of code dependent
on the value of a given expression. The format is as follows:
<PRE>&nbsp;&nbsp;&nbsp; #IF&nbsp;&nbsp;&nbsp;&nbsp; <I>expr</I></PRE>
If the expression <I>expr</I> evaluates to non-zero, the following block
of code is assembled (until an ENDIF or ELSE is encountered).
<H2>
<A NAME="INCLUDE"></A>INCLUDE</H2>
The INCLUDE directive reads in and assembles the indicated source file.
INCLUDEs can be nested up to four levels. This allows a convenient means
to keep common definitions, declarations, or subroutines in files to be
included as needed. The format is as follows:
<PRE>#INCLUDE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>filename</I></PRE>
The <I>filename</I> must be enclosed in double quotes. Here are some examples:
<PRE>&nbsp;&nbsp;&nbsp; #INCLUDE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "macros.h"
&nbsp;&nbsp;&nbsp; #include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "equates"
&nbsp;&nbsp;&nbsp; #include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "subs.asm"</PRE>

<H2>
<A NAME="LIST"></A>LIST/NOLIST</H2>
The LIST and NOLIST directives can be used to alternately turn the output
to the list file on (LIST) or off (NOLIST). The formats are:
<PRE>&nbsp;&nbsp;&nbsp; .LIST
&nbsp;&nbsp;&nbsp; .NOLIST</PRE>

<H2>
<A NAME="LOCALLABELCHAR"></A>LOCALLABELCHAR</H2>
The LOCALLABELCHAR directive can be used to override the default "_" as
the label prefix indicating a local label. For example, to change the prefix
to "?" do this:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>]&nbsp;&nbsp; .LOCALLABELCHAR "?"</PRE>
Be careful to use only characters that are not operators for expression
evaluation. To do so causes ambiguity for the expression evaluator. Some
safe characters are "?", "{", and "}".&nbsp; See <A HREF="#Labels">Labels</A>
for an example of local label usage.
<H2>
<A NAME="LSFIRST"></A>LSFIRST/MSFIRST</H2>
The LSFIRST and MSFIRST directives determine the byte order rule to be
employed for the <A HREF="#WORD">WORD</A> directive. The default (whether
correct or not) for all TASM versions is the least significant byte first
(LSFIRST). The following illustrates its effect:
<PRE>&nbsp;&nbsp;&nbsp; 0000&nbsp; 34 12&nbsp;&nbsp;&nbsp; .word $1234
&nbsp;&nbsp;&nbsp; 0002&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .msfirst
&nbsp;&nbsp;&nbsp; 0002&nbsp; 12 34&nbsp;&nbsp;&nbsp; .word $1234
&nbsp;&nbsp;&nbsp; 0004&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .lsfirst
&nbsp;&nbsp;&nbsp; 0004&nbsp; 34 12&nbsp;&nbsp;&nbsp; .word $1234</PRE>

<H2>
<A NAME="MODULE"></A>MODULE</H2>
The MODULE directive defines the scope of local labels. The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>]&nbsp;&nbsp; .MODULE <I>label</I></PRE>
Here is an example:
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .MODULE module_x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda regx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne _skip
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec
&nbsp;&nbsp; _skip&nbsp; rts
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .MODULE module_y
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lda regy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne _skip
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec
&nbsp;&nbsp; _skip&nbsp; rts</PRE>
In the above example, the local label<I> _skip</I> is reused without harm
since the two usages are in separate modules. See also section <A HREF="#LOCALLABELCHAR">LOCALLABELCHAR</A>
directive.
<H2>
<A NAME="ORG"></A>ORG</H2>
The ORG directive provides the means to set the Instruction Pointer (a.k.a.
Program Counter) to the desired value. The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>] .ORG&nbsp;&nbsp;&nbsp; <I>expr</I></PRE>
The <I>label</I> is optional. The Instruction pointer is assigned the value
of the <I>expr</I>. For example, to generate code starting at address 1000H,
the following could be done:
<PRE>&nbsp;&nbsp;&nbsp; start&nbsp;&nbsp; .ORG&nbsp;&nbsp;&nbsp; 1000H</PRE>
The expression (<I>expr</I>) may contain references to the current Instruction
Pointer, thus allowing various manipulations to be done. For example, to
align the Instruction Pointer on the next 256 byte boundary, the following
could be done:
<PRE>&nbsp;&nbsp;&nbsp; .ORG&nbsp; (($ + 0FFH) &amp; 0FF00H)</PRE>
ORG can also be used to reserve space without assigning values:
<PRE>&nbsp;&nbsp;&nbsp; .ORG&nbsp;&nbsp;&nbsp; $+8</PRE>
An alternate form of ORG is '*=' or '$='. Thus the following two examples
are exactly equivalent to the previous example:
<PRE>&nbsp;&nbsp;&nbsp; *=*+8
&nbsp;&nbsp;&nbsp; $=$+8</PRE>

<H2>
<A NAME="PAGE"></A>PAGE/NOPAGE</H2>
The PAGE/NOPAGE directives can be used to alternately turn the paging mode
on (PAGE) or off (NOPAGE). If paging is in effect, then every sixty lines
of output will be followed by a Top of Form character and a two line header
containing page number, filename, and the title. The format is:
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; .PAGE
&nbsp;&nbsp;&nbsp; .NOPAGE</PRE>
The number of lines per page can be set with the '-p' command line option.
<H2>
<A NAME="SET"></A>SET</H2>
The SET directive allows the value of an existing label to be changed.
The format is:
<PRE>&nbsp;&nbsp;&nbsp; <I>label</I>&nbsp;&nbsp; .SET&nbsp;&nbsp;&nbsp; <I>expr</I></PRE>
The use of the SET directive should be avoided since changing the value
of a label can sometimes cause phase errors between pass 1 and pass 2 of
the assembly.
<H2>
<A NAME="SYM"></A>SYM/AVSYM</H2>
These directives can be used to cause a symbol table file to be generated.
The format is:
<PRE>&nbsp;&nbsp;&nbsp; .SYM&nbsp;&nbsp;&nbsp; ["symbol_filename"]
&nbsp;&nbsp;&nbsp; .AVSYM&nbsp; ["symbol_filename"]</PRE>
For example:
<PRE>&nbsp;&nbsp;&nbsp; .SYM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "symbol.map"
&nbsp;&nbsp;&nbsp; .SYM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; .AVSYM&nbsp;&nbsp;&nbsp;&nbsp; "prog.sym"
&nbsp;&nbsp;&nbsp; .AVSYM</PRE>
The two directives are similar, but result in a different format of the
symbol table file. The format of the SYM file is one line per symbol, each
symbol starts in the first column and is followed by white space and then
four hexadecimal digits representing the value of the symbol. The following
illustrates the format:
<PRE>&nbsp;&nbsp;&nbsp; label1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFFE
&nbsp;&nbsp;&nbsp; label2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FFFF
&nbsp;&nbsp;&nbsp; label3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1000</PRE>
The AVSYM directive is provided to generate symbol tables compatible with
the Avocet 8051 simulator. The format is similar, but each line is prefixed
by an 'AS' and each symbol value is prefixed by a segment indicator:
<PRE>&nbsp;&nbsp;&nbsp; AS&nbsp;&nbsp;&nbsp;&nbsp; start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C:1000
&nbsp;&nbsp;&nbsp; AS&nbsp;&nbsp;&nbsp;&nbsp; read_byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C:1245
&nbsp;&nbsp;&nbsp; AS&nbsp;&nbsp;&nbsp;&nbsp; write_byte&nbsp;&nbsp;&nbsp;&nbsp; C:1280
&nbsp;&nbsp;&nbsp; AS&nbsp;&nbsp;&nbsp;&nbsp; low_nib_mask&nbsp;&nbsp; N:000F
&nbsp;&nbsp;&nbsp; AS&nbsp;&nbsp;&nbsp;&nbsp; buffer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X:0080</PRE>
The segment prefixes are determined by the most recent segment directive
invoked (see BSEG/CSEG/DSEG/NSEG/XSEG directives).
<H2>
<A NAME="TEXT"></A>TEXT</H2>
This directive allows an ASCII string to be used to assign values to a
sequence of locations starting at the current Instruction Pointer. The
format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>] .TEXT&nbsp;&nbsp; "string"</PRE>
The ASCII value of each character in string is taken and assigned to the
next sequential location. Some escape sequences are supported as follows:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=CENTER VALIGN=TOP><B>Escape Sequence&nbsp;</B></TD>

<TD ALIGN=LEFT VALIGN=TOP><B>Description&nbsp;</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP><TT>\n&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>Line Feed&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP><TT>\r&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>Carriage return&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP><TT>\b&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>Backspace&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP><TT>\t&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>Tab&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP><TT>\f&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>Formfeed&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP><TT>\\&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>Backslash&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP><TT>\"&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>Quote&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER VALIGN=TOP><TT>\000&nbsp;</TT></TD>

<TD ALIGN=LEFT VALIGN=TOP>Octal value of character&nbsp;</TD>
</TR>
</TABLE>

<P>Here are some examples:

<PRE>&nbsp;&nbsp;&nbsp; message1&nbsp;&nbsp; .TEXT&nbsp;&nbsp; "Disk I/O error"
&nbsp;&nbsp;&nbsp; message2&nbsp;&nbsp; .text&nbsp;&nbsp; "Enter file name "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .text&nbsp;&nbsp; "abcdefg\n\r"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .text&nbsp;&nbsp; "I said \"NO\""</PRE>

<H2>
<A NAME="TITLE"></A>TITLE</H2>
The TITLE directive allows the user to define a title string that appears
at the top of each page of the list file (assuming the PAGE mode is on).
The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>]&nbsp;&nbsp;&nbsp; .TITLE&nbsp; "<I>string</I>"</PRE>
The <I>string</I> should not exceed 80 characters. Here are some examples:
<PRE>&nbsp;&nbsp;&nbsp; .TITLE&nbsp; "Controller version 1.1"
&nbsp;&nbsp;&nbsp; .title&nbsp; "This is the title of the assembly"
&nbsp;&nbsp;&nbsp; .title&nbsp; ""</PRE>

<H2>
<A NAME="WORD"></A>WORD</H2>
The WORD directive allows a value assignment to the next two bytes pointed
to by the current Instruction Pointer. The format is:
<PRE>&nbsp;&nbsp;&nbsp; [<I>label</I>] .WORD <I>expr</I> [,<I>expr</I>...]</PRE>
The least significant byte of expr is put at the current Instruction Pointer
with the most significant byte at the next sequential location (unless
the MSFIRST directive has been invoked). Here are some examples:
<PRE>&nbsp;&nbsp;&nbsp; data_table&nbsp;&nbsp;&nbsp;&nbsp; .WORD&nbsp;&nbsp; (data_table + 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .word&nbsp;&nbsp; $1234
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Word&nbsp;&nbsp; (('x' - 'a')&nbsp; &lt;&lt; 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Word&nbsp; 12, 55, 32</PRE>

<HR>
<H1>
<A NAME="OBJECT_FILE_FORMATS"></A>OBJECT FILE FORMATS</H1>
TASM can generate object code in the formats indicated below:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD><B>Option&nbsp;</B></TD>

<TD><B>Description</B></TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g0&nbsp;</TD>

<TD ALIGN=LEFT>Intel hex (default)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g1&nbsp;</TD>

<TD ALIGN=LEFT>MOS Technology hex (same as <B>-m</B>)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g2&nbsp;</TD>

<TD ALIGN=LEFT>Motorola hex&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g3&nbsp;</TD>

<TD ALIGN=LEFT>binary (same as <B>-b</B>)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=CENTER>-g4&nbsp;</TD>

<TD ALIGN=LEFT>Intel hex with word addresses</TD>
</TR>
</TABLE>
<P>The <B>-m</B> and <B>-b</B> flags may also be used, as indicated above.
If both are used the right-most option on the command line will be obeyed.
<H2>
Intel Hex Object Format</H2>
This is the default object file format. This format is line oriented and
uses only printable ASCII characters except for the carriage return/line
feed at the end of each line. The format is symbolically represented as:

<P>:<I>NN AAAA RR HH CC CRLF</I>

<P>Where:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>:</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Record Start Character (colon)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>NN</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Byte Count (2 hex digits)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>AAAA</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Address of first byte (4 hex digits)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>RR</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Record Type (<B>00</B> except for last record
which is <B>01</B>)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>HH</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Data Bytes (a pair of hex digits for each byte
of data in the record)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>CC</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Check Sum (2 hex digits)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>CRLF</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Line Terminator (CR/LF for DOS, LF for LINUX)</TD>
</TR>
</TABLE>
<P>The last line of the file will be a record conforming to the above format
with a byte count of zero.

<P>The checksum is defined as:

<P><I>sum = byte_count+address_hi+address_lo+record_type+(sum of all data
bytes)</I>
<BR><I>checksum = ((-sum) &amp; ffh)</I>

<P>Here is a sample listing file followed by the resulting object file:
<PRE>0001&nbsp;&nbsp; 0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0002&nbsp;&nbsp; 1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .org&nbsp;&nbsp; $1000
0003&nbsp;&nbsp; 1000 010203040506&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .byte&nbsp; 1, 2, 3, 4, 5, 6, 7, 8
0003&nbsp;&nbsp; 1006 0708
0004&nbsp;&nbsp; 1008 090A0B0C0D0E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .byte&nbsp; 9,10,11,12,13,14,15,16
0004&nbsp;&nbsp; 100E 0F10
0005&nbsp;&nbsp; 1010 111213141516&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .byte 17,18,19,20,21,22,23,24,25,26
0005&nbsp;&nbsp; 1016 1718191A
0006&nbsp;&nbsp; 101A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .end</PRE>

<PRE>&nbsp;&nbsp;&nbsp; :181000000102030405060708090A0B0C0D0E0F101112131415161718AC
&nbsp;&nbsp;&nbsp; :02101800191AA3
&nbsp;&nbsp;&nbsp; :00000001FF</PRE>

<H2>
Intel Hex Word Address Object Format</H2>
This format is identical to the <B>Intel Hex Object Format</B> except that
the address for each line of object code is divided by two thus converting
it to a word address (16 bit word). All other fields are identical.

<P>Here is an example:
<PRE>:180800000102030405060708090A0B0C0D0E0F101112131415161718AC
:02080C00191AA3
:00000001FF</PRE>

<H2>
MOS Technology Hex Object Format</H2>
This format is line oriented and uses only printable ASCII characters except
for the carriage return/line feed at the end of each line. Each line in
the file is of the following format:

<P>:<I>NN AAAA HH CC CRLF</I>

<P>Where:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>;</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Record Start Character (semicolon)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>NN</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Byte Count (2 hex digits)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>AAAA</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Address of first byte (4 hex digits)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>HH</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Data Bytes (a pair of hex digits for each byte
of data in the record)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>CCCC</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Check Sum (4 hex digits)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>CRLF</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Line Terminator (CR/LF for DOS, LF for LINUX)</TD>
</TR>
</TABLE>
<P>The last line of the file will be a record conforming to the above format
with a byte count of zero.

<P>The checksum is defined as:

<P><I>sum =byte_count+address_hi+address_lo+record_type+(sum of all data
bytes)</I>
<BR><I>checksum = (sum &amp; ffffh)</I>

<P>Here is a sample object file:
<PRE>;1810000102030405060708090A0B0C0D0E0F1011121314151617180154
;021018191A005D
;00</PRE>

<H2>
Motorola Hex Object Format</H2>
This format is line oriented and uses only printable ASCII characters except
for the carriage return/line feed at the end of each line. The format is
symbolically represented as:

<P><I>S1 NN AAAA HH CCCC CRLF</I>

<P>Where:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>S1</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Record Start tag&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>NN</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Byte Count (2 hex digits) (data byte count +
3)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>AAAA</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Address of first byte (4 hex digits)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>HH</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Data Bytes (a pair of hex digits for each byte
of data in the record)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>CC</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Check Sum (2 hex digits)</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP><B><I>CRLF</I></B></TD>

<TD ALIGN=LEFT VALIGN=TOP>Line Terminator (CR/LF for DOS, LF for LINUX)</TD>
</TR>
</TABLE>

<P>The checksum is defined as:

<P><I>sum = byte_count+address_hi+address_lo+(sum of all data bytes)</I>
<BR><I>checksum = ((~sum) &amp; ffh)</I>

<P>Here is a sample file:
<PRE>S11B10000102030405060708090A0B0C0D0E0F101112131415161718A8
S1051018191A9F
S9030000FC</PRE>
<P>The last line of the file will be a record with a byte count of zero and
a tag of S9. The address field will be 0000 unless and address was provided
with the END directive in which case it will appear in the address field.
<H2>
Binary Object Format.</H2>
This file format is essentially a memory image of the object code without
address, checksum or format description information.

<P>Note that when this object format is selected (-b option), the -c option
is forced. This is done so that no ambiguity results from the lack of address
information in the file. Without the -c option, discontinuous blocks of
object code would appear contiguous.
<BR>&nbsp;

<P>
<HR>
<H1>
<A NAME="LISTING_FILE_FORMAT"></A>LISTING FILE FORMAT</H1>
Each line of source code generates one (or more) lines of output in the
listing file. The fields of the output line are as follows:
<OL>
<LI>
Current source file line number (4 decimal digits).</LI>

<LI>
An optional '+' appears if this is an 'INCLUDE' file. (One '+' for each
level of <A HREF="#INCLUDE">INCLUDE</A> invoked).</LI>

<LI>
Current Instruction Pointer (4 hex digits). An optional '~' follows the
Instruction Pointer if the line of source code is not being assembled because
of an IFDEF, IFNDEF, or IF directive.</LI>

<LI>
Resulting code/data generated from this source line (two hex digits per
byte, each byte separated by a space, up to six bytes per line).</LI>

<LI>
The source line exactly as it appears in the source file.</LI>
</OL>
If paging is enabled (by either the '-p' option flag or the .PAGE directive)
some additional fields will be inserted into the listing file every 60
lines. These fields are:
<OL>
<LI>
Top of Form (form feed).</LI>

<LI>
Assembler identifier (e.g. "TASM 6502 Assembler").</LI>

<LI>
Initial source file name.</LI>

<LI>
Page number.</LI>

<LI>
Title.</LI>
</OL>
If errors are encountered, then error messages will be interspersed in
the listing. TASM outputs error messages proceeding the offending line.
The following example illustrates the format:
<PRE>&nbsp;&nbsp;&nbsp; 0001&nbsp;&nbsp; 0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label1&nbsp; .equ&nbsp; 40h
&nbsp;&nbsp;&nbsp; 0002&nbsp;&nbsp; 0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label2&nbsp; .equ&nbsp; 44h
&nbsp;&nbsp;&nbsp; 0003&nbsp;&nbsp; 0000&nbsp;
&nbsp;&nbsp;&nbsp; 0004&nbsp;&nbsp; 1000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start:&nbsp; .org&nbsp; 1000h
&nbsp;&nbsp;&nbsp; 0005&nbsp;&nbsp; 1000 E6 40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp; label1
&nbsp;&nbsp;&nbsp; 0006&nbsp;&nbsp; 1002 E6 44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp; label2
&nbsp;&nbsp;&nbsp; tt.asm line 0007: Label not found: (label3)
&nbsp;&nbsp;&nbsp; 0007&nbsp;&nbsp; 1004 EE 00 00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp; label3
&nbsp;&nbsp;&nbsp; 0008&nbsp;&nbsp; 1007 4C 00 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp; start
&nbsp;&nbsp;&nbsp; 0009&nbsp;&nbsp; 100A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .end&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0010&nbsp;&nbsp; 100A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; tasm: Number of errors = 1</PRE>

<HR>
<H1>
<A NAME="PROM_PROGRAMMING"></A>PROM PROGRAMMING</H1>
A wide variety of PROM programming equipment is available that can use
object code in one or more of the formats supported by TASM. Here are some
notes concerning the generation of code to be programmed into PROMs:
<H2>
PRESET MEMORY</H2>
It is often desirable to have all bytes in the PROM programmed even if
not explicitly assigned a value in the source code (e.g. the bytes are
skipped over with a .ORG statement). This can be accomplished by using
the <I>-c</I> (contiguous block) and the <I>-f</I> (fill) command line
option flags. The <I>-c</I> will ensure that every byte from the lowest
byte assigned a value to the highest byte assigned a value will be in the
object file with no gaps. The <I>-f</I> flag will assign the specified
value to all bytes before the assembly begins so that when the object file
is written, all bytes not assigned a value in the source code will have
a known value. As an example, the following command line will generate
object code in the default Intel Hex format with all bytes not assigned
a value in the source set to EA (hex, 6502 NOP instruction):
<PRE>&nbsp;&nbsp;&nbsp; tasm -65 -c -fEA test.asm</PRE>

<H2>
CONTIGUOUS BLOCKS</H2>
To ensure that TASM generates object code to cover the full address range
of the target PROM, put a .ORG statement at the end of the source file
set to the last address desired. For example, to generate code to be put
in a 2716 EPROM (2 Kbytes) from hex address $1000 to $17ff, do something
like this in the source file:
<PRE>&nbsp;&nbsp;&nbsp; ;start of the file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ORG&nbsp;&nbsp;&nbsp; $1000
&nbsp;&nbsp;&nbsp; ;rest of the source code follows
&nbsp;&nbsp;&nbsp; source code
&nbsp;&nbsp;&nbsp; ;end of the source code
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ORG&nbsp;&nbsp;&nbsp; $17ff
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .BYTE&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .END</PRE>
Now, to invoke TASM to generate the code in the binary format with all
unassigned bytes set to 00 (6502 BRK instruction), do the following:
<PRE>tasm -65 -b -f00 test.asm</PRE>
Note: -b forces the -c option.
<BR>
<HR>
<H1>
<A NAME="ERROR_MESSAGES"></A>ERROR MESSAGES</H1>

<H2>
Error Message Format</H2>
TASM error messages take the following general form:
<PRE>&nbsp;&nbsp;&nbsp; <I>filename </I>line<I> line_number</I>: <I>error_message</I></PRE>
For example:
<PRE>&nbsp;&nbsp;&nbsp; main.asm line 0032: Duplicate label (start)</PRE>
Many editors and IDE’s can run assemblies from within and parse the error
messages to make it convenient to jump to each error and correct.&nbsp;
If the above format is not satisfactory for your editor or IDE, use the
<A HREF="#TASMERRFORMAT">TASMERRFORMAT</A> environment variable to alter
the error message format.

<P>When using automatic invocation of TASM from within an editor or IDE,
it may be useful to use the <A HREF="#TASMOPTS">TASMOPTS</A> environment
variable to set other command line options.&nbsp; For example, to cause
TASM to perform 6502 assemblies, set TASMOPTS like this:
<UL>
<PRE>SET TASMOPTS=-65</PRE>
</UL>

<H2>
ERROR MESSAGE DESCRIPTIONS</H2>

<DL>
<DT>
<B><FONT SIZE=+1>Binary operator where value expected</FONT></B></DT>

<DD>
Two binary operators in a row indicate a missing value.</DD>

<DT>
<B><FONT SIZE=+1>Branch off of current 2K page</FONT></B></DT>

<DD>
An instruction is attempting to branch to a location not within the current
2K byte page.</DD>

<DT>
<B><FONT SIZE=+1>Branch off of current page</FONT></B></DT>

<DD>
An instruction is attempting to branch to a location not within the current
256 byte page.</DD>

<DT>
<B><FONT SIZE=+1>Cannot malloc for label storage</FONT></B></DT>

<DD>
Insufficient memory to store more labels. See <B><A HREF="#LIMITATIONS">LIMITATIONS</A></B>.</DD>

<DT>
<B><FONT SIZE=+1>Duplicate label</FONT></B></DT>

<DD>
The label for the current line has already been assigned a value. Duplicate
label checks are optionally enabled by the <I>-a</I> option.</DD>

<DT>
<B><FONT SIZE=+1>File name too short</FONT></B></DT>

<DD>
A file name on the command line is fewer than 3 characters. A two character
file name may be valid, of course, but it is detected as an error to prevent
a garbled option flag from being taken as a source file, which in turn
can result in the true source file being taken as the object file. Since
the object file is truncated at startup time, the source file could be
clobbered.</DD>

<DT>
<B><FONT SIZE=+1>Forward reference in equate</FONT></B></DT>

<DD>
An EQU directive is using a label on the right hand side that has not yet
been defined.</DD>

<DT>
<B><FONT SIZE=+1>Heap overflow on label definition</FONT></B></DT>

<DD>
TASM was unable to allocate memory to store the label.</DD>

<DT>
<B><FONT SIZE=+1>Imbalanced conditional.</FONT></B></DT>

<DD>
An end-of-file was encountered at which time the level of descent in conditional
directives was different from when the file was entered. Conditional directives
include IF, IFDEF, and IFNDEF.</DD>

<DT>
<B><FONT SIZE=+1>Invalid Object file type.</FONT></B></DT>

<DD>
An object file type was requested by the -g command line option that is
not valid. See section on Option g - Object File Format.</DD>

<DT>
<B><FONT SIZE=+1>Invalid operand.</FONT></B></DT>

<DD>
No indirection for this instruction. The first character of an operand
was a left parenthesis for an instruction that does not explicitly specify
that as the format. Some micros use the parenthesis as an indicator of
indirection, but putting a layer of parenthesis around an expression is
always a valid thing to do (as far as the expression evaluator is concerned).
The test for this case is only done if the <I>-a4</I> option is selected.
See section on <B><A HREF="#Assembly_Control">ASSEMBLY CONTROL</A></B>.</DD>

<DT>
<B><FONT SIZE=+1>Invalid token where value expected.</FONT></B></DT>

<DD>
Two binary operators in a row are not allowed.</DD>

<DT>
<B><FONT SIZE=+1>Label too long.</FONT></B></DT>

<DD>
Labels are limited to 31 characters.</DD>

<DT>
<B><FONT SIZE=+1>Label value misaligned</FONT></B></DT>

<DD>
The value of a label appears to have a different value on the second pass
then it was computed to have on the first pass. This is generally due to
Zero Page Addressing mode problems with the 6502 version of TASM. Labels
that are used in operands for statements that could utilize Zero Page addressing
mode should always be defined before used as an operand.</DD>

<DT>
<B><FONT SIZE=+1>Label not found</FONT></B></DT>

<DD>
A label used in an expression was not found in the current label table.</DD>

<DT>
<B><FONT SIZE=+1>Label must pre-exist for SET.</FONT></B></DT>

<DD>
The SET directive can only be applied to an existing label.</DD>

<DT>
<B><FONT SIZE=+1>Label table overflow</FONT></B></DT>

<DD>
To many labels have been encountered.</DD>

<DT>
<B><FONT SIZE=+1>List file open error</FONT></B></DT>

<DD>
TASM was not able to open the specified list file.</DD>

<DT>
<B><FONT SIZE=+1>Macro expansion too long.</FONT></B></DT>

<DD>
The expansion of a macro resulted in a line that exceeded the maximum length.</DD>

<DT>
<B><FONT SIZE=+1>Max number of nested conditionals exceeded</FONT></B></DT>

<DD>
Too many levels of IF, IFDEF, or IFNDEF.</DD>

<DT>
<B><FONT SIZE=+1>Maximum number of args exceeded</FONT></B></DT>

<DD>
Too many macro arguments.</DD>

<DT>
<B><FONT SIZE=+1>Maximum number of macros exceeded</FONT></B></DT>

<DD>
Too many macros (DEFINEs) have been encountered.</DD>

<DT>
<B><FONT SIZE=+1>No END directive before EOF</FONT></B></DT>

<DD>
The source file did not have an END directive in it. This is not fatal,
but may cause the last object file record to be lost.</DD>

<DT>
<B><FONT SIZE=+1>No files specified</FONT></B></DT>

<DD>
TASM was invoked with no source file specified.</DD>

<DT>
<B><FONT SIZE=+1>No such label</FONT></B></DT>

<DD>
A SET directive was encountered for a label not yet defined. The value
of labels that are modified by the SET directive must already exist.</DD>

<DT>
<B><FONT SIZE=+1>No terminating quote</FONT></B></DT>

<DD>
A double quote was used at the start of a a text string but was not used
at the end of the string.</DD>

<DT>
<B><FONT SIZE=+1>No indirection for this instruction.</FONT></B></DT>

<DD>
A parenthesis was found around the operand expression. This may indicate
an attempt to use indirection where it is inappropriate.</DD>

<DT>
<B><FONT SIZE=+1>Non-unary operator at start of expression</FONT></B></DT>

<DD>
A binary operator (such as '*') was found at the beginning of an expression.
Some micros use '*' as an indirection operator. Since it is also a legitimate
operator in an expression, some ambiguity can arise. If a particular instruction/addressing
mode does not allow indirection, and a '*' is placed in front of the associated
expression, the assembler will assume this error. See the <I>-a8</I> option
of <A HREF="#Assembly_Control">ASSEMBLY CONTROL</A>.</DD>

<DT>
<B><FONT SIZE=+1>Object file open error</FONT></B></DT>

<DD>
TASM was not able to open the specified object file.</DD>

<DT>
<B><FONT SIZE=+1>Range of argument exceeded</FONT></B></DT>

<DD>
The value of an argument exceeds the valid range for the current instruction
and addressing mode.</DD>

<DT>
<B><FONT SIZE=+1>Range of relative branch exceeded</FONT></B></DT>

<DD>
A branch instruction exceeds the maximum range.</DD>

<DT>
<B><FONT SIZE=+1>Source file open error</FONT></B></DT>

<DD>
TASM was not able to open the specified source file.</DD>

<DT>
<B><FONT SIZE=+1>Unrecognized directive</FONT></B></DT>

<DD>
A statement starting with a '.' or '#' has a mnemonic that is not defined
as a directive.</DD>

<DT>
<B><FONT SIZE=+1>Unrecognized instruction</FONT></B></DT>

<DD>
A statement has an opcode mnemonic that is not defined.</DD>

<DT>
<B><FONT SIZE=+1>Unrecognized argument</FONT></B></DT>

<DD>
A statement has an operand format that is not defined.</DD>

<DT>
<B><FONT SIZE=+1>Unknown token</FONT></B></DT>

<DD>
Unexpected characters were encountered while parsing an expression.</DD>

<DT>
<B><FONT SIZE=+1>Unused data in MS byte of argument</FONT></B></DT>

<DD>
An instruction or directive used the least significant byte of an argument
and left the most significant byte unused, but it was non-zero.</DD>

<DT>
<B><FONT SIZE=+1>Unknown option Flag.</FONT></B></DT>

<DD>
Invalid option flag has been specified on the command line. invoke TASM
with nothing on the command line to see a list of valid options.</DD>
</DL>

<HR>
<H1>
<A NAME="LIMITATIONS"></A>LIMITATIONS</H1>

<TABLE BORDER >
<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum number of labels&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>15000&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum length of labels&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>32 characters&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum address space&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>64 Kbytes (65536 bytes)&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum number of nested INCLUDES</TD>

<TD ALIGN=LEFT VALIGN=TOP>4&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum length of TITLE string&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>79 characters&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum source line length&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>511 characters&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum length after macro expansion&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>511 characters&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum length of expressions&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>511 characters&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum length of pathnames&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>79 characters&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum length of command line&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>127 characters&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum number of instructions (per table)&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>1200&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum number of macros&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>1000&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum number of macro arguments&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>10&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Maximum length of macro argument&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>16 characters&nbsp;</TD>
</TR>

<TR>
<TD ALIGN=LEFT VALIGN=TOP>Memory requirements&nbsp;</TD>

<TD ALIGN=LEFT VALIGN=TOP>512K&nbsp;</TD>
</TR>
</TABLE>

<H2>
Other Limitations</H2>

<OL>
<LI>
The 8048 version of TASM does not check for use of memory beyond any reasonable
bounds (e.g. an 8048 has a maximum address space of 4 Kbytes but TASM will
let you pretend that you have 64 Kbytes).</LI>

<LI>
Expression evaluation has no operator precedence in effect which can make
for unexpected results if not explicitly grouped with parenthesis.</LI>

<LI>
First page of listing file will not show a user defined title (defined
via TITLE directive).</LI>
</OL>

<HR>
<BR><A HREF="#Top">Top</A>
</BODY>
</HTML>
