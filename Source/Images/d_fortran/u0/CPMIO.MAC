TITLE CPMIO CONSOLE I/O ROUTINES FOR CP/M
	ENTRY	$TTYIN,$TTYOT,$LNPTR,$CPMBF,$LINBF
TANDY	EQU	0
CPMSBC	EQU	0
;
IF2
.PRINTX /CPMIO/
IFT	TANDY
.PRINTX/TANDY VERSION/
ENDIF
IFT	CPMSBC
.PRINTX/CPM SBC VERSION/
ENDIF
IFF	TANDY OR CPMSBC
.PRINTX/NORMAL CPM VERSION/
ENDIF
ENDIF
;
IFT	TANDY
CPMENT	SET	4205H
ENDIF
IFF	TANDY
CPMENT	SET	5
ENDIF
IFT	CPMSBC
CPMENT	SET	4005H
ENDIF
;CP/M CONSOLE OUTPUT ROUTINE
$TTYOT:	PUSH	B
	PUSH	D
	PUSH	H
	PUSH	PSW		;SAVE ALL REG'S
	MVI	C,2		;CONSOLE OUTPUT
	MOV	E,A		;EXPECTS CHAR IN [E]
	CALL	CPMENT		;OUTPUT THE CHAR
	POP	PSW
	POP	H
	POP	D
	POP	B		;RESTORE STATE
	RET
;
;CP/M CONSOLE INPUT ROUTINE
;NOTE: DON'T STOP PROGRAM IN INPUT WITH SWITCHES, COULD LEAVE
;	GARB IN LINE IF THEN SAVED AND STARTED OVER.
$TTYIN:	PUSH	H		;SAVE [H,L]
	LHLD	$LNPTR		;POINT TO LAST CHAR
	MOV	A,M		;GET LAST CHAR
	CPI	12Q		;FINISHED OFF LINE(LF)?
	CZ	GETLIN		;YES, GET ANOTHER
	INX	H		;POINT TO NEXT CHAR
	MOV	A,M		;GET IT
	SHLD	$LNPTR		;SAVE PTR
	POP	H		;RESTORE
	RET
;
GETLIN:	PUSH	B
	PUSH	D		;SAVE OTHER REG'S
	MVI	C,12Q		;READ CONSOLE LINE
	LXI	D,$CPMBF	;PTR TO BUFFER
	CALL	CPMENT		;READ LINE FROM CONSOLE
	LXI	H,$CPMBF+1	;POINT TO LENGTH OF LINE
	MOV	E,M		;GET LENGTH
	MVI	D,0		;[D,E] = LENGTH
	XCHG			;SAVE [H,L] IN [D,E]
	DAD	D		;GET PTR TO LAST CHAR
	INX	H
	MVI	M,15Q		;ADD <CR>
	INX	H
	MVI	A,12Q		;LINE FEED
	CALL	$TTYOT		;CPM DOESN'T GIVE ONE
	MOV	M,A		;AND <LF>
	XCHG			;[H,L]=1ST CHAR -1
	POP	D
	POP	B
	RET
;
DSEG
$CPMBF:	DB	80		;LENGTH OF BUFFER
	DB	0		;LENGTH OF LINE
$LINBF:	DB	12Q		;SO WORKS AT FIRST
	DS	135		;REST OF BUFFER FOR LINE
;
$LNPTR:	DW	$LINBF		;AT FIRST POINT TO <LF> IN FRONT
;				;TO FORCE READ OF LINE
;
	END
