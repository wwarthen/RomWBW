;
;=============================================================================
;   PPIDE DISK DRIVER
;=============================================================================
;
; TODO:
; - FIX SCALER CONSTANT
; - GOPARTNER NEEDS TO HANDLE "NO PARTNER" CONDITION
;
; NOTES:
;  - WELL KNOWN PPIDE PORT ADDRESSES:
;      $60 - SBC/ZETA ONBOARD PPI
;      $20 - ECB DISKIO3, RC FAMILY
;      $44 - ECB MULTI-FUNCTION PIC
;      $80 - N8 ONBOARD PPI
;      $4C - DYNO ONBOARD PPI
;
; THE CONTROL PORT OF THE 8255 IS PROGRAMMED AS NEEDED TO READ OR WRITE
; DATA ON THE IDE BUS.	PORT C OF THE 8255 IS ALWAYS IN OUTPUT MODE BECAUSE
; IT IS DRIVING THE ADDRESS BUS AND CONTROL SIGNALS.  PORTS A & B WILL BE
; PLACED IN READ OR WRITE MODE DEPENDING ON THE DIRECTION OF THE DATA BUS.
;
PPIDE_DIR_READ	.EQU	%10010010	; IDE BUS DATA INPUT MODE
PPIDE_DIR_WRITE	.EQU	%10000000	; IDE BUS DATA OUTPUT MODE
;
; PORT C OF THE 8255 IS USED TO DRIVE THE IDE INTERFACE ADDRESS BUS
; AND VARIOUS CONTROL SIGNALS.	THE CONSTANTS BELOW REFLECT THESE
; ASSIGNMENTS.
;
PPIDE_CTL_DA0	.EQU	%00000001	; DRIVE ADDRESS BUS - BIT 0 (DA0)
PPIDE_CTL_DA1	.EQU	%00000010	; DRIVE ADDRESS BUS - BIT 1 (DA1)
PPIDE_CTL_DA2	.EQU	%00000100	; DRIVE ADDRESS BUS - BIT 2 (DA2)
PPIDE_CTL_CS1	.EQU	%00001000	; DRIVE CHIP SELECT 0 (ACTIVE LOW, INVERTED)
PPIDE_CTL_CS3	.EQU	%00010000	; DRIVE CHIP SELECT 1 (ACTIVE LOW, INVERTED)
PPIDE_CTL_DIOW	.EQU	%00100000	; DRIVE I/O WRITE (ACTIVE LOW, INVERTED)
PPIDE_CTL_DIOR	.EQU	%01000000	; DRIVE I/O READ (ACTIVE LOW, INVERTED)
PPIDE_CTL_RESET	.EQU	%10000000	; DRIVE RESET (ACTIVE LOW, INVERTED)
;
;	+-----------------------------------------------------------------------+
;	| CONTROL BLOCK REGISTERS (CS3FX)					|
;	+-----------------------+-------+-------+-------------------------------+
;	| REGISTER		| PORT	| DIR	| DESCRIPTION			|
;	+-----------------------+-------+-------+-------------------------------+
;	| PPIDE_REG_ALTSTAT	| 0x06	| R	| ALTERNATE STATUS REGISTER	|
;	| PPIDE_REG_CTRL	| 0x06	| W	| DEVICE CONTROL REGISTER	|
;	| PPIDE_REG_DRVADR	| 0x07	| R	| DRIVE ADDRESS REGISTER	|
;	+-----------------------+-------+-------+-------------------------------+
;
;	+-----------------------+-------+-------+-------------------------------+
;	| COMMAND BLOCK REGISTERS (CS1FX)					|
;	+-----------------------+-------+-------+-------------------------------+
;	| REGISTER		| PORT	| DIR	| DESCRIPTION			|
;	+-----------------------+-------+-------+-------------------------------+
;	| PPIDE_REG_DATA	| 0x00	| R/W	| DATA INPUT/OUTPUT		|
;	| PPIDE_REG_ERR		| 0x01	| R	| ERROR REGISTER		|
;	| PPIDE_REG_FEAT	| 0x01	| W	| FEATURES REGISTER		|
;	| PPIDE_REG_COUNT	| 0x02	| R/W	| SECTOR COUNT REGISTER		|
;	| PPIDE_REG_SECT	| 0x03	| R/W	| SECTOR NUMBER REGISTER	|
;	| PPIDE_REG_CYLLO	| 0x04	| R/W	| CYLINDER NUM REGISTER (LSB)	|
;	| PPIDE_REG_CYLHI	| 0x05	| R/W	| CYLINDER NUM REGISTER (MSB)	|
;	| PPIDE_REG_DRVHD	| 0x06	| R/W	| DRIVE/HEAD REGISTER		|
;	| PPIDE_REG_LBA0*	| 0x03	| R/W	| LBA BYTE 0 (BITS 0-7)		|
;	| PPIDE_REG_LBA1*	| 0x04	| R/W	| LBA BYTE 1 (BITS 8-15)	|
;	| PPIDE_REG_LBA2*	| 0x05	| R/W	| LBA BYTE 2 (BITS 16-23)	|
;	| PPIDE_REG_LBA3*	| 0x06	| R/W	| LBA BYTE 3 (BITS 24-27)	|
;	| PPIDE_REG_STAT	| 0x07	| R	| STATUS REGISTER		|
;	| PPIDE_REG_CMD		| 0x07	| W	| COMMAND REGISTER (EXECUTE)	|
;	+-----------------------+-------+-------+-------------------------------+
;	* LBA0-3 ARE ALTERNATE DEFINITIONS OF SECT, CYL, AND DRVHD PORTS
;
;	=== STATUS REGISTER ===
;
;	    7	    6	    5	    4	    3	    2	    1	    0
;	+-------+-------+-------+-------+-------+-------+-------+-------+
;	|  BSY	| DRDY	|  DWF	|  DSC	|  DRQ	| CORR	|  IDX	|  ERR	|
;	+-------+-------+-------+-------+-------+-------+-------+-------+
;
;	BSY:	BUSY
;	DRDY:	DRIVE READY
;	DWF:	DRIVE WRITE FAULT
;	DSC:	DRIVE SEEK COMPLETE
;	DRQ:	DATA REQUEST
;	CORR:	CORRECTED DATA
;	IDX:	INDEX
;	ERR:	ERROR
;
;	=== ERROR REGISTER ===
;
;	    7	    6	    5	    4	    3	    2	    1	    0
;	+-------+-------+-------+-------+-------+-------+-------+-------+
;	| BBK	|  UNC	|  MC	|  IDNF |  MCR	| ABRT	| TK0NF |  AMNF |
;	+-------+-------+-------+-------+-------+-------+-------+-------+
;	(VALID WHEN ERR BIT IS SET IN STATUS REGISTER)
;
;	BBK:	BAD BLOCK DETECTED
;	UNC:	UNCORRECTABLE DATA ERROR
;	MC:	MEDIA CHANGED
;	IDNF:	ID NOT FOUND
;	MCR:	MEDIA CHANGE REQUESTED
;	ABRT:	ABORTED COMMAND
;	TK0NF:	TRACK 0 NOT FOUND
;	AMNF:	ADDRESS MARK NOT FOUND
;
;	=== DRIVE/HEAD / LBA3 REGISTER ===
;
;	    7	    6	    5	    4	    3	    2	    1	    0
;	+-------+-------+-------+-------+-------+-------+-------+-------+
;	|   1	|   L	|   1	|  DRV	|  HS3	|  HS2	|  HS1	|  HS0	|
;	+-------+-------+-------+-------+-------+-------+-------+-------+
;
;	L:	0 = CHS ADDRESSING, 1 = LBA ADDRESSING
;	DRV:	0 = DRIVE 0 (PRIMARY) SELECTED, 1 = DRIVE 1 (SLAVE) SELECTED
;	HS:	CHS = HEAD ADDRESS (0-15), LBA = BITS 24-27 OF LBA
;
;	=== DEVICE CONTROL REGISTER ===
;
;	    7	    6	    5	    4	    3	    2	    1	    0
;	+-------+-------+-------+-------+-------+-------+-------+-------+
;	|   X	|   X	|   X	|   X	|   1	| SRST	|  ~IEN |   0	|
;	+-------+-------+-------+-------+-------+-------+-------+-------+
;
;	SRST:	SOFTWARE RESET
;	~IEN:	INTERRUPT ENABLE
;
; CONTROL VALUES TO USE WHEN ACCESSING THE VARIOUS IDE DEVICE REGISTERS
;
PPIDE_REG_DATA		.EQU	PPIDE_CTL_CS1 | $00	; DATA INPUT/OUTPUT (R/W)
PPIDE_REG_ERR		.EQU	PPIDE_CTL_CS1 | $01	; ERROR REGISTER (R)
PPIDE_REG_FEAT		.EQU	PPIDE_CTL_CS1 | $01	; FEATURES REGISTER (W)
PPIDE_REG_COUNT		.EQU	PPIDE_CTL_CS1 | $02	; SECTOR COUNT REGISTER (R/W)
PPIDE_REG_SECT		.EQU	PPIDE_CTL_CS1 | $03	; SECTOR NUMBER REGISTER (R/W)
PPIDE_REG_CYLLO		.EQU	PPIDE_CTL_CS1 | $04	; CYLINDER NUM REGISTER (LSB) (R/W)
PPIDE_REG_CYLHI		.EQU	PPIDE_CTL_CS1 | $05	; CYLINDER NUM REGISTER (MSB) (R/W)
PPIDE_REG_DRVHD		.EQU	PPIDE_CTL_CS1 | $06	; DRIVE/HEAD REGISTER (R/W)
PPIDE_REG_LBA0		.EQU	PPIDE_CTL_CS1 | $03	; LBA BYTE 0 (BITS 0-7) (R/W)
PPIDE_REG_LBA1		.EQU	PPIDE_CTL_CS1 | $04	; LBA BYTE 1 (BITS 8-15) (R/W)
PPIDE_REG_LBA2		.EQU	PPIDE_CTL_CS1 | $05	; LBA BYTE 2 (BITS 16-23) (R/W)
PPIDE_REG_LBA3		.EQU	PPIDE_CTL_CS1 | $06	; LBA BYTE 3 (BITS 24-27) (R/W)
PPIDE_REG_STAT		.EQU	PPIDE_CTL_CS1 | $07	; STATUS REGISTER (R)
PPIDE_REG_CMD		.EQU	PPIDE_CTL_CS1 | $07	; COMMAND REGISTER (EXECUTE) (W)
PPIDE_REG_ALTSTAT	.EQU	PPIDE_CTL_CS3 | $06	; ALTERNATE STATUS REGISTER (R)
PPIDE_REG_CTRL		.EQU	PPIDE_CTL_CS3 | $06	; DEVICE CONTROL REGISTER (W)
PPIDE_REG_DRVADR	.EQU	PPIDE_CTL_CS3 | $07	; DRIVE ADDRESS REGISTER (R)
;
; COMMAND BYTES
;
PPIDE_CMD_RECAL		.EQU	$10
PPIDE_CMD_READ		.EQU	$20
PPIDE_CMD_WRITE		.EQU	$30
PPIDE_CMD_IDDEV		.EQU	$EC
PPIDE_CMD_SETFEAT	.EQU	$EF
;
; FEATURE BYTES
;
PPIDE_FEAT_ENABLE8BIT	.EQU	$01
PPIDE_FEAT_DISABLE8BIT	.EQU	$81
;
; PPIDE DEVICE TYPES
;
PPIDE_TYPEUNK	.EQU	0
PPIDE_TYPEATA	.EQU	1
PPIDE_TYPEATAPI	.EQU	2
;
; PPIDE DEVICE STATUS CODES
;
PPIDE_STOK	.EQU	0
PPIDE_STINVUNIT	.EQU	-1
PPIDE_STNOMEDIA	.EQU	-2
PPIDE_STCMDERR	.EQU	-3
PPIDE_STIOERR	.EQU	-4
PPIDE_STRDYTO	.EQU	-5
PPIDE_STDRQTO	.EQU	-6
PPIDE_STBSYTO	.EQU	-7
;
; DRIVE SELECTION BYTES (FOR USE IN DRIVE/HEAD REGISTER)
;
;PPIDE_DRVSEL:
PPIDE_DRVMASTER	.EQU	%11100000	; LBA, MASTER DEVICE
PPIDE_DRVSLAVE	.EQU	%11110000	; LBA, SLAVE DEVICE
;
; PPIDE DEVICE CONFIGURATION
;
PPIDE_CFGSIZ	.EQU	18		; SIZE OF CFG TBL ENTRIES
;
; PER DEVICE DATA OFFSETS
;
PPIDE_DEV	.EQU	0		; OFFSET OF DEVICE NUMBER (BYTE)
PPIDE_STAT	.EQU	1		; LAST STATUS (BYTE)
PPIDE_TYPE	.EQU	2		; DEVICE TYPE (BYTE)
PPIDE_ACC	.EQU	3		; ACCESS FLAG BITS BIT 0=MASTER, 1=8BIT (BYTE)
PPIDE_MED	.EQU	4		; MEDIA FLAG BITS BIT 0=CF, 1=LBA (BYTE)
PPIDE_MEDCAP	.EQU	5		; MEDIA CAPACITY (DWORD)
PPIDE_LBA	.EQU	9		; OFFSET OF LBA (DWORD)
PPIDE_DATALO	.EQU	13		; BASE PORT AND IDE DATA BUS LSB (8255 PORT A) (BYTE)
PPIDE_CTL	.EQU	14		; IDE ADDRESS BUS AND CONTROL SIGNALS (8255 PORT C)(BYTE)
PPIDE_PPI	.EQU	15		; 8255 CONTROL PORT(BYTE)
PPIDE_PARTNER	.EQU	16		; PARTNER DEVICE (MASTER <-> SLAVE) (WORD)
;
PPIDE_ACC_MAS	.EQU	%00000001	; UNIT IS MASTER (ELSE SLAVE)
PPIDE_ACC_8BIT	.EQU	%00000010	; UNIT WANTS 8 BIT I/O (ELSE 16 BIT)
;
PPIDE_MED_CF	.EQU	%00000001	; MEDIA IS CF CARD
PPIDE_MED_LBA	.EQU	%00000010	; MEDIA HAS LBA CAPABILITY
;
PPIDE_DEVCNT	.EQU	PPIDECNT * 2
;
PPIDE_CFGTBL:
;
#IF (PPIDECNT >= 1)
;
PPIDE_DEV0M:	; DEVICE 0, MASTER
	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
	.DB	0			; DEVICE STATUS
	.DB	0			; DEVICE TYPE
	.DB	PPIDE_ACC_MAS | (PPIDE0A8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
	.DB	0			; MEDIA FLAGS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
	.DB	PPIDE0BASE  		; DATALO
	.DB	PPIDE0BASE+2		; CTL 
	.DB	PPIDE0BASE+3		; PPI
	.DW	PPIDE_DEV0S		; PARTNER
;
PPIDE_DEV0S:	; DEVICE 0, SLAVE
	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
	.DB	0			; DEVICE STATUS
	.DB	0			; DEVICE TYPE
	.DB	(PPIDE0B8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
	.DB	0			; MEDIA FLAGS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
	.DB	PPIDE0BASE  		; DATALO
	.DB	PPIDE0BASE+2		; CTL 
	.DB	PPIDE0BASE+3		; PPI
	.DW	PPIDE_DEV0M		; PARTNER
;
#ENDIF
;
#IF (PPIDECNT >= 2)
;
PPIDE_DEV1M:	; DEVICE 1, MASTER
	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
	.DB	0			; DEVICE STATUS
	.DB	0			; DEVICE TYPE
	.DB	PPIDE_ACC_MAS | (PPIDE1A8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
	.DB	0			; MEDIA FLAGS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
	.DB	PPIDE1BASE  		; DATALO
	.DB	PPIDE1BASE+2		; CTL 
	.DB	PPIDE1BASE+3		; PPI
	.DW	PPIDE_DEV1S		; PARTNER
;
PPIDE_DEV1S:	; DEVICE 1, SLAVE
	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
	.DB	0			; DEVICE STATUS
	.DB	0			; DEVICE TYPE
	.DB	(PPIDE1B8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
	.DB	0			; MEDIA FLAGS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
	.DB	PPIDE1BASE  		; DATALO
	.DB	PPIDE1BASE+2		; CTL 
	.DB	PPIDE1BASE+3		; PPI
	.DW	PPIDE_DEV1M		; PARTNER
;
#ENDIF
;
#IF (PPIDECNT >= 3)
;
PPIDE_DEV2M:	; DEVICE 2, MASTER
	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
	.DB	0			; DEVICE STATUS
	.DB	0			; DEVICE TYPE
	.DB	PPIDE_ACC_MAS | (PPIDE2A8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
	.DB	0			; MEDIA FLAGS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
	.DB	PPIDE2BASE  		; DATALO
	.DB	PPIDE2BASE+2		; CTL 
	.DB	PPIDE2BASE+3		; PPI
	.DW	PPIDE_DEV2S		; PARTNER
;	
PPIDE_DEV2S:	; DEVICE 2, SLAVE
	.DB	$FE			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
	.DB	0			; DEVICE STATUS
	.DB	0			; DEVICE TYPE
	.DB	(PPIDE2B8BIT & PPIDE_ACC_8BIT)	; UNIT ACCESS FLAGS
	.DB	0			; MEDIA FLAGS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
	.DB	PPIDE2BASE  		; DATALO
	.DB	PPIDE2BASE+2		; CTL 
	.DB	PPIDE2BASE+3		; PPI
	.DW	PPIDE_DEV2M		; PARTNER
;
#ENDIF
;
#IF ($ - PPIDE_CFGTBL) != (PPIDE_DEVCNT * PPIDE_CFGSIZ)
	.ECHO	"*** INVALID PPIDE CONFIG TABLE ***\n"
#ENDIF
;
	.DB	$FF			; END OF TABLE MARKER
;
; THE IDE_WAITXXX FUNCTIONS ARE BUILT TO TIMEOUT AS NEEDED SO DRIVER WILL
; NOT HANG IF DEVICE IS UNRESPONSIVE.  DIFFERENT TIMEOUTS ARE USED DEPENDING
; ON THE SITUATION.  GENERALLY, THE FAST TIMEOUT IS USED TO PROBE FOR DEVICES
; USING FUNCTIONS THAT PERFORM NO I/O.	OTHERWISE THE NORMAL TIMEOUT IS USED.
; IDE SPEC ALLOWS FOR UP TO 30 SECS MAX TO RESPOND.  IN PRACTICE, THIS IS WAY
; TOO LONG, BUT IF YOU ARE USING A VERY OLD DEVICE, THESE TIMEOUTS MAY NEED TO
; BE ADJUSTED.	NOTE THAT THESE ARE BYTE VALUES, SO YOU CANNOT EXCEED 255.
; THE TIMEOUTS ARE IN UNITS OF .05 SECONDS.
;
PPIDE_TONORM	.EQU	200		; NORMAL TIMEOUT IS 10 SECS
PPIDE_TOFAST	.EQU	10		; FAST TIMEOUT IS 0.5 SECS
;
;=============================================================================
; INITIALIZATION ENTRY POINT
;=============================================================================
;
PPIDE_INIT:
	; COMPUTE CPU SPEED COMPENSATED TIMEOUT SCALER
	; AT 1MHZ, THE SCALER IS 218 (50000US / 229TS = 218)
	; SCALER IS THEREFORE 218 * CPU SPEED IN MHZ
	LD	DE,218			; LOAD SCALER FOR 1MHZ
	LD	A,(CB_CPUMHZ)		; LOAD CPU SPEED IN MHZ
	CALL	MULT8X16		; HL := DE * A
	LD	(PPIDE_TOSCALER),HL	; SAVE IT
;
	XOR	A			; ZERO ACCUM
	LD	(PPIDE_DEVNUM),A	; INIT DEV UNIT NUM FOR DYNAMIC ASSIGNMENT
	LD	IY,PPIDE_CFGTBL		; POINT TO START OF CONFIG TABLE
;
PPIDE_INIT1:
	LD	A,(IY)			; LOAD FIRST BYTE TO CHECK FOR END
	CP	$FF			; CHECK FOR END OF TABLE VALUE
	JR	NZ,PPIDE_INIT2		; IF NOT END OF TABLE, CONTINUE
	XOR	A			; SIGNAL SUCCESS
	RET				; AND RETURN
;
PPIDE_INIT2:
	BIT	0,(IY+PPIDE_ACC)	; MASTER?
	JR	Z,PPIDE_INIT4		; IF NOT MASTER, SKIP AHEAD
;
	CALL	NEWLINE			; FORMATTING
	PRTS("PPIDE:$")			; LABEL FOR IO ADDRESS
;
	PRTS(" IO=0x$")			; LABEL FOR IO ADDRESS
	LD	A,(IY+PPIDE_DATALO)	; GET IO BASE ADDRES
	CALL	PRTHEXBYTE		; DISPLAY IT
;
	CALL	PPIDE_DETECT		; PROBE FOR INTERFACE
	JR	Z,PPIDE_INIT3		; GOT IT, MOVE ON TO INIT UNITS
	CALL	PC_SPACE		; FORMATTING
	LD	DE,PPIDE_STR_NOPPI	; NO PPI MESSAGE
	CALL	WRITESTR		; DISPLAY IT
	JR	PPIDE_INIT4		; SKIP CFG ENTRY
;	
PPIDE_INIT3:
	CALL	PPIDE_RESET		; RESET THE BUS
	CALL	PPIDE_INIT5		; DETECT/INIT MASTER
	PUSH	IY			; SAVE CFG PTR
	CALL	PPIDE_GOPARTNER		; SWITCH IY TO PARTNER CFG
	CALL	PPIDE_INIT5		; DETECT/INIT SLAVE
	POP	IY			; RESTORE CFG PTR
;	
PPIDE_INIT4:
	LD	DE,PPIDE_CFGSIZ		; SIZE OF CFG TABLE ENTRY
	ADD	IY,DE			; BUMP POINTER
	JR	PPIDE_INIT1		; AND LOOP
;
PPIDE_INIT5:
	; UPDATE DRIVER RELATIVE UNIT NUMBER IN CONFIG TABLE
	LD	A,(PPIDE_DEVNUM)	; GET NEXT UNIT NUM TO ASSIGN
	LD	(IY+PPIDE_DEV),A	; UPDATE IT
	INC	A			; BUMP TO NEXT UNIT NUM TO ASSIGN
	LD	(PPIDE_DEVNUM),A	; SAVE IT
;
	; ADD UNIT TO GLOBAL DISK UNIT TABLE
	LD	BC,PPIDE_FNTBL		; BC := FUNC TABLE ADR
	PUSH	IY			; CFG ENTRY POINTER
	POP	DE			; COPY TO DE
	CALL	DIO_ADDENT		; ADD ENTRY TO GLOBAL DISK DEV TABLE
;
	; CHECK FOR BAD STATUS
	LD	A,(IY+PPIDE_STAT)	; GET STATUS
	OR	A			; SET FLAGS
	JP	NZ,PPIDE_PRTSTAT	; EXIT VIA PRINT STATUS
;
	CALL	PPIDE_PRTPREFIX		; PRINT DEVICE PREFIX
;
	LD	DE,PPIDE_STR_8BIT
	BIT	1,(IY+PPIDE_ACC)	; 8 BIT ACCESS?
	CALL	NZ,WRITESTR
;
	; PRINT LBA/NOLBA
	CALL	PC_SPACE		; FORMATTING
	BIT	1,(IY+PPIDE_MED)	; TEST LBA FLAG
	LD	DE,PPIDE_STR_NO		; POINT TO "NO" STRING
	CALL	Z,WRITESTR		; PRINT "NO" BEFORE "LBA" IF LBA NOT SUPPORTED
	PRTS("LBA$")			; PRINT "LBA" REGARDLESS
;
	; PRINT STORAGE CAPACITY (BLOCK COUNT)
	PRTS(" BLOCKS=0x$")		; PRINT FIELD LABEL
	LD	A,PPIDE_MEDCAP		; OFFSET TO CAPACITY FIELD
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	LD32			; GET THE CAPACITY VALUE
	CALL	PRTHEX32		; PRINT HEX VALUE
;
	; PRINT STORAGE SIZE IN MB
	PRTS(" SIZE=$")			; PRINT FIELD LABEL
	LD	B,11			; 11 BIT SHIFT TO CONVERT BLOCKS --> MB
	CALL	SRL32			; RIGHT SHIFT
;	CALL	PRTDEC			; PRINT LOW WORD IN DECIMAL (HIGH WORD DISCARDED)
	CALL	PRTDEC32		; PRINT DWORD IN DECIMAL
	PRTS("MB$")			; PRINT SUFFIX
;
	RET
;
;----------------------------------------------------------------------
; PROBE FOR PPI HARDWARE
;----------------------------------------------------------------------
;
; ON RETURN, ZF SET INDICATES HARDWARE FOUND
;
PPIDE_DETECT:
;
	; TEST FOR PPI EXISTENCE
	; WE SETUP THE PPI TO WRITE, THEN WRITE A VALUE OF ZERO
	; TO PORT A (DATALO), THEN READ IT BACK.  IF THE PPI IS THERE
	; THEN THE BUS HOLD CIRCUITRY WILL READ BACK THE ZERO. SINCE
	; WE ARE IN WRITE MODE, AN IDE CONTROLLER WILL NOT BE ABLE TO
	; INTERFERE WITH THE VALUE BEING READ.
;
	LD	A,PPIDE_DIR_WRITE	; SET DATA BUS DIRECTION TO WRITE
	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
	OUT	(C),A			; WRITE IT
;
	LD	C,(IY+PPIDE_DATALO)	; PPI PORT A, DATALO
	XOR	A			; VALUE ZERO
	OUT	(C),A			; PUSH VALUE TO PORT
	IN	A,(C)			; GET PORT VALUE
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	OR	A			; SET FLAGS
	RET				; AND RETURN
;
;=============================================================================
; DRIVER FUNCTION TABLE
;=============================================================================
;
PPIDE_FNTBL:
	.DW	PPIDE_STATUS
	.DW	PPIDE_RESET
	.DW	PPIDE_SEEK
	.DW	PPIDE_READ
	.DW	PPIDE_WRITE
	.DW	PPIDE_VERIFY
	.DW	PPIDE_FORMAT
	.DW	PPIDE_DEVICE
	.DW	PPIDE_MEDIA
	.DW	PPIDE_DEFMED
	.DW	PPIDE_CAP
	.DW	PPIDE_GEOM
#IF (($ - PPIDE_FNTBL) != (DIO_FNCNT * 2))
	.ECHO	"*** INVALID PPIDE FUNCTION TABLE ***\n"
#ENDIF
;
PPIDE_VERIFY:
PPIDE_FORMAT:
PPIDE_DEFMED:
	SYSCHKERR(ERR_NOTIMPL)		; NOT IMPLEMENTED
	RET
;
;
;
PPIDE_READ:
	CALL	HB_DSKREAD		; HOOK HBIOS DISK READ SUPERVISOR
	LD	BC,PPIDE_RDSEC		; GET ADR OF SECTOR READ FUNC
	LD	(PPIDE_IOFNADR),BC	; SAVE IT AS PENDING IO FUNC
	JR	PPIDE_IO		; CONTINUE TO GENERIC IO ROUTINE
;
;
;
PPIDE_WRITE:
	CALL	HB_DSKWRITE		; HOOK HBIOS DISK WRITE SUPERVISOR
	LD	BC,PPIDE_WRSEC		; GET ADR OF SECTOR WRITE FUNC
	LD	(PPIDE_IOFNADR),BC	; SAVE IT AS PENDING IO FUNC
	JR	PPIDE_IO		; CONTINUE TO GENERIC IO ROUTINE
;
;
;
PPIDE_IO:
	LD	(PPIDE_DSKBUF),HL	; SAVE DISK BUFFER ADDRESS
	LD	A,E			; BLOCK COUNT TO A
	OR	A			; SET FLAGS
	RET	Z			; ZERO SECTOR I/O, RETURN W/ E=0 & A=0
	LD	B,A			; INIT SECTOR DOWNCOUNTER
	LD	C,0			; INIT SECTOR READ/WRITE COUNT
#IF (PPIDETRACE == 1)
	LD	HL,PPIDE_PRTERR		; SET UP PPIDE_PRTERR
	PUSH	HL			; ... TO FILTER ALL EXITS
#ENDIF
	PUSH	BC			; SAVE COUNTERS
	CALL	PPIDE_SELUNIT		; HARDWARE SELECTION OF TARGET UNIT
	CALL	PPIDE_CHKERR		; CHECK FOR ERR STATUS AND RESET IF SO
	POP	BC			; RESTORE COUNTERS
	JR	NZ,PPIDE_IO3		; BAIL OUT ON ERROR
PPIDE_IO1:
	PUSH	BC			; SAVE COUNTERS
	LD	HL,(PPIDE_IOFNADR)	; GET PENDING IO FUNCTION ADDRESS
	CALL	JPHL			; ... AND CALL IT
	JR	NZ,PPIDE_IO2		; IF ERROR, SKIP INCREMENT
	; INCREMENT LBA
	LD	A,PPIDE_LBA		; LBA OFFSET
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	INC32HL			; INCREMENT THE VALUE
	; INCREMENT DMA
	LD	HL,PPIDE_DSKBUF+1	; POINT TO MSB OF BUFFER ADR
	INC	(HL)			; BUMP DMA BY
	INC	(HL)			; ... 512 BYTES
	XOR	A			; SIGNAL SUCCESS
PPIDE_IO2:
	POP	BC			; RECOVER COUNTERS
	JR	NZ,PPIDE_IO3		; IF ERROR, BAIL OUT
	INC	C			; BUMP COUNT OF SECTORS READ
	DJNZ	PPIDE_IO1		; LOOP AS NEEDED
PPIDE_IO3:
	LD	E,C			; SECTOR READ COUNT TO E
	LD	HL,(PPIDE_DSKBUF)	; CURRENT DMA TO HL
	OR	A			; SET FLAGS BASED ON RETURN CODE
	RET	Z			; RETURN IF SUCCESS
	LD	A,ERR_IO		; SIGNAL IO ERROR
	OR	A			; SET FLAGS
	RET				; AND DONE
;
;
;
PPIDE_STATUS:
	; RETURN UNIT STATUS
	LD	A,(IY+PPIDE_STAT)	; GET STATUS OF SELECTED DEVICE
	OR	A			; SET FLAGS
	RET				; AND RETURN
;
;
;
PPIDE_DEVICE:
	LD	D,DIODEV_PPIDE		; D := DEVICE TYPE
	LD	E,(IY+PPIDE_DEV)	; E := PHYSICAL DEVICE NUMBER
	BIT	0,(IY+PPIDE_MED)	; TEST CF BIT IN FLAGS
	LD	C,%00000000		; ASSUME NON-REMOVABLE HARD DISK
	JR	Z,PPIDE_DEVICE1		; IF Z, WE ARE DONE
	LD	C,%01001000		; OTHERWISE REMOVABLE COMPACT FLASH
PPIDE_DEVICE1:
	LD	H,0			; H := 0, DRIVER HAS NO MODES
	LD	L,(IY+PPIDE_DATALO)	; L := BASE I/O ADDRESS
	XOR	A			; SIGNAL SUCCESS
	RET
;
; IDE_GETMED
;
PPIDE_MEDIA:
	LD	A,E			; GET FLAGS
	OR	A			; SET FLAGS
	JR	Z,PPIDE_MEDIA2		; JUST REPORT CURRENT STATUS AND MEDIA
;
	; GET CURRENT STATUS
	LD	A,(IY+PPIDE_STAT)	; GET STATUS
	OR	A			; SET FLAGS
	JR	NZ,PPIDE_MEDIA1		; ERROR ACTIVE, GO RIGHT TO RESET
;
	; USE IDENTIFY COMMAND TO CHECK DEVICE
	LD	HL,PPIDE_TIMEOUT	; POINT TO TIMEOUT
	LD	(HL),PPIDE_TOFAST	; USE FAST TIMEOUT DURING IDENTIFY COMMAND
	CALL	PPIDE_SELUNIT		; HARDWARE SELECTION OF TARGET UNIT
	CALL	PPIDE_IDENTIFY		; EXECUTE IDENTIFY COMMAND
	LD	HL,PPIDE_TIMEOUT	; POINT TO TIMEOUT
	LD	(HL),PPIDE_TONORM	; BACK TO NORMAL TIMEOUT
	JR	Z,PPIDE_MEDIA2		; IF SUCCESS, BYPASS RESET
;
PPIDE_MEDIA1:
	CALL	PPIDE_RESET		; RESET IDE INTERFACE
;
PPIDE_MEDIA2:
	LD	A,(IY+PPIDE_STAT)	; GET STATUS
	OR	A			; SET FLAGS
	LD	D,0			; NO MEDIA CHANGE DETECTED
	LD	E,MID_HD		; ASSUME WE ARE OK
	RET	Z			; RETURN IF GOOD INIT
	LD	E,MID_NONE		; SIGNAL NO MEDIA
	LD	A,ERR_NOMEDIA		; NO MEDIA ERROR
	OR	A			; SET FLAGS
	RET				; AND RETURN
;
;
;
PPIDE_SEEK:
	BIT	7,D			; CHECK FOR LBA FLAG
	CALL	Z,HB_CHS2LBA		; CLEAR MEANS CHS, CONVERT TO LBA
	RES	7,D			; CLEAR FLAG REGARDLESS (DOES NO HARM IF ALREADY LBA)
	LD	(IY+PPIDE_LBA+0),L	; SAVE NEW LBA
	LD	(IY+PPIDE_LBA+1),H	; ...
	LD	(IY+PPIDE_LBA+2),E	; ...
	LD	(IY+PPIDE_LBA+3),D	; ...
	XOR	A			; SIGNAL SUCCESS
	RET				; AND RETURN
;
;
;
PPIDE_CAP:
	LD	A,(IY+PPIDE_STAT)	; GET STATUS
	PUSH	AF			; SAVE IT
	LD	A,PPIDE_MEDCAP		; OFFSET TO CAPACITY FIELD
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	LD32			; GET THE CURRENT CAPACITY INTO DE:HL
	LD	BC,512			; 512 BYTES PER BLOCK
	POP	AF			; RECOVER STATUS
	OR	A			; SET FLAGS
	RET
;
;
;
PPIDE_GEOM:
	; FOR LBA, WE SIMULATE CHS ACCESS USING 16 HEADS AND 16 SECTORS
	; RETURN HS:CC -> DE:HL, SET HIGH BIT OF D TO INDICATE LBA CAPABLE
	CALL	PPIDE_CAP		; GET TOTAL BLOCKS IN DE:HL, BLOCK SIZE TO BC
	LD	L,H			; DIVPPIDE BY 256 FOR # TRACKS
	LD	H,E			; ... HIGH BYTE DISCARDED, RESULT IN HL
	LD	D,16 | $80		; HEADS / CYL = 16, SET LBA CAPABILITY BIT
	LD	E,16			; SECTORS / TRACK = 16
	RET				; DONE, A STILL HAS PPIDE_CAP STATUS
;
;=============================================================================
; FUNCTION SUPPORT ROUTINES
;=============================================================================
;
;
;
PPIDE_SETFEAT:
	PUSH	AF
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_PRTPREFIX
	PRTS(" SETFEAT$")
#ENDIF
	LD	A,(PPIDE_DRVHD)
	;OUT	(PPIDE_REG_DRVHD),A
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_DRVHD
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	POP	AF
	;OUT	(PPIDE_REG_FEAT),A	; SET THE FEATURE VALUE
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_FEAT
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	LD	A,PPIDE_CMD_SETFEAT	; CMD = SETFEAT
	LD	(PPIDE_CMD),A		; SAVE IT
	JP	PPIDE_RUNCMD		; RUN COMMAND AND EXIT
;
;
;
PPIDE_IDENTIFY:
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_PRTPREFIX
	PRTS(" IDDEV$")
#ENDIF
	LD	A,(PPIDE_DRVHD)
	;OUT	(PPIDE_REG_DRVHD),A
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_DRVHD
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	LD	A,PPIDE_CMD_IDDEV
	LD	(PPIDE_CMD),A
	CALL	PPIDE_RUNCMD
	RET	NZ
	LD	HL,HB_WRKBUF
	JP	PPIDE_GETBUF		; EXIT THRU BUFRD
;
;
;
PPIDE_RDSEC:
;
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_PRTPREFIX
	PRTS(" READ$")
#ENDIF
	LD	A,(PPIDE_DRVHD)
	;OUT	(PPIDE_REG_DRVHD),A
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_DRVHD
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CALL	PPIDE_SETADDR		; SETUP CYL, TRK, HEAD
	LD	A,PPIDE_CMD_READ
	LD	(PPIDE_CMD),A
	CALL	PPIDE_RUNCMD
	RET	NZ
	LD	HL,(PPIDE_DSKBUF)
	JP	PPIDE_GETBUF
;
;
;
PPIDE_WRSEC:
;
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_PRTPREFIX
	PRTS(" WRITE$")
#ENDIF
	LD	A,(PPIDE_DRVHD)
	;OUT	(PPIDE_REG_DRVHD),A
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_DRVHD
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CALL	PPIDE_SETADDR		; SETUP CYL, TRK, HEAD
	LD	A,PPIDE_CMD_WRITE
	LD	(PPIDE_CMD),A
	CALL	PPIDE_RUNCMD
	RET	NZ
	LD	HL,(PPIDE_DSKBUF)
	JP	PPIDE_PUTBUF
;
;
;
PPIDE_SETADDR:
;
#IF (DSKYENABLE)
	LD	A,PPIDE_LBA
	CALL	LDHLIYA
	CALL	HB_DSKACT		; SHOW ACTIVITY
#ENDIF
	; SEND 3 LOWEST BYTES OF LBA IN REVERSE ORDER
	; IDE_IO_LBA3 HAS ALREADY BEEN SET
	; HSTLBA2-0 --> IDE_IO_LBA2-0
	LD	A,(IY+PPIDE_LBA+2)
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_LBA2
;
	LD	A,(IY+PPIDE_LBA+1)
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_LBA1
;
	LD	A,(IY+PPIDE_LBA+0)
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_LBA0
;
	LD	A,1
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_COUNT
;
;;#IF (DSKYENABLE)
;;	CALL	PPIDE_DSKY
;;#ENDIF
;
	RET
;
;=============================================================================
; COMMAND PROCESSING
;=============================================================================
;
PPIDE_RUNCMD:
	CALL	PPIDE_WAITRDY		; WAIT FOR DRIVE READY
	RET	NZ			; BAIL OUT ON TIMEOUT
;
	LD	A,(PPIDE_CMD)		; GET THE COMMAND
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	;OUT	(PPIDE_REG_CMD),A	; SEND IT (STARTS EXECUTION)
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_CMD
#IF (PPIDETRACE >= 3)
	PRTS(" -->$")
#ENDIF
;
	CALL	PPIDE_WAITBSY		; WAIT FOR DRIVE READY (COMMAND DONE)
	RET	NZ			; BAIL OUT ON TIMEOUT
;
	CALL	PPIDE_GETRES
	JP	NZ,PPIDE_CMDERR
	RET
;
;
;
PPIDE_GETBUF:
#IF (PPIDETRACE >= 3)
	PRTS(" GETBUF$")
#ENDIF
;
	; WAIT FOR BUFFER
	CALL	PPIDE_WAITDRQ		; WAIT FOR BUFFER READY
	RET	NZ			; BAIL OUT IF TIMEOUT
;
	; SETUP PPI TO READ
	LD	A,PPIDE_DIR_READ	; SET DATA BUS DIRECTION TO READ
	;OUT	(PPIDE_IO_PPI),A	; DO IT
	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
	OUT	(C),A			; WRITE IT
;
	; SELECT READ/WRITE IDE REGISTER
	LD	A,PPIDE_REG_DATA	; DATA REGISTER
	;OUT	(PPIDE_IO_CTL),A	; DO IT
	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
	OUT	(C),A			; DO IT
	LD	E,A			; E := READ UNASSERTED
	XOR	PPIDE_CTL_DIOR		; SWAP THE READ LINE BIT
	LD	D,A			; D := READ ASSERTED
;
	; LOOP SETUP
	XOR	A			; IMPORTANT, NEEDED FOR LOOP END COMPARISON
	LD	B,0			; 256 ITERATIONS
	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
;
	BIT	1,(IY+PPIDE_ACC)	; 8 BIT?
	JR	Z,PPIDE_GETBUF1		; IF NOT, DO 16 BIT
	CALL	PPIDE_GETBUF8		; FIRST PASS (FIRST 256 BYTES)
	CALL	PPIDE_GETBUF8		; SECOND PASS (LAST 256 BYTES)
	JR	PPIDE_GETBUF2		; CONTINUE
PPIDE_GETBUF1:
	CALL	PPIDE_GETBUF16		; FIRST PASS (FIRST 256 BYTES)
	CALL	PPIDE_GETBUF16		; SECOND PASS (LAST 256 BYTES)
PPIDE_GETBUF2:
	CALL	PPIDE_WAITRDY		; PROBLEMS IF THIS IS REMOVED!
	RET	NZ
	CALL	PPIDE_GETRES
	JP	NZ,PPIDE_IOERR
	RET
;
PPIDE_GETBUF8:	; 8 BIT WIDE READ LOOP
	; ENTER W/ C = PPIDE_IO_CTL
	OUT	(C),D			; ASSERT READ
	DEC	C			; CTL -> MSB
	DEC	C			; MSB -> LSB
	INI				; READ FROM LSB
	INC	C			; LSB -> MSB
	INC	C			; MSB -> CTL
	OUT	(C),E			; DEASSERT READ
	CP	B			; B == A == 0?
	JR	NZ,PPIDE_GETBUF8	; LOOP UNTIL DONE
	RET
;
PPIDE_GETBUF16:	; 16 BIT WIDE READ LOOP
	; ENTER W/ C = PPIDE_IO_CTL
	OUT	(C),D			; ASSERT READ
	DEC	C			; CTL -> MSB
	DEC	C			; MSB -> LSB
	INI				; READ FROM LSB
	INC	C			; LSB -> MSB
	INI				; READ MSB FOR 16 BIT
	INC	C			; MSB -> CTL
	OUT	(C),E			; DEASSERT READ
	CP	B			; B == A == 0?
	JR	NZ,PPIDE_GETBUF16	; LOOP UNTIL DONE
	RET
;
;
;
PPIDE_PUTBUF:
#IF (PPIDETRACE >= 3)
	PRTS(" PUTBUF$")
#ENDIF
;
	; WAIT FOR BUFFER
	CALL	PPIDE_WAITDRQ		; WAIT FOR BUFFER READY
	RET	NZ			; BAIL OUT IF TIMEOUT
;
	; SETUP PPI TO WRITE
	LD	A,PPIDE_DIR_WRITE	; SET DATA BUS DIRECTION TO WRITE
	;OUT	(PPIDE_IO_PPI),A	; DO IT
	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
	OUT	(C),A			; WRITE IT
;
	; SELECT READ/WRITE IDE REGISTER
	LD	A,PPIDE_REG_DATA	; DATA REGISTER
	;OUT	(PPIDE_IO_CTL),A	; DO IT
	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
	OUT	(C),A			; DO IT
	LD	E,A			; E := WRITE UNASSERTED
	XOR	PPIDE_CTL_DIOW		; SWAP THE READ LINE BIT
	LD	D,A			; D := WRITE ASSERTED
;
	; LOOP SETUP
	XOR	A			; IMPORTANT, NEEDED FOR LOOP END COMPARISON
	LD	B,0			; 256 ITERATIONS
	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
;
	BIT	1,(IY+PPIDE_ACC)	; 8 BIT?
	JR	Z,PPIDE_PUTBUF1		; IF NOT, DO 16 BIT
	CALL	PPIDE_PUTBUF8		; FIRST PASS (FIRST 256 BYTES)
	CALL	PPIDE_PUTBUF8		; SECOND PASS (LAST 256 BYTES)
	JR	PPIDE_PUTBUF2		; CONTINUE
PPIDE_PUTBUF1:
	CALL	PPIDE_PUTBUF16		; FIRST PASS (FIRST 256 BYTES)
	CALL	PPIDE_PUTBUF16		; SECOND PASS (LAST 256 BYTES)
PPIDE_PUTBUF2:
	CALL	PPIDE_WAITRDY		; PROBLEMS IF THIS IS REMOVED!
	RET	NZ
	CALL	PPIDE_GETRES
	JP	NZ,PPIDE_IOERR
	RET
;
PPIDE_PUTBUF8:	; 8 BIT WIDE WRITE LOOP
	DEC	C			; CTL -> MSB
	DEC	C			; MSB -> LSB
	OUTI				; WRITE NEXT BYTE (LSB)
	INC	C			; LSB -> MSB
	INC	C			; MSB -> CTL
	OUT	(C),D			; ASSERT WRITE
	OUT	(C),E			; DEASSERT WRITE
	CP	B			; B == A == 0?
	JR	NZ,PPIDE_PUTBUF8	; LOOP UNTIL DONE
	RET
;
PPIDE_PUTBUF16:	; 16 BIT WIDE WRITE LOOP
	DEC	C			; CTL -> MSB
	DEC	C			; MSB -> LSB
	OUTI				; WRITE NEXT BYTE (LSB)
	INC	C			; LSB -> MSB
	OUTI				; WRITE NEXT BYTE (MSB)
	INC	C			; MSB -> CTL
	OUT	(C),D			; ASSERT WRITE
	OUT	(C),E			; DEASSERT WRITE
	CP	B			; B == A == 0?
	JR	NZ,PPIDE_PUTBUF16	; LOOP UNTIL DONE
	RET
;
;
;
PPIDE_GETRES:
	;IN	A,(PPIDE_REG_STAT)	; READ STATUS
	CALL	PPIDE_IN
	.DB	PPIDE_REG_STAT
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	AND	%00000001		; ERROR BIT SET?
	RET	Z			; NOPE, RETURN WITH ZF
;
	;IN	A,(PPIDE_REG_ERR)	; READ ERROR REGISTER
	CALL	PPIDE_IN
	.DB	PPIDE_REG_ERR
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	OR	$FF			; FORCE NZ TO SIGNAL ERROR
	RET				; RETURN
;
;=============================================================================
; HARDWARE INTERFACE ROUTINES
;=============================================================================
;
; SOFT RESET OF ALL DEVICES ON BUS
;
PPIDE_RESET:
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_PRTPREFIX
	PRTS(" RESET$")
#ENDIF
;
	; SETUP PPI TO READ
	LD	A,PPIDE_DIR_READ	; SET DATA BUS DIRECTION TO READ
	;OUT	(PPIDE_IO_PPI),A	; DO IT
	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
	OUT	(C),A			; WRITE IT
;
; IF A DSKYNG IS ACTIVE AND IS ON THE SAME PPI PORT AS THE PPISD BEING
; RESET, THEN THE DSKYNG WILL ALSO BE RESET.  SO, THE RESET CODE IS
; BRACKETED WITH CODE TO SAVE AND RESTORE THE STATE OF THE DSKYNG.
; THERE IS NO CHECK FOR THE SPECIFIC PPI PORT SINCE IT DOES NO HARM
; IF THE DSKYNG IS SAVED AND RESTORED.
;
#IF (DSKYENABLE)
  #IF (DSKYMODE == DSKYMODE_NG)
	; SAVE CONTENTS OF DSKY DISPLAY ACROSS RESET
	LD	B,8
	LD	C,0
	LD	HL,DSKY_BUF
	CALL	DSKY_GETSTR
  #ENDIF
#ENDIF
;
	; PULSE IDE RESET LINE
#IF (IDETRACE >= 3)
	PRTS(" HARD$")
#ENDIF
	LD	A,PPIDE_CTL_RESET
	;OUT	(PPIDE_IO_CTL),A
	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
	OUT	(C),A
	LD	DE,20
	CALL	VDELAY
	XOR	A
	;OUT	(PPIDE_IO_CTL),A
	OUT	(C),A
	LD	DE,20
	CALL	VDELAY
;	
#IF (DSKYENABLE)
  #IF (DSKYMODE == DSKYMODE_NG)
	; REININT DSKY AND RESTORE CONTENTS
	CALL	DSKY_REINIT
	LD	B,8
	LD	C,0
	LD	HL,DSKY_BUF
	CALL	DSKY_PUTSTR
  #ENDIF
#ENDIF
;
	; CONFIGURE OPERATION
#IF (PPIDETRACE >= 3)
	PRTS(" CONFIG$")
#ENDIF
	LD	A,%00001010		; SET ~IEN, NO INTERRUPTS
	;OUT	(PPIDE_REG_CTRL),A
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_CTRL
;
; SPEC ALLOWS UP TO 450MS FOR DEVICES TO ASSERT THEIR PRESENCE
; VIA -DASP.  I ENCOUNTER PROBLEMS LATER ON IF I DON'T WAIT HERE
; FOR THAT TO OCCUR.  THUS FAR, IT APPEARS THAT 150MS IS SUFFICIENT
; FOR ANY DEVICE ENCOUNTERED.  MAY NEED TO EXTEND BACK TO 500MS
; IF A SLOWER DEVICE IS ENCOUNTERED.
;
	;LD	DE,500000/16		; ~500MS
	LD	DE,150000/16		; ~???MS
	CALL	VDELAY
;
	; INITIALIZE THE INDIVIDUAL UNITS (MASTER AND SLAVE).
	; BASED ON TESTING, IT APPEARS THAT THE MASTER UNIT MUST
	; BE DONE FIRST OR THIS BEHAVES BADLY.
	PUSH	IY			; SAVE CFG PTR
	BIT	0,(IY+PPIDE_ACC)	; MASTER?
	CALL	Z,PPIDE_GOPARTNER	; IF NOT, SWITCH TO MASTER
	CALL	PPIDE_INITUNIT		; INIT CURRENT UNIT
	CALL	PPIDE_GOPARTNER		; POINT TO SLAVE
	CALL	PPIDE_INITUNIT		; INIT PARTNER UNIT
	POP	IY			; RECOVER ORIG CFG PTR
;	
	XOR	A			; SIGNAL SUCCESS
	RET				; AND DONE
;
;
;
PPIDE_INITUNIT:
	CALL	PPIDE_SELUNIT		; SELECT UNIT
	RET	NZ			; ABORT IF ERROR

	LD	HL,PPIDE_TIMEOUT	; POINT TO TIMEOUT
	LD	(HL),PPIDE_TONORM	; SET NORMAL TIMEOUT

	CALL	PPIDE_PROBE		; DO PROBE
	RET	NZ			; JUST RETURN IF NOTHING THERE

	CALL	PPIDE_INITDEV		; IF FOUND, ATTEMPT TO INIT DEVICE
	RET				; DONE
;
; TAKE ANY ACTIONS REQUIRED TO SELECT DESIRED PHYSICAL UNIT
;
PPIDE_SELUNIT:
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_PRTPREFIX
	PRTS(" SELUNIT$")
#ENDIF
	BIT	0,(IY+PPIDE_ACC)	; MASTER?
	JR	Z,PPIDE_SELUNIT1	; HANDLE SLAVE
	LD	A,PPIDE_DRVMASTER	; MASTER
	JR	PPIDE_SELUNIT2          
PPIDE_SELUNIT1:                         
	LD	A,PPIDE_DRVSLAVE	; SLAVE
PPIDE_SELUNIT2:                         
	LD	(PPIDE_DRVHD),A		; SAVE IT
	XOR	A			; SUCCESS
	RET
;
;
;
PPIDE_PROBE:
;
; PROBE FOR A DRIVE ON THE INTERFACE (EITHER MASTER OR SLAVE).
; IDEALLY, THIS IS BEING CALLED IMMEDIATELY AFTER A HARD OR SOFT
; INTERFACE RESET.  HOWEVER, THERE ARE SOME HARDWARE IMPLEMENTATTIONS
; WHICH ARE NOT CAPABLE OF EITHER A HARD NOR SOFT RESET.  SO THIS
; CODE SHOULD TRY TO HANDLE THE SCENARIO WHERE NO INTERFACE RESET
; HAS OCCURRED.
;
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_PRTPREFIX
	PRTS(" PROBE$")			; LABEL FOR IO ADDRESS
#ENDIF
;
	; SELECT DEVICE (MASTER/SLAVE)
	LD	A,(PPIDE_DRVHD)
	;OUT	(IDE_IO_DRVHD),A
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_DRVHD
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CALL	DELAY			; DELAY ~16US
;
; IF WE GET HERE AND THE INTERFACE IS STILL INITIALIZING, WE NEED TO
; WAIT UNTIL THE INTERFACE IS READY.  PER SPEC, THE STATUS REGISTER
; WILL BE EXACTLY $80 IN THIS SCENARIO.  SINCE $80 IS UNLIKELY
; FOR A FLOATING PORT VALUE, WE INTERPRET THIS VALUE TO MEAN HARDWARE
; IS THERE AND INIT IS IN PROGRESS, SO IT WILL BE IMPOSSIBLE TO
; INTERROGATE REGISTERS YET.  SINCE WE NOW BELIEVE THAT SOME HARDWARE
; IS RESPONDING, IT IS SAFE (AND NECESSARY) TO WAIT FOR BUSY TO
; CLEAR.
;
	CALL	PPIDE_IN
	.DB	PPIDE_REG_STAT
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CP	$80			; INIT IN PROGRESS?
	CALL	Z,PPIDE_WAITBSY		; WAIT FOR BUSY TO CLEAR
;
; TEST FOR PRESENCE OF IDE REGISTERS.  USE LBA0/1 TO SEE
; IF VALUE CAN BE PERSISTED.  THE USE OF BOTH LBA0 AND LBA1
; IS TO MAINTAIN CONSISTENCY WITH TGHE THE PPIDE DRIVER BECAUSE
; PPI ITSELF WILL PERSIST THE LAST VALUE WRITTEN, SO WE USE
; MULTIPLE REGISTERS TO WORK AROUND THIS FALSE POSITIVE.
;
	; $AA -> LBA0
	LD	A,$AA
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_LBA0
;	
	; $55 => LBA1
	LD	A,$55
	CALL	PPIDE_OUT
	.DB	PPIDE_REG_LBA1
;
	; TEST LBA0 == $AA
	CALL	PPIDE_IN
	.DB	PPIDE_REG_LBA0
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CP	$AA
	JP	NZ,PPIDE_NOMEDIA
;
	; TEST LBA1 == $55
	CALL	PPIDE_IN
	.DB	PPIDE_REG_LBA1
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
#ENDIF
	CP	$55
	JP	NZ,PPIDE_NOMEDIA
;
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_REGDUMP
#ENDIF
;
	CALL	PPIDE_WAITBSY		; WAIT FOR BUSY TO CLEAR
	JP	NZ,PPIDE_NOMEDIA	; CONVERT TIMEOUT TO NO MEDIA AND RETURN
;
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_REGDUMP
#ENDIF
;
; IF THE INTERFACE HAS A MASTER AND NO SLAVE, THEN THE ABOVE CHECKS
; MAY ALL SUCCEED WHEN PROBING FOR THE SLAVE.  HOWEVER, THE STATUS
; BYTE FOR THE SLAVE WILL REMAIN $00, SO WE LOOK FOR THAT VALUE AS A
; FINAL WAY TO DETECT NO MEDIA.
;
	; CHECK STATUS
;	IN	A,(PPIDE_REG_STAT)	; GET STATUS
	CALL	PPIDE_IN
	.DB	PPIDE_REG_STAT
#IF (PPIDETRACE >= 3)
	CALL	PC_SPACE
	CALL	PRTHEXBYTE		; IF DEBUG, PRINT STATUS
#ENDIF
	OR	A			; SET FLAGS TO TEST FOR ZERO
	JP	Z,PPIDE_NOMEDIA		; CONTINUE IF NON-ZERO
;
	; ASSUME ATA DEVICE FOR NOW, RECORD TYPE AND RETURN SUCCESS
	LD	A,PPIDE_TYPEATA		; TYPE = ATA
	LD	(IY+PPIDE_TYPE),A	; SET IT IN INSTANCE DATA
	XOR	A			; SIGNAL SUCCESS
	RET				; DONE, NOTE THAT A=0 AND Z IS SET
;
; (RE)INITIALIZE DEVICE
;
PPIDE_INITDEV:
;
	LD	A,(IY+PPIDE_TYPE)	; GET THE DEVICE TYPE
	OR	A			; SET FLAGS
	JP	Z,PPIDE_NOMEDIA		; EXIT SETTING NO MEDIA STATUS
;
	BIT	1,(IY+PPIDE_ACC)	; 8 BIT ACCESS?
	JR	Z,PPIDE_INITDEV0	; NO, DO 16 BIT INIT
	LD	A,PPIDE_FEAT_ENABLE8BIT	; FEATURE VALUE = ENABLE 8-BIT PIO
	CALL	PPIDE_SETFEAT		; SET FEATURE
	RET	NZ			; BAIL OUT ON ERROR
	JR	PPIDE_INITDEV00		; CONTINUE
;
PPIDE_INITDEV0:
	; "REAL" IDE DRIVES MAY NOT ACCEPT THE DISABLE8BIT FEATURE COMMAND,
	; SO IT IS ONLY AN ERROR IF WE ARE ATTEMPTING TO ENABLE8BIT.
	; CREDIT TO ED BRINDLEY FOR THIS CORRECTION.  SO ERROR RETURN IGNORED HERE.
	LD	A,PPIDE_FEAT_DISABLE8BIT	; FEATURE VALUE = ENABLE 8-BIT PIO
	CALL	PPIDE_SETFEAT		; SET FEATURE, IGNORE ERRORS
;
PPIDE_INITDEV00:
;
	CALL	PPIDE_IDENTIFY		; EXECUTE PPIDENTIFY COMMAND
	RET	NZ			; BAIL OUT ON ERROR
;
	LD	DE,HB_WRKBUF		; POINT TO BUFFER
#IF (PPIDETRACE >= 3)
	CALL	DUMP_BUFFER		; DUMP IT IF DEBUGGING
#ENDIF
;
	LD	(IY+PPIDE_MED),0	; CLEAR MEDIA FLAGS
;
	; DETERMINE IF CF DEVICE BY TESTING FOR CF CARD SIGNATURES
	; IN THEORY, THERE ARE SOME OTHER POSSIBLE VARIATIONS, BUT
	; THEY ARE NOT RECOMMENDED BY THE CF CARD SPEC AND MIGHT
	; OVERLAP WITH "REAL" HARD DISK SIGNATURES.  I HAVE NEVER
	; SEEN A CF CARD THAT DID NOT USE ONE OF THE BELOW.
	; CREDIT TO LASZLO SZOLNOKI
;
#IF (PPIDETRACE >= 3)
	CALL	PPIDE_PRTPREFIX
	PRTS(" SIG=0x$")
	LD	BC,(HB_WRKBUF)
	CALL	PRTHEXWORD
#ENDIF
;
; SEE PAGE 114 OF CF+ & CF SPECIFICATION REV. 3.0 FOR CF CARD
; SIGNATURE VALUES.  ALL OF THE BELOW ARE DOCUMENTED THERE EXCEPT
; $045A WHICH IS A VALUE DISCOVERED ON A CF<->SD CARD ADAPTER.
;
; SIGNATURE $045A IS NOT LISTED IN THE CF SPEC.  IT WAS ADDED BECAUSE
; IT WAS SEEN IN THE WILD ON A CF-SD ADAPTER.  HOWEVER IT HAS NOW
; ALSO BEEN SEEN ON A SPINNING HARD DISK.  SINCE IT IS AMBIGUOUS, I
; WILL CONSIDER IT TO BE A HARD DISK.
;
	LD	BC,$848A		; STANDARD CF CARD SIGNATURE	%1000 1111 1000 1010
	CALL	PPIDE_INITDEV000	; TEST & SET
	LD	BC,$044A		; ALT SIG FOR CF NON-REMOVABLE	%0000 0100 0100 1010
	CALL	PPIDE_INITDEV000	; TEST & SET
	;LD	BC,$045A		; ?ALT SIG FOR CF NON-REMOVABLE	%0000 0100 0101 1010
	;CALL	PPIDE_INITDEV000	; TEST & SET
	LD	BC,$0040		; ALT SIG FOR CF NON-REMOVABLE	%0000 0000 0100 0000
	CALL	PPIDE_INITDEV000	; TEST & SET
	JR	PPIDE_INITDEV1		; CONTINUE INIT
;
PPIDE_INITDEV000:
	; CHECK IF FIRST WORD OF IDENTIFY DATA MATCHES VALUE IN BC
	; AND SET CF FLAG IF SO
	LD	HL,(HB_WRKBUF)		; FIRST WORD OF IDENTIFY DATA
	OR	A			; CLEAR CARRY
	SBC	HL,BC			; COMPARE
	RET	NZ			; ABORT IF NOT EQUAL
	SET	0,(IY+PPIDE_MED)	; ELSE SET FLAGS BIT FOR CF MEDIA
	RET				; AND RETURN
;
PPIDE_INITDEV1:
	; DETERMINE IF LBA CAPABLE
	LD	A,(HB_WRKBUF+98+1)	; GET BYTE WITH LBA BIT FROM BUFFER
	BIT	1,A			; CHECK THE LBA BIT
	JR	Z,PPIDE_INITDEV2	; NOT SET, BYPASS
	SET	1,(IY+PPIDE_MED)	; SET FLAGS BIT FOR LBA
;
PPIDE_INITDEV2:
	; GET DEVICE CAPACITY AND SAVE IT
	LD	A,PPIDE_MEDCAP		; OFFSET TO CAPACITY FIELD
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	PUSH	HL			; SAVE POINTER
	LD	HL,HB_WRKBUF		; POINT TO BUFFER START
	LD	A,120			; OFFSET OF SECTOR COUNT
	CALL	ADDHLA			; POINT TO ADDRESS OF SECTOR COUNT
	CALL	LD32			; LOAD IT TO DE:HL
	POP	BC			; RECOVER POINTER TO CAPACITY ENTRY
	CALL	ST32			; SAVE CAPACITY
;
	; RESET CARD STATUS TO 0 (OK)
	XOR	A			; A := 0 (STATUS = OK)
	LD	(IY+PPIDE_STAT),A	; SAVE IT
;
	RET				; RETURN, A=0, Z SET
;
; SWITCH IY POINTER FROM CURRENT UNIT CFG TO PARTNER UNIT CFG
;
PPIDE_GOPARTNER:
	PUSH	HL			; SAVE HL
	LD	L,(IY+PPIDE_PARTNER)	; GET PARTNER ENTRY
	LD	H,(IY+PPIDE_PARTNER+1)	; ...
	PUSH	HL			; MOVE HL
	POP	IY			; ... TO IY
	POP	HL			; RESTORE INCOMING HL
	RET				; AND DONE
;
; CHECK CURRENT DEVICE FOR ERROR STATUS AND ATTEMPT TO RECOVER
; VIA RESET IF DEVICE IS IN ERROR.
;
PPIDE_CHKERR:
	LD	A,(IY+PPIDE_STAT)	; GET STATUS
	OR	A			; SET FLAGS
	CALL	NZ,PPIDE_RESET		; IF ERROR STATUS, RESET BUS
	RET
;
;
;
PPIDE_WAITRDY:
	LD	A,(PPIDE_TIMEOUT)	; GET TIMEOUT IN 0.05 SECS
	LD	B,A			; PUT IN OUTER LOOP VAR
PPIDE_WAITRDY1:
	LD	DE,(PPIDE_TOSCALER)	; CPU SPEED SCALER TO INNER LOOP VAR
PPIDE_WAITRDY2:
	;IN	A,(PPIDE_REG_STAT)	; READ STATUS
	CALL	PPIDE_IN
	.DB	PPIDE_REG_STAT
	LD	C,A			; SAVE IT
	AND	%11000000		; ISOLATE BUSY AND RDY BITS
	XOR	%01000000		; WE WANT BUSY(7) TO BE 0 AND RDY(6) TO BE 1
	RET	Z			; ALL SET, RETURN WITH Z SET
	DEC	DE
	LD	A,D
	OR	E
	JR	NZ,PPIDE_WAITRDY2	; INNER LOOP RETURN
	DJNZ	PPIDE_WAITRDY1		; OUTER LOOP RETURN
	JP	PPIDE_RDYTO		; EXIT WITH RDYTO ERR
;
;
;
PPIDE_WAITDRQ:
	LD	A,(PPIDE_TIMEOUT)	; GET TIMEOUT IN 0.05 SECS
	LD	B,A			; PUT IN OUTER LOOP VAR
PPIDE_WAITDRQ1:
	LD	DE,(PPIDE_TOSCALER)	; CPU SPEED SCALER TO INNER LOOP VAR
PPIDE_WAITDRQ2:
	;IN	A,(PPIDE_REG_STAT)	; READ STATUS
	CALL	PPIDE_IN
	.DB	PPIDE_REG_STAT
	LD	C,A			; SAVE IT
	AND	%10001000		; TO FILL (OR READY TO FILL)
	XOR	%00001000
	RET	Z
	DEC	DE
	LD	A,D
	OR	E
	JR	NZ,PPIDE_WAITDRQ2
	DJNZ	PPIDE_WAITDRQ1
	JP	PPIDE_DRQTO		; EXIT WITH BUFTO ERR
;
;
;
PPIDE_WAITBSY:
	LD	A,(PPIDE_TIMEOUT)	; GET TIMEOUT IN 0.05 SECS
	LD	B,A			; PUT IN OUTER LOOP VAR
PPIDE_WAITBSY1:
	LD	DE,(PPIDE_TOSCALER)	; CPU SPEED SCALER TO INNER LOOP VAR
PPIDE_WAITBSY2:
	;IN	A,(PPIDE_REG_STAT)	; READ STATUS
	CALL	PPIDE_IN							; 17TS + 170TS
	.DB	PPIDE_REG_STAT							; 0TS
	LD	C,A			; SAVE IT				; 4TS
	AND	%10000000		; TO FILL (OR READY TO FILL)		; 7TS
	RET	Z								; 5TS
	DEC	DE								; 6TS
	LD	A,D								; 4TS
	OR	E								; 4TS
	JR	NZ,PPIDE_WAITBSY2						; 12TS
	DJNZ	PPIDE_WAITBSY1							; -----
	JP	PPIDE_BSYTO		; EXIT WITH BSYTO ERR			; 229TS
;
; READ A VALUE FROM THE DEVICE POINTED TO BY IY AND RETURN IT IN A
; 
PPIDE_IN:
	EX	(SP),HL			; GET PARM POINTER			; 19TS
	PUSH	BC			; SAVE INCOMING BC			; 11TS
	LD	A,PPIDE_DIR_READ	; SET DATA BUS DIRECTION TO READ	; 7TS
	;OUT	(PPIDE_IO_PPI),A	; DO IT					; 11TS
	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
	OUT	(C),A			; WRITE IT
;
	LD	B,(HL)			; GET CTL PORT VALUE			; 7TS
	;LD	C,PPIDE_IO_CTL		; SETUP PORT TO WRITE			; 7TS
	;LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
	DEC	C			; SET IDE ADDRESS
	OUT	(C),B			; SET ADDRESS LINES			; 12TS
	SET	6,B			; TURN ON READ BIT			; 8TS
	OUT	(C),B			; ASSERT READ LINE			; 12TS
;
	;IN	A,(PPIDE_IO_DATALO)	; GET DATA VALUE FROM DEVICE		; 11TS
	DEC	C
	DEC	C
	IN	A,(C)			; GET DATA VALUE FROM DEVICE
	INC	C
	INC	C
;
	RES	6,B			; CLEAR READ BIT			; 8TS
	OUT	(C),B			; DEASSERT READ LINE			; 12TS
	POP	BC			; RECOVER INCOMING BC			; 10TS
	INC	HL			; POINT PAST PARM			; 6TS
	EX	(SP),HL			; RESTORE STACK				; 19TS
	RET									; 10TS
;
; OUTPUT VALUE IN A TO THE DEVICE POINTED TO BY IY
; 
PPIDE_OUT:
	; *** TODO *** FIX ORDER OF SET/CLEAR WRITE LINE
	EX	(SP),HL			; GET PARM POINTER
	PUSH	BC			; SAVE INCOMING BC
	PUSH	AF			; PRESERVE INCOMING VALUE
	LD	A,PPIDE_DIR_WRITE	; SET DATA BUS DIRECTION TO WRITE
	;OUT	(PPIDE_IO_PPI),A	; DO IT
	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
	OUT	(C),A			; WRITE IT
	POP	AF			; RECOVER VALUE TO WRITE
;
	LD	B,(HL)			; GET IDE ADDRESS VALUE
	;LD	C,PPIDE_IO_CTL		; SETUP PORT TO WRITE
	;LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
	DEC	C			; SET IDE ADDRESS
	OUT	(C),B			; SET ADDRESS LINES
	SET	5,B			; TURN ON WRITE BIT
	OUT	(C),B			; ASSERT WRITE LINE
;
	DEC	C
	DEC	C
	;OUT	(PPIDE_IO_DATALO),A	; SEND DATA VALUE TO DEVICE
	OUT	(C),A			; SEND DATA VALUE TO DEVICE
	INC	C
	INC	C
;
	RES	5,B			; CLEAR WRITE BIT
	OUT	(C),B			; DEASSERT WRITE LINE
	POP	BC			; RECOVER INCOMING BC
	INC	HL			; POINT PAST PARM
	EX	(SP),HL			; RESTORE STACK
	RET
;
;=============================================================================
; ERROR HANDLING AND DIAGNOSTICS
;=============================================================================
;
; ERROR HANDLERS
;
PPIDE_INVUNIT:
	LD	A,PPIDE_STINVUNIT
	JR	PPIDE_ERR2		; SPECIAL CASE FOR INVALID UNIT
;
PPIDE_NOMEDIA:
	LD	A,PPIDE_STNOMEDIA
	JR	PPIDE_ERR
;
PPIDE_CMDERR:
	LD	A,PPIDE_STCMDERR
	JR	PPIDE_ERR
;
PPIDE_IOERR:
	LD	A,PPIDE_STIOERR
	JR	PPIDE_ERR
;
PPIDE_RDYTO:
	LD	A,PPIDE_STRDYTO
	JR	PPIDE_ERR
;
PPIDE_DRQTO:
	LD	A,PPIDE_STDRQTO
	JR	PPIDE_ERR
;
PPIDE_BSYTO:
	LD	A,PPIDE_STBSYTO
	JR	PPIDE_ERR
;
PPIDE_ERR:
	LD	(IY+PPIDE_STAT),A	; SAVE NEW STATUS
;
PPIDE_ERR2:
#IF (PPIDETRACE >= 2)
	CALL	PPIDE_PRTSTAT
	CALL	PPIDE_REGDUMP
#ENDIF
	OR	A			; SET FLAGS
	RET
;
;
;
PPIDE_PRTERR:
	RET	Z			; DONE IF NO ERRORS
	; FALL THRU TO PPIDE_PRTSTAT
;
; PRINT STATUS STRING (STATUS NUM IN A)
;
PPIDE_PRTSTAT:
	PUSH	AF
	PUSH	DE
	PUSH	HL
	LD	A,(IY+PPIDE_STAT)
	OR	A
	LD	DE,PPIDE_STR_STOK
	JR	Z,PPIDE_PRTSTAT1
	INC	A
	LD	DE,PPIDE_STR_STINVUNIT
	JR	Z,PPIDE_PRTSTAT2	; INVALID UNIT IS SPECIAL CASE
	INC	A
	LD	DE,PPIDE_STR_STNOMEDIA
	JR	Z,PPIDE_PRTSTAT1
	INC	A
	LD	DE,PPIDE_STR_STCMDERR
	JR	Z,PPIDE_PRTSTAT1
	INC	A
	LD	DE,PPIDE_STR_STIOERR
	JR	Z,PPIDE_PRTSTAT1
	INC	A
	LD	DE,PPIDE_STR_STRDYTO
	JR	Z,PPIDE_PRTSTAT1
	INC	A
	LD	DE,PPIDE_STR_STDRQTO
	JR	Z,PPIDE_PRTSTAT1
	INC	A
	LD	DE,PPIDE_STR_STBSYTO
	JR	Z,PPIDE_PRTSTAT1
	LD	DE,PPIDE_STR_STUNK
PPIDE_PRTSTAT1:
	CALL	PPIDE_PRTPREFIX		; PRINT UNIT PREFIX
	JR	PPIDE_PRTSTAT3
PPIDE_PRTSTAT2:
	CALL	NEWLINE
	PRTS("PPIDE:$")			; NO UNIT NUM IN PREFIX FOR INVALID UNIT
PPIDE_PRTSTAT3:
	CALL	PC_SPACE		; FORMATTING
	CALL	WRITESTR
	POP	HL
	POP	DE
	POP	AF
	RET
;
; PRINT ALL REGISTERS DIRECTLY FROM DEVICE
; DEVICE MUST BE SELECTED PRIOR TO CALL
;
PPIDE_REGDUMP:
	PUSH	AF
	PUSH	BC
	push	DE
	CALL	PC_SPACE
	CALL	PC_LBKT
	LD	A,PPIDE_DIR_READ	; SET DATA BUS DIRECTION TO READ
	;OUT	(PPIDE_IO_PPI),A	; DO IT
	LD	C,(IY+PPIDE_PPI)	; PPI CONTROL WORD
	OUT	(C),A			; WRITE IT
	LD	C,(IY+PPIDE_CTL)	; SET IDE ADDRESS
	LD	E,PPIDE_REG_CMD
	LD	B,7
PPIDE_REGDUMP1:
	LD	A,E			; REGISTER ADDRESS
	;OUT	(PPIDE_IO_CTL),A	; SET IT
	OUT	(C),A			; REGISTER ADDRESS
	XOR	PPIDE_CTL_DIOR		; SET BIT TO ASSERT READ LINE
	;OUT	(PPIDE_IO_CTL),A	; ASSERT READ
	OUT	(C),A			; ASSERT READ
	;IN	A,(PPIDE_IO_DATALO)	; GET VALUE
	DEC	C			; CTL -> MSB
	DEC	C			; MSB -> LSB
	IN	A,(C)			; GET VALUE
	INC	C			; LSB -> MSB
	INC	C			; MSB -> CTL
	CALL	PRTHEXBYTE		; DISPLAY IT
	;LD	A,C			; RELOAD ADDRESS W/ READ UNASSERTED
	;OUT	(PPIDE_IO_CTL),A	; AND SET IT
	OUT	(C),E			; RELOAD ADDRESS W/ READ UNASSERTED
	;DEC	C			; NEXT LOWER REGISTER
	DEC	E			; NEXT LOWER REGISTER
	DEC	B			; DEC LOOP COUNTER
	CALL	NZ,PC_SPACE		; FORMATTING
	JR	NZ,PPIDE_REGDUMP1	; LOOP AS NEEDED
	CALL	PC_RBKT			; FORMATTING
	POP	DE
	POP	BC
	POP	AF
	RET
;
; PRINT DIAGNONSTIC PREFIX
;
PPIDE_PRTPREFIX:
	PUSH	AF
	CALL	NEWLINE
	PRTS("PPIDE$")
	LD	A,(IY+PPIDE_DEV)	; GET CURRENT DEVICE NUM
	CP	$FE			; NOT YET ASSIGNED?
	JR	Z,PPIDE_PRTPREFIX1	; SKIP DEV NUM IF SO
	CALL	PRTDECB
PPIDE_PRTPREFIX1:
	CALL	PC_COLON
	POP	AF
	RET
;;;
;;;
;;;
;;#IF (DSKYENABLE)
;;PPIDE_DSKY:
;;	LD	HL,DSKY_HEXBUF		; POINT TO DSKY BUFFER
;;	CALL	PPIDE_IN
;;	.DB	PPIDE_REG_DRVHD
;;	LD	(HL),A			; SAVE IN BUFFER
;;	INC	HL			; INCREMENT BUFFER POINTER
;;	CALL	PPIDE_IN
;;	.DB	PPIDE_REG_CYLHI
;;	LD	(HL),A			; SAVE IN BUFFER
;;	INC	HL			; INCREMENT BUFFER POINTER
;;	CALL	PPIDE_IN
;;	.DB	PPIDE_REG_CYLLO
;;	LD	(HL),A			; SAVE IN BUFFER
;;	INC	HL			; INCREMENT BUFFER POINTER
;;	CALL	PPIDE_IN
;;	.DB	PPIDE_REG_SECT
;;	LD	(HL),A			; SAVE IN BUFFER
;;	CALL	DSKY_HEXOUT		; SEND IT TO DSKY
;;	RET
;;#ENDIF
;
;=============================================================================
; STRING DATA
;=============================================================================
;
PPIDE_STR_STOK		.TEXT	"OK$"
PPIDE_STR_STINVUNIT	.TEXT	"INVALID UNIT$"
PPIDE_STR_STNOMEDIA	.TEXT	"NO MEDIA$"
PPIDE_STR_STCMDERR	.TEXT	"COMMAND ERROR$"
PPIDE_STR_STIOERR	.TEXT	"IO ERROR$"
PPIDE_STR_STRDYTO	.TEXT	"READY TIMEOUT$"
PPIDE_STR_STDRQTO	.TEXT	"DRQ TIMEOUT$"
PPIDE_STR_STBSYTO	.TEXT	"BUSY TIMEOUT$"
PPIDE_STR_STUNK		.TEXT	"UNKNOWN ERROR$"
;
PPIDE_STR_NO		.TEXT	"NO$"
PPIDE_STR_NOPPI		.TEXT	"PPI NOT PRESENT$"
PPIDE_STR_8BIT		.TEXT	" 8-BIT$"
;
;=============================================================================
; DATA STORAGE
;=============================================================================
;
PPIDE_TIMEOUT	.DB	PPIDE_TONORM	; WAIT FUNCS TIMEOUT IN TENTHS OF SEC
PPIDE_TOSCALER	.DW	CPUMHZ * 218	; WAIT FUNCS SCALER FOR CPU SPEED
;
PPIDE_CMD	.DB	0		; PENDING COMMAND TO PROCESS
PPIDE_IOFNADR	.DW	0		; PENDING IO FUNCTION ADDRESS
PPIDE_DRVHD	.DB	0		; CURRENT DRIVE/HEAD MASK
;
PPIDE_DSKBUF	.DW	0		; ACTIVE DISK BUFFER
;
PPIDE_DEVNUM	.DB	0		; TEMP DEVICE NUM USED DURING INIT
