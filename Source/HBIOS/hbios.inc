;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; HBIOS FUNCTIONS
;
BF_CIO		.EQU	$00
BF_CIOIN	.EQU	BF_CIO + 0	; CHARACTER INPUT
BF_CIOOUT	.EQU	BF_CIO + 1	; CHARACTER OUTPUT
BF_CIOIST	.EQU	BF_CIO + 2	; CHARACTER INPUT STATUS
BF_CIOOST	.EQU	BF_CIO + 3	; CHARACTER OUTPUT STATUS
BF_CIOINIT	.EQU	BF_CIO + 4	; INIT/RESET DEVICE/LINE CONFIG
BF_CIOQUERY	.EQU	BF_CIO + 5	; REPORT DEVICE/LINE CONFIG
BF_CIODEVICE	.EQU	BF_CIO + 6	; REPORT DEVICE INFO
;
BF_DIO		.EQU	$10
BF_DIOSTATUS	.EQU	BF_DIO + 0	; DISK STATUS
BF_DIORESET	.EQU	BF_DIO + 1	; DISK RESET
BF_DIOSEEK	.EQU	BF_DIO + 2	; DISK SEEK
BF_DIOREAD	.EQU	BF_DIO + 3	; DISK READ SECTORS
BF_DIOWRITE	.EQU	BF_DIO + 4	; DISK WRITE SECTORS
BF_DIOVERIFY	.EQU	BF_DIO + 5	; DISK VERIFY SECTORS
BF_DIOFORMAT	.EQU	BF_DIO + 6	; DISK FORMAT TRACK
BF_DIODEVICE	.EQU	BF_DIO + 7	; DISK DEVICE INFO REPORT
BF_DIOMEDIA	.EQU	BF_DIO + 8	; DISK MEDIA REPORT
BF_DIODEFMED	.EQU	BF_DIO + 9	; DEFINE DISK MEDIA
BF_DIOCAP	.EQU	BF_DIO + 10	; DISK CAPACITY REPORT
BF_DIOGEOM	.EQU	BF_DIO + 11	; DISK GEOMETRY REPORT
;
BF_RTC		.EQU	$20
BF_RTCGETTIM	.EQU	BF_RTC + 0	; GET TIME
BF_RTCSETTIM	.EQU	BF_RTC + 1	; SET TIME
BF_RTCGETBYT	.EQU	BF_RTC + 2	; GET NVRAM BYTE BY INDEX
BF_RTCSETBYT	.EQU	BF_RTC + 3	; SET NVRAM BYTE BY INDEX
BF_RTCGETBLK	.EQU	BF_RTC + 4	; GET NVRAM DATA BLOCK
BF_RTCSETBLK	.EQU	BF_RTC + 5	; SET NVRAM DATA BLOCK
BF_RTCGETALM	.EQU	BF_RTC + 6	; GET ALARM
BF_RTCSETALM	.EQU	BF_RTC + 7	; SET ALARM
BF_RTCDEVICE	.EQU	BF_RTC + 8	; RTC DEVICE INFO REPORT
;
BF_EMU		.EQU	$30		; DEPRECATED
;
BF_VDA		.EQU	$40
BF_VDAINI	.EQU	BF_VDA + 0	; INITIALIZE VDU
BF_VDAQRY	.EQU	BF_VDA + 1	; QUERY VDU STATUS
BF_VDARES	.EQU	BF_VDA + 2	; SOFT RESET VDU
BF_VDADEV	.EQU	BF_VDA + 3	; DEVICE INFO
BF_VDASCS	.EQU	BF_VDA + 4	; SET CURSOR STYLE
BF_VDASCP	.EQU	BF_VDA + 5	; SET CURSOR POSITION
BF_VDASAT	.EQU	BF_VDA + 6	; SET CHARACTER ATTRIBUTE
BF_VDASCO	.EQU	BF_VDA + 7	; SET CHARACTER COLOR
BF_VDAWRC	.EQU	BF_VDA + 8	; WRITE CHARACTER
BF_VDAFIL	.EQU	BF_VDA + 9	; FILL
BF_VDACPY	.EQU	BF_VDA + 10	; COPY
BF_VDASCR	.EQU	BF_VDA + 11	; SCROLL
BF_VDAKST	.EQU	BF_VDA + 12	; GET KEYBOARD STATUS
BF_VDAKFL	.EQU	BF_VDA + 13	; FLUSH KEYBOARD BUFFER
BF_VDAKRD	.EQU	BF_VDA + 14	; READ KEYBOARD
BF_VDARDC	.EQU	BF_VDA + 15	; READ CHARACTER
;
BF_SND		.EQU	$50
BF_SNDRESET	.EQU	BF_SND + 0	; RESET SOUND SYSTEM
BF_SNDVOL	.EQU	BF_SND + 1	; REQUEST SOUND VOL - L CONTAINS VOLUME (255 MAX, 0 SILENT) - SCALED AS REQUIRED BY DRIVER (EG: MAPS TO JUST 4 BIT RESOLUTION FOR SN76489)
BF_SNDPRD	.EQU	BF_SND + 2	; REQUEST SOUND PERIOD - HL CONTAINS DRIVER SPECIFIC VALUE
BF_SNDNOTE	.EQU	BF_SND + 3	; REQUEST NOTE - L CONTAINS NOTE - EACH VALUE IS QUARTER NOTE
BF_SNDPLAY	.EQU	BF_SND + 4	; INITIATE THE REQUESTED SOUND COMMAND
BF_SNDQUERY	.EQU	BF_SND + 5	; E IS SUBFUNCTION
BF_SNDDURATION	.EQU	BF_SND + 6	; REQUEST DURATION HL MILLISECONDS
BF_SNDDEVICE	.EQU	BF_SND + 7	; SOUND DEVICE INFO REQUEST
;
; BF_SNDQUERY SUBCOMMANDS
BF_SNDQ_STATUS		.EQU	0
BF_SNDQ_CHCNT		.EQU	BF_SNDQ_STATUS + 1	; RETURN COUNT OF CHANNELS
BF_SNDQ_VOLUME		.EQU	BF_SNDQ_STATUS + 2	; 8 BIT NUMBER
BF_SNDQ_PERIOD		.EQU	BF_SNDQ_STATUS + 3	; 16 BIT NUMBER
BF_SNDQ_DEV		.EQU	BF_SNDQ_STATUS + 4	; RETURN DEVICE TYPE CODE AND IO PORTS - TYPE IN B, PORTS IN DE, HL
;
BF_SYS		.EQU	$F0
BF_SYSRESET	.EQU	BF_SYS + 0	; SOFT RESET HBIOS
BF_SYSVER	.EQU	BF_SYS + 1	; GET HBIOS VERSION
BF_SYSSETBNK	.EQU	BF_SYS + 2	; SET CURRENT BANK
BF_SYSGETBNK	.EQU	BF_SYS + 3	; GET CURRENT BANK
BF_SYSSETCPY	.EQU	BF_SYS + 4	; BANK MEMORY COPY SETUP
BF_SYSBNKCPY	.EQU	BF_SYS + 5	; BANK MEMORY COPY
BF_SYSALLOC	.EQU	BF_SYS + 6	; ALLOC HBIOS HEAP MEMORY
BF_SYSFREE	.EQU	BF_SYS + 7	; FREE HBIOS HEAP MEMORY
BF_SYSGET	.EQU	BF_SYS + 8	; GET HBIOS INFO
BF_SYSSET	.EQU	BF_SYS + 9	; SET HBIOS PARAMETERS
BF_SYSPEEK	.EQU	BF_SYS + 10	; GET A BYTE VALUE FROM ALT BANK
BF_SYSPOKE	.EQU	BF_SYS + 11	; SET A BYTE VALUE IN ALT BANK
BF_SYSINT	.EQU	BF_SYS + 12	; MANAGE INTERRUPT VECTORS
;
BF_SYSRES_INT		.EQU	$00	; RESET HBIOS INTERNAL
BF_SYSRES_WARM		.EQU	$01	; WARM START (RESTART BOOT LOADER)
BF_SYSRES_COLD		.EQU	$02	; COLD START
BF_SYSRES_USER		.EQU	$03	; USER RESET REQUEST
;
BF_SYSGET_CIOCNT	.EQU	$00	; GET CHAR UNIT COUNT
BF_SYSGET_CIOFN		.EQU	$01	; GET CIO UNIT FN/DATA ADR
BF_SYSGET_DIOCNT	.EQU	$10	; GET DISK UNIT COUNT
BF_SYSGET_DIOFN		.EQU	$11	; GET DIO UNIT FN/DATA ADR
BF_SYSGET_RTCCNT	.EQU	$20	; GET RTC UNIT COUNT
BF_SYSGET_VDACNT	.EQU	$40	; GET VDA UNIT COUNT
BF_SYSGET_VDAFN		.EQU	$41	; GET VDA UNIT FN/DATA ADR
BF_SYSGET_SNDCNT	.EQU	$50	; GET VDA UNIT COUNT
BF_SYSGET_SNDFN		.EQU	$51	; GET SND UNIT FN/DATA ADR
BF_SYSGET_TIMER		.EQU	$D0	; GET CURRENT TIMER VALUE
BF_SYSGET_SECS		.EQU	$D1	; GET CURRENT SECONDS VALUE
BF_SYSGET_BOOTINFO	.EQU	$E0	; GET BOOT INFORMATION
BF_SYSGET_CPUINFO	.EQU	$F0	; GET CPU INFORMATION
BF_SYSGET_MEMINFO	.EQU	$F1	; GET MEMORY CAPACTITY INFO
BF_SYSGET_BNKINFO	.EQU	$F2	; GET BANK ASSIGNMENT INFO
BF_SYSGET_CPUSPD	.EQU	$F3	; GET CLOCK SPEED & WAIT STATES
BF_SYSGET_PANEL		.EQU	$F4	; GET FRONT PANEL SWITCHES VAL
;
BF_SYSSET_TIMER		.EQU	$D0	; SET TIMER VALUE
BF_SYSSET_SECS		.EQU	$D1	; SET SECONDS VALUE
BF_SYSSET_BOOTINFO	.EQU	$E0	; SET BOOT INFORMATION
BF_SYSSET_CPUSPD	.EQU	$F3	; SET CLOCK SPEED & WAIT STATES
BF_SYSSET_PANEL		.EQU	$F4	; SET FRONT PANEL LEDS
;
BF_SYSINT_INFO		.EQU	$00	; GET INTERRUPT SYSTEM INFO
BF_SYSINT_GET		.EQU	$10	; GET INT VECTOR ADDRESS
BF_SYSINT_SET		.EQU	$20	; SET INT VECTOR ADDRESS
;
CIO_CONSOLE		.EQU	$80	; CIO UNIT NUM FOR CUR CON
;
; PRIMARY HARDWARE PLATFORMS
;
PLT_SBC		.EQU	1		; SBC ECB Z80 SBC
PLT_ZETA	.EQU	2		; ZETA Z80 SBC
PLT_ZETA2	.EQU	3		; ZETA Z80 V2 SBC
PLT_N8		.EQU	4		; N8 (HOME COMPUTER) Z180 SBC
PLT_MK4		.EQU	5		; MARK IV
PLT_UNA		.EQU	6		; UNA BIOS
PLT_RCZ80	.EQU	7		; RCBUS W/ Z80
PLT_RCZ180	.EQU	8		; RCBUS W/ Z180
PLT_EZZ80	.EQU	9		; EASY Z80
PLT_SCZ180	.EQU	10		; SCZ180
PLT_DYNO	.EQU	11		; DYNO MICRO-ATX MOTHERBOARD
PLT_RCZ280	.EQU	12		; RCBUS W/ Z280
PLT_MBC		.EQU	13		; MULTI BOARD COMPUTER
PLT_RPH		.EQU	14		; RHYOPHYRE GRAPHICS COMPUTER
PLT_Z80RETRO	.EQU	15		; Z80 RETRO COMPUTER
;
; HBIOS GLOBAL ERROR RETURN VALUES
;
ERR_NONE		.EQU	0	; SUCCESS
;
ERR_UNDEF		.EQU	-1	; UNDEFINED ERROR
ERR_NOTIMPL		.EQU	-2	; FUNCTION NOT IMPLEMENTED
ERR_NOFUNC		.EQU	-3	; INVALID FUNCTION
ERR_NOUNIT		.EQU	-4	; INVALID UNIT NUMBER
ERR_NOMEM		.EQU	-5	; OUT OF MEMORY
ERR_RANGE		.EQU	-6	; PARAMETER OUT OF RANGE
ERR_NOMEDIA		.EQU	-7	; MEDIA NOT PRESENT
ERR_NOHW		.EQU	-8	; HARDWARE NOT PRESENT
ERR_IO			.EQU	-9	; I/O ERROR
ERR_READONLY		.EQU	-10	; WRITE REQUEST TO READ-ONLY MEDIA
ERR_TIMEOUT		.EQU	-11	; DEVICE TIMEOUT
ERR_BADCFG		.EQU	-12	; INVALID CONFIGURATION
ERR_INTERNAL		.EQU	-13	; INTERNAL ERROR
;
; HBIOS DIAG OPTIONS
;
DIAG_PROG	.EQU	0		; PROGRESS BAR
DIAG_STEP	.EQU	1		; STEP BAR
DIAG_ASCII	.EQU	2		; 8-BIT ASCII 30H - 39H
DIAG_BINARY	.EQU	3		; BINARY 00H - 09H
DIAG_7SEG	.EQU	4		; 7-SEGMENT
DIAG_FLASH	.EQU	5		; FLASH
DIAG_TRIG	.EQU	6		; TRIGGER
;
DIAG_DISP	.EQU	DIAG_PROG	; DEFAULT
;
#IF (DIAG_DISP == DIAG_PROG)
DIAG_00 .EQU 00000000B	
DIAG_01 .EQU 00000001B 
DIAG_02 .EQU 00000011B 
DIAG_03 .EQU 00000111B 
DIAG_04 .EQU 00001111B 
DIAG_05 .EQU 00011111B 
DIAG_06 .EQU 00111111B 
DIAG_07 .EQU 01111111B 
DIAG_08 .EQU 11111111B 
DIAG_09 .EQU 11111111B   
#ENDIF
;
#IF (DIAG_DISP == DIAG_STEP)
DIAG_00 .EQU 00000000B	
DIAG_01 .EQU 00000001B 
DIAG_02 .EQU 00000010B 
DIAG_03 .EQU 00000100B 
DIAG_04 .EQU 00001000B 
DIAG_05 .EQU 00010000B 
DIAG_06 .EQU 00100000B 
DIAG_07 .EQU 01000000B 
DIAG_08 .EQU 10000000B
DIAG_09 .EQU 11111111B
#ENDIF
;
#IF (DIAG_DISP == DIAG_ASCII)
DIAG_00 .EQU '0'	
DIAG_01 .EQU '1'
DIAG_02 .EQU '2' 
DIAG_03 .EQU '3' 
DIAG_04 .EQU '4'
DIAG_05 .EQU '5'
DIAG_06 .EQU '6' 
DIAG_07 .EQU '7'
DIAG_08 .EQU '8' 
DIAG_09 .EQU '9' 
#ENDIF
;
#IF (DIAG_DISP == DIAG_BINARY)
DIAG_00 .EQU 0	
DIAG_01 .EQU 1
DIAG_02 .EQU 2
DIAG_03 .EQU 3
DIAG_04 .EQU 4
DIAG_05 .EQU 5
DIAG_06 .EQU 6
DIAG_07 .EQU 7
DIAG_08 .EQU 8
DIAG_09 .EQU 9 
#ENDIF
;
#IF (DIAG_DISP == DIAG_7SEG)
;             abcdefg
DIAG_00 .EQU 00000000B ; BLANK
DIAG_01 .EQU 01111110B ; 0
DIAG_02 .EQU 00110000B ; 1
DIAG_03 .EQU 01101101B ; 2
DIAG_04 .EQU 01111001B ; 3 
DIAG_05 .EQU 00110011B ; 4
DIAG_06 .EQU 01011011B ; 5
DIAG_07 .EQU 00011111B ; 6 
DIAG_08 .EQU 01110000B ; 7
DIAG_09 .EQU 01111111B ; 8
DIAG_10 .EQU 01110011B ; 9
#ENDIF
;
#IF (DIAG_DISP == DIAG_FLASH)
DIAG_00 .EQU 00000000B ; OFF	
DIAG_01 .EQU 11111111B ; ON
DIAG_02 .EQU 00000000B ; OFF	
DIAG_03 .EQU 11111111B ; ON
DIAG_04 .EQU 00000000B ; OFF	
DIAG_05 .EQU 11111111B ; ON
DIAG_06 .EQU 00000000B ; OFF	
DIAG_07 .EQU 11111111B ; ON
DIAG_08 .EQU 00000000B ; OFF	
DIAG_09 .EQU 11111111B ; ON 
#ENDIF
;
#IF (DIAG_DISP == DIAG_TRIG)
DIAG_00 .EQU 11111111B ; ON	
DIAG_01 .EQU 11111111B ; ON
DIAG_02 .EQU 11111111B ; ON
DIAG_03 .EQU 11111111B ; ON
DIAG_04 .EQU 11111111B ; ON
DIAG_05 .EQU 11111111B ; ON
DIAG_06 .EQU 11111111B ; ON
DIAG_07 .EQU 11111111B ; ON
DIAG_08 .EQU 11111111B ; ON
DIAG_09 .EQU 11111111B ; ON 
#ENDIF
;
; FRONT PANEL SWITCHES
;
SW_CRT		.EQU	%10000000	; CRT/SER CONSOLE
SW_SEC		.EQU	%01000000	; SEC/PRI CONSOLE
SW_AUTO		.EQU	%00100000	; AUTO/MENU BOOT
SW_DISK		.EQU	%00010000	; DISK/ROM
SW_FLOP		.EQU	%00001000	; FLOP/HD
SW_OPT		.EQU	%00000111	; SLICE/ROM APP
;
; MEDIA ID VALUES
;
MID_NONE	.EQU	0
MID_MDROM	.EQU	1
MID_MDRAM	.EQU	2
MID_RF		.EQU	3
MID_HD		.EQU	4
MID_FD720	.EQU	5
MID_FD144	.EQU	6
MID_FD360	.EQU	7
MID_FD120	.EQU	8
MID_FD111	.EQU	9
MID_HDNEW	.EQU	10
;
; CHAR DEVICE IDS
;
CIODEV_UART	.EQU	$00
CIODEV_ASCI	.EQU	$10
CIODEV_TERM	.EQU	$20
CIODEV_PRPCON	.EQU	$30
CIODEV_PPPCON	.EQU	$40
CIODEV_SIO	.EQU	$50
CIODEV_ACIA	.EQU	$60
CIODEV_PIO	.EQU	$70
CIODEV_UF	.EQU	$80
CIODEV_DUART	.EQU	$90
CIODEV_Z2U	.EQU	$A0
CIODEV_LPT	.EQU	$B0
;
; SUB TYPES OF CHAR DEVICES
;
;00 RS-232
;01 TERMINAL
;02 PARALLEL PORT
;03 UNUSED
;
; DISK DEVICE IDS
;
DIODEV_MD	.EQU	$00
DIODEV_FD	.EQU	$10
DIODEV_RF	.EQU	$20
DIODEV_IDE	.EQU	$30
DIODEV_ATAPI	.EQU	$40
DIODEV_PPIDE	.EQU	$50
DIODEV_SD	.EQU	$60
DIODEV_PRPSD	.EQU	$70
DIODEV_PPPSD	.EQU	$80
DIODEV_HDSK	.EQU	$90
;
; RTC DEVICE IDS
;
RTCDEV_DS	.EQU	$00		; DS1302
RTCDEV_BQ	.EQU	$10		; BQ4845P
RTCDEV_SIMH	.EQU	$20		; SIMH
RTCDEV_INT	.EQU	$30		; PERIODIC INT TIMER
RTCDEV_DS7	.EQU	$40		; DS1307 (I2C)
RTCDEV_RP5	.EQU	$50		; RP5C01
;
; VIDEO DEVICE IDS
;
VDADEV_VDU	.EQU	$00		; ECB VDU - MOTOROLA 6545
VDADEV_CVDU	.EQU	$10		; ECB COLOR VDU - MOS 8563
VDADEV_GDC	.EQU	$20		; GRAPHICS DISPLAY CTLR - UPD7220
VDADEV_TMS	.EQU	$30		; N8 ONBOARD VDA SUBSYSTEM - TMS 9918
VDADEV_VGA	.EQU	$40		; ECB VGA3 - HITACHI HD6445
;VDADEV_V9958	.EQU	$50		; V9958 VDU
;
; SOUND DEVICE IDS
;
SNDDEV_SN76489	.EQU	$00
SNDDEV_AY38910	.EQU	$10
SNDDEV_BITMODE	.EQU	$20
SNDDEV_YM2612	.EQU	$30
;
; HBIOS CONTROL BLOCK OFFSETS
; WARNING: THESE OFFSETS WILL CHANGE SIGNIFICANTLY BETWEEN RELEASES
;          IT IS STRONGLY RECOMMENDED THAT YOU DO NOT USE THEM!
;
HCB_LOC		.EQU	$100		; LOCATION OF HCB IN HBIOS BANK
HCB_SIZ		.EQU	$100		; SIZE OF HCB DATA BLOCK
;
HCB_MARKER	.EQU	$03		; MARKER ('W',~'W') (WORD)
HCB_VERSION	.EQU	$05		; HBIOS VERSION NUM
HCB_PLATFORM	.EQU	$07		; PLATFORM ID
HCB_CPUMHZ	.EQU	$08		; CPU SPEED IN MHZ (BYTE)
HCB_CPUKHZ	.EQU	$09		; CPU SPEED IN KHZ (WORD)
HCB_RAMBANKS	.EQU	$0B		; TOTAL SIZE OF RAM IN 32K BANKS (BYTE)
HCB_ROMBANKS	.EQU	$0C		; TOTAL SIZE OF ROM IN 32K BANKS (BYTE)
HCB_BOOTVOL	.EQU	$0D		; BOOT VOLUME, MSB=DEV/UNIT, LSB=LU (WORD)
HCB_BOOTBID	.EQU	$0F		; BANK ID OF ROM PAGE BOOTED (BYTE)
HCB_SERDEV	.EQU	$10		; PRIMARY SERIAL DEVICE/UNIT (BYTE)
HCB_CRTDEV	.EQU	$11		; CRT DISPLAY DEVICE/UNIT (BYTE)
HCB_CONDEV	.EQU	$12		; ACTIVE CONSOLE DEVICE/UNIT (BYTE)
HCB_DIAGLVL	.EQU	$13		; HBIOS DIAGNOSTIC LEVEL (BYTE)
;
HCB_HEAP	.EQU	$20		; DWORD ADDRESS OF START OF HEAP
HCB_HEAPTOP	.EQU	$22		; DWORD ADDRESS OF TOP OF HEAP
;
; MEMORY BANK IDS (ONE BYTE EACH)
HCB_BIDCOM	.EQU	$D8		; COMMON BANK (UPPER 32K)
HCB_BIDUSR	.EQU	$D9		; USER BANK (TPA)
HCB_BIDBIOS	.EQU	$DA		; BIOS BANK (HBIOS, UBIOS)
HCB_BIDAUX	.EQU	$DB		; AUX BANK (BPBIOS)
HCB_BIDRAMD0	.EQU	$DC		; FIRST BANK OF RAM DRIVE
HCB_BIDRAMDN	.EQU	$DD		; LAST BANK OF RAM DRIVE
HCB_BIDROMD0	.EQU	$DE		; FIRST BANK OF ROM DRIVE
HCB_BIDROMDN	.EQU	$DF		; LAST BANK OF ROM DRIVE
;
; HBIOS PROXY COMMON DATA BLOCK
; EXACTLY 32 BYTES AT $FFE0-$FFFF
;
HBX_XFC		.EQU	$10000 - $20		; HBIOS PROXY INTERFACE AREA, 32 BYTES FIXED
;
HBX_XFCDAT	.EQU	HBX_XFC			; DATA PORTION OF HBIOS PROXY INTERFACE AREA
HB_CURBNK	.EQU	HBX_XFCDAT + 0		; CURRENTLY ACTIVE LOW MEMORY BANK ID
HB_INVBNK	.EQU	HBX_XFCDAT + 1		; BANK ACTIVE AT TIME OF HBIOS CALL INVOCATION
HB_SRCADR	.EQU	HBX_XFCDAT + 2		; BNKCPY: DESTINATION BANK ID
HB_SRCBNK	.EQU	HBX_XFCDAT + 4		; BNKCPY: SOURCE BANK ID
HB_DSTADR	.EQU	HBX_XFCDAT + 5		; BNKCPY: DESTINATION ADDRESS
HB_DSTBNK	.EQU	HBX_XFCDAT + 7		; BNKCPY: SOURCE ADDRESS
HB_CPYLEN	.EQU	HBX_XFCDAT + 8		; BNKCPY: COPY LENGTH
HB_RTCVAL	.EQU	HBX_XFCDAT + 14		; RTC LATCH SHADOW VALUE
HB_LOCK		.EQU	HBX_XFCDAT + 15		; INVOKE: HBIOS MUTEX LOCK
;
HBX_XFCFNS	.EQU	HBX_XFC + $10		; JUMP TABLE PORTION OF HBIOS PROXY INTERFACE AREA
HB_INVOKE	.EQU	HBX_XFCFNS + (0 * 3)	; INVOKE HBIOS FUNCTION
HB_BNKSEL	.EQU	HBX_XFCFNS + (1 * 3)	; SELECT LOW MEMORY BANK ID
HB_BNKCPY	.EQU	HBX_XFCFNS + (2 * 3)	; INTERBANK MEMORY COPY
HB_BNKCALL	.EQU	HBX_XFCFNS + (3 * 3)	; INTERBANK FUNCTION CALL
;HB_LOC		.EQU	HBX_XFCFNS + 12		; ADDRESS OF HBIOS PROXY START (DEPRECATED)
HB_IDENT	.EQU	HBX_XFCFNS + 14		; POINTER TO HBIOS IDENT DATA BLOCK
