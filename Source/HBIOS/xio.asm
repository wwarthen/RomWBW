;___XIO________________________________________________________________________________________________________________
;
; DIRECT SERIAL I/O
;
;   PROVIDES INTERFACE TO PLATFORM BASE SERIAL I/O DEVICE
;   ALLOWS USER MESSAGING/INTERACTION PRIOR TO AND DURING HBIOS INIT
;______________________________________________________________________________________________________________________
;
;
#IF ((PLATFORM == PLT_SBC) | (PLATFORM == PLT_ZETA) | (PLATFORM == PLT_ZETA2))
;
SIO_RBR		.EQU	UART0IOB + 0	; DLAB=0: RCVR BUFFER REG (READ ONLY)
SIO_THR		.EQU	UART0IOB + 0	; DLAB=0: XMIT HOLDING REG (WRITE ONLY)
SIO_IER		.EQU	UART0IOB + 1	; DLAB=0: INT ENABLE REG
SIO_IIR		.EQU	UART0IOB + 2	; INT IDENT REGISTER (READ ONLY)
SIO_FCR		.EQU	UART0IOB + 2	; FIFO CONTROL REG (WRITE ONLY)
SIO_LCR		.EQU	UART0IOB + 3	; LINE CONTROL REG
SIO_MCR		.EQU	UART0IOB + 4	; MODEM CONTROL REG
SIO_LSR		.EQU	UART0IOB + 5	; LINE STATUS REG
SIO_MSR		.EQU	UART0IOB + 6	; MODEM STATUS REG
SIO_SCR		.EQU	UART0IOB + 7	; SCRATCH REGISTER
SIO_DLL		.EQU	UART0IOB + 0	; DLAB=1: DIVISOR LATCH (LS)
SIO_DLM		.EQU	UART0IOB + 1	; DLAB=1: DIVISOR LATCH (MS)
;
#ENDIF
;
XIO_INIT:	; MINIMAL UART INIT

#IF (PLATFORM == PLT_UNA)
	; SHOULD UNA SERIAL I/O BE RESET HERE???
#ENDIF

#IF ((PLATFORM == PLT_N8) | (PLATFORM == PLT_MK4))

	; ASCI0
	LD	A,66H
	OUT0	(Z180_ASEXT0),A
	LD	A,64H
	OUT0	(Z180_CNTLA0),A
	LD	A,Z180_ASCIB0
	OUT0	(Z180_CNTLB0),A
	
#ENDIF

#IF ((PLATFORM == PLT_SBC) | (PLATFORM == PLT_ZETA) | (PLATFORM == PLT_ZETA2))

XIO_DIV	.EQU	(UARTOSC / (16 * CONBAUD))

	LD	A,$80			; LCR := DLAB ON
	OUT	(SIO_LCR),A		; SET LCR
	LD	A,XIO_DIV % $100	; BAUD RATE DIVISOR (LSB)
	OUT	(SIO_DLL),A		; SET DIVISOR (LSB)
	LD	A,XIO_DIV / $100	; BAUD RATE DIVISOR (MSB)
	OUT	(SIO_DLM),A		; SET DIVISOR (MSB)
	LD	A,03H			; VALUE FOR LCR AND MCR
	OUT	(SIO_LCR),A		; LCR := 3, DLAB OFF, 8 DATA, 1 STOP, NO PARITY
	OUT  	(SIO_MCR),A		; MCR := 3, DTR ON, RTS ON
	LD	A,6			; DISABLE & RESET FIFO'S
	OUT	(SIO_FCR),A		; DO IT

#ENDIF

	RET
;
XIO_CRLF:	; OUTPUT A NEWLINE
	LD	A,13			; A = CR
	CALL	XIO_OUTC		; WRITE IT
	LD	A,10			; A = LF
	JR	XIO_OUTC		; WRITE IT
;
XIO_SPACE:	; OUTPUT A SPACE CHARACTER
	LD	A,' '
	JR	XIO_OUTC
;
XIO_DOT:	; OUTPUT A DOT (MARK PROGRESS)
	LD	A,'.'
;	
XIO_OUTC:	; OUTPUT BYTE IN A

#IF (PLATFORM == PLT_UNA)
	PUSH	DE		; PRESERVE DE
	LD	BC,$0012	; UNA UNIT = 0, FUNC = WRITE CHAR
	LD	E,A		; CHAR TO E
	CALL	$FFFD		; DO IT (RST 08 NOT SETUP YET)
	POP	DE		; RESTORE DE
	RET			; DONE
#ENDIF

#IF ((PLATFORM == PLT_N8) | (PLATFORM == PLT_MK4))
	PUSH	AF			; SAVE INCOMING BYTE
XIO_OUTC1:
	IN0	A,(Z180_STAT0)
	AND	$02
	JR	Z,XIO_OUTC1
	POP	AF
	OUT0	(Z180_TDR0),A
	RET
#ENDIF

#IF ((PLATFORM == PLT_SBC) | (PLATFORM == PLT_ZETA) | (PLATFORM == PLT_ZETA2))
	PUSH	AF			; SAVE INCOMING BYTE
XIO_OUTC1:
	IN	A,(SIO_LSR)		; READ LINE STATUS REGISTER
	AND	$20			; ISOLATE THRE
	JR	Z,XIO_OUTC1		; LOOP TILL READY (EMPTY)
	POP	AF			; RECOVER BYTE TO WRITE
	OUT	(SIO_THR),A		; WRITE THE CHAR TO UART
	RET
#ENDIF
;
XIO_OUTS:	; OUTPUT '$' TERMINATED STRING AT ADDRESS IN HL
	LD	A,(HL)			; GET NEXT BYTE
	CP	'$'			; END OF STRING?
	RET	Z			; YES, GET OUT
	CALL	XIO_OUTC		; OTHERWISE, WRITE IT
	INC	HL			; POINT TO NEXT BYTE
	JR	XIO_OUTS		; AND LOOP
