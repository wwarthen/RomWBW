;
;==================================================================================================
; CH375/376 USB/SD DRIVER
;==================================================================================================
;
; https://www.wch-ic.com/
;
; Thanks and credit to Alan Cox.  Much of this driver is based on
; his code in FUZIX (https://github.com/EtchedPixels/FUZIX).
;
; NOTES:
;  - There seem to be compatibility issues with older USB thumb drives.
;    Such drives will complete DISK_INIT successfully, but then return
;    an error attempting to do any I/O.  The error is $17 indicating
;    the CH37x encountered an overflow during communication with the
;    device.   I found that adding a DISK_MOUNT command (only possible
;    on CH376) resolved the issue for some devices, so that has been
;    added to the RESET routine when using CH376.
;
;  - The CH37x can get in an inconsistent state.  The RESET_ALL command
;    will clear this, but the RESET_ALL command is very problematic on
;    the CH376.  On the CH376, the hardware reset takes a very long
;    time (much longer than the documentation suggests).  It seems to
;    work fine on the CH375, but since you don't know what chip you
;    are dealing with at that point, I have given up on using it.
;
; TODO:
;  - Implement auto-recovery on error status.
;
CHUSB_FASTIO	.EQU	TRUE		; USE INIR/OTIR?
;
; PORT OFFSETS FROM BASE PORT
;
;CH_DATA	.EQU	0		; DATA PORT AT BASE + 0
;CH_CMD		.EQU	1		; CMD PORT AT BASE + 1
;
; CH DEVICE TYPES
;
CHTYP_NONE	.EQU	0		; NONE
CHTYP_375	.EQU	1		; CH375
CHTYP_376	.EQU	2		; CH376
;
; CH375/376 COMMANDS
;
CH_CMD_VER	.EQU	$01		; GET IC VER
CH_CMD_RESET	.EQU	$05		; FULL CH37X RESET
CH_CMD_EXIST	.EQU	$06		; CHECK EXISTS
CH_CMD_PKTSEC	.EQU	$0B		; SET PACKETS PER SECTOR
CH_CMD_MODE	.EQU	$15		; SET USB MODE
CH_CMD_STAT	.EQU	$22		; GET STATUS
CH_CMD_RD6	.EQU	$27		; READ USB DATA (375 & 376)
CH_CMD_RD5	.EQU	$28		; READ USB DATA (375)
CH_CMD_WR5	.EQU	$2B		; WRITE USB DATA (375)
CH_CMD_WR6	.EQU	$2C		; WRITE USB DATA (376)
CH_CMD_DSKMNT	.EQU	$31		; DISK MOUNT
CH_CMD_DSKCAP	.EQU	$3E		; DISK CAPACITY
CH_CMD_AUTOSET	.EQU	$4D		; USB AUTO SETUP
CH_CMD_DSKINIT	.EQU	$51		; DISK INIT
CH_CMD_DSKSIZ	.EQU	$53		; DISK SIZE
CH_CMD_DSKRD	.EQU	$54		; DISK READ
CH_CMD_DSKRDGO	.EQU	$55		; CONTINUE DISK READ
CH_CMD_DSKWR	.EQU	$56		; DISK WRITE
CH_CMD_DSKWRGO	.EQU	$57		; CONTINUE DISK WRITE
CH_CMD_DSKINQ	.EQU	$58		; DISK INQUIRY
CH_CMD_DSKRDY	.EQU	$59		; DISK READY
;
; CH DEVICE CONFIGURATION
;
CH_CFGSIZ	.EQU	9		; SIZE OF CFG TBL ENTRIES
;
; CONFIG ENTRY DATA OFFSETS
;
CH_DEV		.EQU	0		; OFFSET OF DEVICE NUMBER (BYTE)
CH_TYPE		.EQU	1		; CH DEVICE TYPE (CHTYP_XXX)
CH_IOBASE	.EQU	2		; IO BASE ADDRESS (BYTE)
CH_USBENABLE	.EQU	3		; ENABLE USB SUB-DRIVER
CH_USBCFG	.EQU	4		; USB SUB-DRIVER CFG ENTRY
CH_SDENABLE	.EQU	6		; ENABLE SD CARD SUB-DRIVER
CH_SDCFG	.EQU	7		; SD CARD SUB-DRIVER CFG ENTRY
;
CH_CFGTBL:
;
#IF (CHCNT >= 1)
CH_CFG0:	; DEVICE 0
	.DB	0			; DEV NUM
	.DB	CHTYP_NONE		; DEV TYPE, FILLED DYNCAMICALLY
	.DB	CH0BASE			; IO BASE ADDRESS
	.DB	CH0USBENABLE		; ENABLE USB SUB-DRIVER
	.DW	CHUSB_CFG0		; USB SUB-DRIVER INIT ADR
	.DB	CH0SDENABLE		; ENABLE SD CARD SUB-DRIVER
	.DW	CHSD_CFG0		; SD CARD SUB-DRIVER INIT ADR
#ENDIF
;
#IF (CHCNT >= 2)
CH_CFG1:	; DEVICE 1
	.DB	1			; DEV NUM
	.DB	CHTYP_NONE		; DEV TYPE, FILLED DYNCAMICALLY
	.DB	CH1BASE			; IO BASE ADDRESS
	.DB	CH1USBENABLE		; ENABLE USB SUB-DRIVER
	.DW	CHUSB_CFG1		; USB SUB-DRIVER INIT ADR
	.DB	CH1SDENABLE		; ENABLE SD CARD SUB-DRIVER
	.DW	CHSD_CFG1		; SD CARD SUB-DRIVER INIT ADR
#ENDIF
;
#IF ($ - CH_CFGTBL) != (CHCNT * CH_CFGSIZ)
	.ECHO	"*** INVALID CH CONFIG TABLE ***\n"
#ENDIF
;
	.DB	$FF			; END OF TABLE MARKER
;
; GLOBAL CH37X INITIALIZATION
;
CH_INIT:
	LD	IY,CH_CFGTBL		; POINT TO START OF CONFIG TABLE
;
CH_INIT1:
	LD	A,(IY)			; LOAD FIRST BYTE TO CHECK FOR END
	CP	$FF			; CHECK FOR END OF TABLE VALUE
	JR	NZ,CH_INIT2		; IF NOT END OF TABLE, CONTINUE
	XOR	A			; SIGNAL SUCCESS
	RET				; AND RETURN
;
CH_INIT2:
	CALL	NEWLINE			; FORMATTING
	PRTS("CH$")			; LABEL FOR IO ADDRESS
	LD	A,(IY+CH_DEV)		; DEVICE NUMBER
	CALL	PRTDECB			; PRINT IT
	CALL	PC_COLON		; FORMATTING
;
	PRTS(" IO=0x$")			; LABEL FOR IO ADDRESS
	LD	A,(IY+CH_IOBASE)	; GET IO BASE ADDRES
	CALL	PRTHEXBYTE		; DISPLAY IT
;
	;CALL	CH_FLUSH		; FLUSH DEVICE OUTPUT QUEUE
	;CALL	CH_RESET		; FULL CH37X RESET
	CALL	CH_DETECT		; DETECT CHIP PRESENCE
	JR	Z,CH_INIT3		; GO AHEAD IF CHIP FOUND
	LD	DE,CH_STR_NOHW		; NOT PRESENT
	CALL	WRITESTR		; PRINT IT
	JR	CH_INIT4		; NEXT ENTRY
;
CH_INIT3:
	CALL	CH_GETVER		; GET VERSION BYTE
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
;
	LD	B,A			; SAVE IN REG B
	AND	$C0			; ISOLATE CHIP TYPE BITS
	LD	C,CHTYP_375		; ASSUME CH375
	LD	DE,CH_STR_375		; STRING FOR CH375
	CP	$80			; 375?
	JR	Z,CH_INIT3A		; IF SO, RECORD IT
	LD	C,CHTYP_376		; ASSUME CH376
	LD	DE,CH_STR_376		; STRING FOR CH376
	CP	$40			; 376?
	JR	Z,CH_INIT3A		; IF SO, RECORD IT
	PRTS(" VER ERR 0x$")		; SHOW VERSION ERROR
	LD	A,B			; GET VERSION BYTE BACK
	CALL	PRTHEXBYTE		; PRINT IT
	JR	CH_INIT4		; NEXT ENTRY
;
CH_INIT3A:
	LD	A,C			; CHIP TYPE TO ACCUM
	LD	(IY+CH_TYPE),A		; SAVE IT
	PRTS(" TYPE=$")			; TAG
	CALL	WRITESTR		; PRINT CHIP TYPE
	PRTS(" VER=0x$")		; LABEL FOR CHIP VERSION
	LD	A,B			; RECOVER VERSION BYTE
	AND	$3F			; ISOLATE VERSION BITS
	CALL	PRTHEXBYTE		; PRINT IT
;
	; USB SUB-DRIVER INIT
	LD	L,(IY+CH_USBCFG+0)	; LSB OF USB CFG ENTRY
	LD	H,(IY+CH_USBCFG+1)	; MSB OF USB CFG ENTRY
	LD	A,(IY+CH_USBENABLE)	; USB ENABLED?
	PUSH	IY			; SAVE IY
	OR	A			; SET FLAGS
	CALL	NZ,CHUSB_INIT		; IF SO, DO USB INIT
	POP	IY			; RESTORE IY
;
	; SD CARD SUB-DRIVER INIT
	LD	L,(IY+CH_SDCFG+0)	; LSB OF SD CFG ENTRY
	LD	H,(IY+CH_SDCFG+1)	; MSB OF SD CFG ENTRY
	LD	A,(IY+CH_SDENABLE)	; SD ENABLED?
	PUSH	IY			; SAVE IY
	OR	A			; SET FLAGS
	CALL	NZ,CHSD_INIT		; IF SO, DO SD INIT
	POP	IY			; RESTORE IY
;
CH_INIT4:
	LD	DE,CH_CFGSIZ		; SIZE OF CFG TABLE ENTRY
	ADD	IY,DE			; BUMP POINTER
	JP	CH_INIT1		; AND LOOP
;
; SEND COMMAND IN A
;
CH_CMD:
	LD	C,(IY+CH_IOBASE)	; BASE PORT
	INC	C			; BUMP TO CMD PORT
	OUT	(C),A			; SEND COMMAND
	CALL	CH_NAP			; *DEBUG*
	RET
;
; GET STATUS
;
CH_STAT:
	LD	C,(IY+CH_IOBASE)	; BASE PORT
	INC	C			; BUMP TO CMD PORT
	IN	A,(C)			; READ STATUS
	RET
;
; READ A BYTE FROM DATA PORT
;
CH_RD:
	LD	C,(IY+CH_IOBASE)	; BASE PORT
	IN	A,(C)			; READ BYTE
	RET
;
; WRITE A BYTE TO DATA PORT
;
CH_WR:
	LD	C,(IY+CH_IOBASE)	; BASE PORT
	OUT	(C),A			; READ BYTE
	RET
;
; SMALL DELAY REQUIRED AT STRATEGIC LOCATIONS
;
CH_NAP:
	;CALL	DELAY			; *DEBUG*
	;CALL	DELAY			; *DEBUG*
	;CALL	DELAY			; *DEBUG*
	JP	DELAY
;
; POLL WAITING FOR INTERRUPT
;
CH_POLL:
	PUSH	HL			; SAVE HL
	CALL	CH_NAP			; SMALL DELAY
	LD	HL,$8000		; POLL LOOP COUNTER
	LD	HL,0			; *DEBUG*
CH_POLL1:
	CALL	CH_STAT			; GET INT STATUS
	BIT	7,A			; CHECK BIT
	JR	Z,CH_POLL2		; IF ZERO, MOVE ON
	DEC	HL			; DECREMENT COUNTER
	LD	A,H			; CHECK
	OR	L			; ... LOOP COUNTER
	JR	NZ,CH_POLL1		; LOOP AS NEEDED
	;CALL	PC_ASTERISK		; *DEBUG*
	POP	HL			; RESTORE HL
	OR	$FF			; FLAG TIMEOUT
	RET				; AND RETURN
CH_POLL2:
	LD	A,CH_CMD_STAT		; GET STATUS
	CALL	CH_CMD			; SEND IT
	CALL	CH_NAP			; SMALL DELAY
	CALL	CH_RD			; GET RESULT
	POP	HL			; RESTORE HL
	RET				; AND RETURN
;
; SEND READ USB DATA COMMAND
; USING BEST OPCODE FOR DEVICE
;
CH_CMD_RD:
	LD	A,(IY+CH_TYPE)
	CP	CHTYP_375
	JR	NZ,CH_CMD_RD1
;
	; SEND CH375 READ USB DATA CMD
	LD	A,CH_CMD_RD5
	JP	CH_CMD
;
CH_CMD_RD1:
	; SEND CH376 READ USB DATA CMD
	LD	A,CH_CMD_RD6
	JP	CH_CMD
;
; SEND WRITE USB DATA COMMAND
; USING BEST OPCODE FOR DEVICE
;
CH_CMD_WR:
	LD	A,(IY+CH_TYPE)
	CP	CHTYP_375
	JR	NZ,CH_CMD_WR1
;
	; SEND CH375 WRITE USB DATA CMD
	LD	A,CH_CMD_WR5
	JP	CH_CMD
;
CH_CMD_WR1:
	; SEND CH376 WRITE USB DATA CMD
	LD	A,CH_CMD_WR6
	JP	CH_CMD
;
; PERFORM A FULL HARDWARE RESET ON CH37X
;
; WARNING: CH376 CAN TAKE A VERY LONG TIME TO PROCESS THIS
; COMMAND.  PROBABLY DON'T WANT TO USE THIS.
;
CH_RESET:
	;PRTS("\r\nHW RESET:$")		; *DEBUG*
	PUSH	DE
	LD	A,CH_CMD_RESET
	CALL	CH_CMD
	; DOC SAYS 40MS, BUT I FOUND THAT TO BE INSUFFICIENT
	;LD	DE,2500			; 16US * 2500 = 40MS
	LD	DE,10000		; 16US * 10000 = 160MS
	CALL	VDELAY
	;CALL	CH_RD			; *DEBUG*
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	POP	DE
	RET
;
; EMPTY THE CH37X OUTPUT QUEUE OF GARBAGE
;
CH_FLUSH:
	LD	B,$80
CH_FLUSH1:
	CALL	CH_RD
	DJNZ	CH_FLUSH1
	RET
;
;
;
CH_DETECT:
	;PRTS("\r\nDETECT:$")		; *DEBUG*
CH_DETECT1:
	LD	A,CH_CMD_EXIST		; LOAD COMMAND
	CALL	CH_CMD			; SEND COMMAND
	LD	A,$AA			; LOAD CHECK PATTERN
	CALL	CH_WR			; SEND IT
	CALL	CH_NAP			; SMALL DELAY
	CALL	CH_RD			; GET ECHO
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CP	$55			; SHOULD BE INVERTED
	RET				; RETURN
;
;
;
CH_GETVER:
	LD	A,CH_CMD_VER		; LOAD COMMAND
	CALL	CH_CMD			; SEND COMMAND
	CALL	CH_RD			; GET VERSION BYTE
	RET				; DONE
;
;
;
CH_STR_NOHW		.TEXT	" NOT PRESENT$"
CH_STR_UPGRADE		.TEXT	" !!!UPGRADE REQUIRED!!!$"
;
CH_STR_375		.TEXT	"CH375$"
CH_STR_376		.TEXT	"CH376$"
;
;==================================================================================================
; CH375/376 USB SUB-DRIVER
;==================================================================================================
;
; CHUSB DEVICE STATUS
;
CHUSB_STOK	.EQU	0
CHUSB_STNOMEDIA	.EQU	-1
CHUSB_STCMDERR	.EQU	-2
CHUSB_STIOERR	.EQU	-3
CHUSB_STTO	.EQU	-4
CHUSB_STNOTSUP	.EQU	-5
;
; CH DEVICE CONFIGURATION
;
CHUSB_CFGSIZ	.EQU	12		; SIZE OF USB CFG TBL ENTRIES
;
; CONFIG ENTRY DATA OFFSETS
;
; FIRST 3 BYTES SAME AS CH CONFIG
CHUSB_STAT	.EQU	3		; LAST STATUS (BYTE)
CHUSB_MEDCAP	.EQU	4		; MEDIA CAPACITY (DWORD)
CHUSB_LBA	.EQU	8		; CURRENT LBA (DWORD)
;
CHUSB_CFGTBL:
;
#IF (CHCNT >= 1)
CHUSB_CFG0:
	.DB	0			; DEV NUM, FILLED DYNAMICALLY
	.DB	CHTYP_NONE		; DEV TYPE, FILLED DYNCAMICALLY
	.DB	CH0BASE			; IO BASE ADDRESS
	.DB	0			; DEVICE STATUS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
#ENDIF
;
#IF (CHCNT >= 2)
CHUSB_CFG1:
	.DB	0			; DEV NUM
	.DB	CHTYP_NONE		; DEV TYPE, FILLED DYNCAMICALLY
	.DB	CH1BASE			; IO BASE ADDRESS
	.DB	0			; DEVICE STATUS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
#ENDIF
;
#IF ($ - CHUSB_CFGTBL) != (CHCNT * CHUSB_CFGSIZ)
	.ECHO	"*** INVALID CHUSB CONFIG TABLE ***\n"
#ENDIF
;
	.DB	$FF			; END OF TABLE MARKER
;
;
;
CHUSB_INIT:
	LD	A,(IY+CH_TYPE)		; GET DEVICE TYPE
	PUSH	HL			; COPY INCOMING HL
	POP	IY			; ... TO IY
	LD	(IY+CH_TYPE),A		; SAVE DEVICE TYPE
;
	; UPDATE DRIVER RELATIVE UNIT NUMBER IN CONFIG TABLE
	LD	A,(CHUSB_DEVNUM)	; GET NEXT UNIT NUM TO ASSIGN
	LD	(IY+CH_DEV),A		; UPDATE IT
	INC	A			; BUMP TO NEXT UNIT NUM TO ASSIGN
	LD	(CHUSB_DEVNUM),A	; SAVE IT
;
	; ADD UNIT TO GLOBAL DISK UNIT TABLE
	LD	BC,CHUSB_FNTBL		; BC := FUNC TABLE ADR
	PUSH	IY			; CFG ENTRY POINTER
	POP	DE			; COPY TO DE
	CALL	DIO_ADDENT		; ADD ENTRY TO GLOBAL DISK DEV TABLE
;
	CALL	CHUSB_RESET		; RESET & DISCOVER MEDIA
#IF (CHUSBTRACE <= 1)
	CALL	NZ,CHUSB_PRTSTAT
#ENDIF
	RET	NZ			; ABORT ON FAILURE
;
	; START PRINTING DEVICE INFO
	CALL	CHUSB_PRTPREFIX		; PRINT DEVICE PREFIX
;
	; PRINT STORAGE CAPACITY (BLOCK COUNT)
	PRTS(" BLOCKS=0x$")		; PRINT FIELD LABEL
	LD	A,CHUSB_MEDCAP		; OFFSET TO CAPACITY FIELD
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	LD32			; GET THE CAPACITY VALUE
	CALL	PRTHEX32		; PRINT HEX VALUE
;
	; PRINT STORAGE SIZE IN MB
	PRTS(" SIZE=$")			; PRINT FIELD LABEL
	LD	B,11			; 11 BIT SHIFT TO CONVERT BLOCKS --> MB
	CALL	SRL32			; RIGHT SHIFT
	CALL	PRTDEC32		; PRINT DWORD IN DECIMAL
	PRTS("MB$")			; PRINT SUFFIX
;
	XOR	A			; SIGNAL SUCCESS
	RET
;
; DRIVER FUNCTION TABLE
;
CHUSB_FNTBL:
	.DW	CHUSB_STATUS
	.DW	CHUSB_RESET
	.DW	CHUSB_SEEK
	.DW	CHUSB_READ
	.DW	CHUSB_WRITE
	.DW	CHUSB_VERIFY
	.DW	CHUSB_FORMAT
	.DW	CHUSB_DEVICE
	.DW	CHUSB_MEDIA
	.DW	CHUSB_DEFMED
	.DW	CHUSB_CAP
	.DW	CHUSB_GEOM
#IF (($ - CHUSB_FNTBL) != (DIO_FNCNT * 2))
	.ECHO	"*** INVALID CHUSB FUNCTION TABLE ***\n"
#ENDIF
;
CHUSB_VERIFY:
CHUSB_FORMAT:
CHUSB_DEFMED:
	SYSCHKERR(ERR_NOTIMPL)		; NOT IMPLEMENTED
	RET
;
;
;
CHUSB_READ:
	CALL	HB_DSKREAD		; HOOK HBIOS DISK READ SUPERVISOR
	LD	(CHUSB_DSKBUF),HL	; SAVE DISK BUFFER ADDRESS
	LD	A,CH_CMD_DSKRD		; DISK READ COMMAND
	CALL	CHUSB_RWSTART		; SEND CMD AND LBA
;
	; READ THE SECTOR IN 64 BYTE CHUNKS
	LD	B,8			; 8 CHUNKS OF 64 FOR 512 BYTE SECTOR
	LD	HL,(CHUSB_DSKBUF)	; GET DISK BUF ADR
CHUSB_READ1:
	CALL	CH_POLL			; WAIT FOR DATA READY
	CP	$1D			; DATA READY TO READ?
	;CALL	PC_LT			; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	JP	NZ,CHUSB_IOERR		; HANDLE IO ERROR
	CALL	CH_CMD_RD		; SEND READ USB DATA CMD
	CALL	CH_RD			; READ DATA BLOCK LENGTH
	CP	64			; AS EXPECTED?
	JP	NZ,CHUSB_IOERR		; IF NOT, HANDLE ERROR
;
#IF (CHUSB_FASTIO)
	; READ 64 BYTE CHUNK
	PUSH	BC			; SAVE LOOP CONTROL
	LD	B,64			; READ 64 BYTES
	LD	C,(IY+CH_IOBASE)	; BASE PORT
	INIR				; DO IT FAST
	POP	BC			; RESTORE LOOP CONTROL
#ELSE
	; BYTE READ LOOP
	PUSH	BC			; SAVE LOOP CONTROL
	LD	B,64			; READ 64 BYTES
CHUSB_READ2:
	CALL	CH_RD			; GET NEXT BYTE
	LD	(HL),A			; SAVE IT
	INC	HL			; INC BUF PTR
	DJNZ	CHUSB_READ2		; LOOP AS NEEDED
	POP	BC			; RESTORE LOOP CONTROL
#ENDIF
;
	; PREPARE FOR NEXT CHUNK
	LD	A,CH_CMD_DSKRDGO	; CONTINUE DISK READ
	CALL	CH_CMD			; SEND IT
	DJNZ	CHUSB_READ1		; LOOP TILL DONE
;
	; FINAL CHECK FOR COMPLETION & SUCCESS
	CALL	CH_POLL			; WAIT FOR COMPLETION
	CP	$14			; SUCCESS?
	JP	NZ,CHUSB_IOERR		; IF NOT, HANDLE ERROR
;
	; INCREMENT LBA
	PUSH	HL			; SAVE HL
	LD	A,CHUSB_LBA		; LBA OFFSET
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	INC32HL			; INCREMENT THE VALUE
	POP	HL			; RESTORE HL
;
	XOR	A			; SIGNAL SUCCESS
	RET
;
;
;
CHUSB_WRITE:
	CALL	HB_DSKWRITE		; HOOK HBIOS DISK WRITE SUPERVISOR
	LD	(CHUSB_DSKBUF),HL	; SAVE DISK BUFFER ADDRESS
	LD	A,CH_CMD_DSKWR		; DISK READ COMMAND
	CALL	CHUSB_RWSTART		; SEND CMD AND LBA
;
	; WRITE THE SECTOR IN 64 BYTE CHUNKS
	LD	B,8			; 8 CHUNKS OF 64 FOR 512 BYTE SECTOR
	LD	HL,(CHUSB_DSKBUF)	; GET DISK BUF ADR
CHUSB_WRITE1:
	CALL	CH_POLL			; WAIT FOR DATA READY
	CP	$1E			; DATA READY TO WRITE
	;CALL	PC_GT			; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	JP	NZ,CHUSB_IOERR		; HANDLE IO ERROR
	CALL	CH_CMD_WR		; SEND WRITE USB DATA CMD
	LD	A,64			; 64 BYTE CHUNK
	CALL	CH_WR			; SEND DATA BLOCK LENGTH
;
#IF (CHUSB_FASTIO)
	; WRITE 64 BYTE CHUNK
	PUSH	BC			; SAVE LOOP CONTROL
	LD	B,64			; WRITE 64 BYTES
	LD	C,(IY+CH_IOBASE)	; BASE PORT
	OTIR				; DO IT FAST
	POP	BC			; RESTORE LOOP CONTROL
#ELSE
	; BYTE WRITE LOOP
	PUSH	BC			; SAVE LOOP CONTROL
	LD	B,64			; WRITE 64 BYTES
CHUSB_WRITE2:
	LD	A,(HL)			; GET NEXT BYTE
	INC	HL			; INC BUF PTR
	CALL	CH_WR			; WRITE NEXT BYTE
	DJNZ	CHUSB_WRITE2		; LOOP AS NEEDED
	POP	BC			; RESTORE LOOP CONTROL
#ENDIF
;
	; PREPARE FOR NEXT CHUNK
	LD	A,CH_CMD_DSKWRGO	; CONTINUE DISK READ
	CALL	CH_CMD			; SEND IT
	DJNZ	CHUSB_WRITE1		; LOOP TILL DONE
;
	; FINAL CHECK FOR COMPLETION & SUCCESS
	CALL	CH_POLL			; WAIT FOR COMPLETION
	CP	$14			; SUCCESS?
	JP	NZ,CHUSB_IOERR		; IF NOT, HANDLE ERROR
;
	; INCREMENT LBA
	PUSH	HL			; SAVE HL
	LD	A,CHUSB_LBA		; LBA OFFSET
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	INC32HL			; INCREMENT THE VALUE
	POP	HL			; RESTORE HL
;
	XOR	A			; SIGNAL SUCCESS
	RET
;
; INITIATE A DISK SECTOR READ/WRITE OPERATION
; A: READ OR WRITE OPCODE
;
CHUSB_RWSTART:
	CALL	CH_CMD			; SEND R/W COMMAND
;
	; SEND LBA, 4 BYTES, LITTLE ENDIAN
	LD	A,CHUSB_LBA		; OFFSET TO CAPACITY FIELD
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	LD	B,4			; SEND 4 BYTES
CHUSB_RWSTART1:
	LD	A,(HL)			; GET BYTE
	INC	HL			; BUMP PTR
	CALL	CH_WR			; SEND BYTE
	DJNZ	CHUSB_RWSTART1		; LOOP AS NEEDED
;
	; REQUEST 1 SECTOR
	LD	A,1			; 1 SECTOR
	CALL	CH_WR			; SEND IT
	RET
;
;
;
CHUSB_STATUS:
	; RETURN UNIT STATUS
	LD	A,(IY+CHUSB_STAT)	; GET STATUS OF SELECTED DEVICE
	OR	A			; SET FLAGS
	RET				; AND RETURN
;
; RESET THE INTERFACE AND REDISCOVER MEDIA
;
CHUSB_RESET:
	;PRTS("\n\rRESET:$")		; *DEBUG*
	;CALL	CH_FLUSH		; DISCARD ANY GARBAGE
	;CALL	CH_RESET		; FULL CH37X RESET
;
	; RESET THE BUS
	LD	A,CH_CMD_MODE		; SET MODE COMMAND
	CALL	CH_CMD			; SEND IT
	LD	A,7			; RESET BUS
	CALL	CH_WR			; SEND IT
	CALL	CH_NAP			; SMALL WAIT
	CALL	CH_RD			; GET RESULT
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CALL	CH_NAP			; SMALL WAIT
;
	; ACTIVATE USB MODE
	LD	A,CH_CMD_MODE		; SET MODE COMMAND
	CALL	CH_CMD			; SEND IT
	LD	A,6			; USB ENABLED, SEND SOF
	CALL	CH_WR			; SEND IT
	CALL	CH_NAP			; SMALL WAIT
	CALL	CH_RD			; GET RESULT
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CALL	CH_NAP			; SMALL WAIT
;
	; INITIALIZE DISK
	LD	B,24			; TRY A FEW TIMES
CHUSB_RESET1:
	LD	A,CH_CMD_DSKINIT	; DISK INIT COMMAND
	CALL	CH_CMD			; SEND IT
	LD	DE,10000		; 10000 * 16 = 160MS ???
	CALL	VDELAY			; DELAY
	CALL	CH_POLL			; WAIT FOR RESULT
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CP	$14			; SUCCESS?
	JR	Z,CHUSB_RESET2		; IF SO, MOVE ON
	CP	$16			; NO MEDIA
	JP	Z,CHUSB_NOMEDIA		; HANDLE IT
	CALL	CH_NAP			; SMALL DELAY
	DJNZ	CHUSB_RESET1		; LOOP AS NEEDED
	JP	CHUSB_TO		; HANDLE TIMEOUT
;
CHUSB_RESET2:
	; USE OF CH376 DISK_MOUNT COMMAND SEEMS TO IMPROVE
	; COMPATIBILITY WITH SOME OLDER USB THUMBDRIVES.
	LD	A,(IY+CH_TYPE)		; CH37X TYPE?
	CP	CHTYP_376		; IS CH376?
	CALL	Z,CHUSB_DSKMNT		; IF SO, ISSUE MOUNT
	;CALL	CHUSB_AUTOSET		; *DEBUG*
;
	; GET AND STORE DISK CAPACITY
	;JP	CHUSB_RESET2D		; *DEBUG*
	;LD	A,(IY+CH_TYPE)		; GET DEVICE TYPE
	;CP	CHTYP_375
	;JR	CHUSB_RESET2A
	;CP	CHTYP_376
	;JR	CHUSB_RESET2B
	;JP	CHUSB_CMDERR
;
CHUSB_RESET2A:
	; CH375 DISK SIZE
	LD	A,CH_CMD_DSKSIZ		; DISK SIZE COMMAND
	CALL	CH_CMD			; SEND IT
	CALL	CH_POLL			; WAIT FOR RESULT
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CP	$14			; SUCCESS?
	;JP	NZ,CHUSB_CMDERR		; HANDLE CMD ERROR
	JR	NZ,CHUSB_RESET2D	; FAKE THE CAPACITY
	CALL	CH_CMD_RD		; SEND READ USB DATA CMD
	CALL	CH_RD			; GET RD DATA LEN
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CP	$08			; MAKE SURE IT IS 8
	JP	NZ,CHUSB_CMDERR		; HANDLE CMD ERROR
	LD	A,CHUSB_MEDCAP		; MEDIA CAPACITY OFFSET
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	PUSH	HL			; SAVE ADDRESS
	CALL	CH_RD
	LD	D,A
	CALL	CH_RD
	LD	E,A
	CALL	CH_RD
	LD	H,A
	CALL	CH_RD
	LD	L,A
	CALL	CH_RD
	CALL	CH_RD
	CALL	CH_RD
	CALL	CH_RD
	POP	BC			; RECOVER ADDRESS TO BC
	CALL	ST32			; STORE IT
	CALL	CH_FLUSH		; DISCARD REMAINING CHARS
	JR	CHUSB_RESET3		; CONTINUE
;
CHUSB_RESET2B:
	; CH376 DISK CAPACITY
	LD	A,CH_CMD_DSKCAP		; DISK CAPACITY COMMAND
	CALL	CH_CMD			; SEND IT
	CALL	CH_POLL			; WAIT FOR RESULT
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CP	$14			; SUCCESS?
	;JP	NZ,CHUSB_CMDERR		; HANDLE CMD ERROR
	JR	NZ,CHUSB_RESET2D	; FAKE THE CAPACITY
	CALL	CH_CMD_RD		; SEND USB READ DATA
	CALL	CH_RD			; GET RD DATA LEN
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CP	$04			; MAKE SURE IT IS 8
	JP	NZ,CHUSB_CMDERR		; HANDLE CMD ERROR
	LD	A,CHUSB_MEDCAP		; MEDIA CAPACITY OFFSET
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	CH_RD
	LD	B,4			; 4 BYTES
CHUSB_RESET2C:
	LD	(HL),A
	INC	HL
	CALL	CH_RD
	DJNZ	CHUSB_RESET2C
	JR	CHUSB_RESET3		; CONTINUE
;
CHUSB_RESET2D:
	; OLDER USB STICKS SEEM TO FAIL (PRIMARILY ON CH375).
	; FAILURE TO GET A DISK CAPACITY SHOULD NOT PREVENT THE
	; USE OF THE DISK.  SO, WE PUNT, AND JUST PLUG IN 1GB.
	LD	A,CHUSB_MEDCAP		; MEDIA CAPACITY OFFSET
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	PUSH	HL			; SAVE POINTER
	LD	DE,$0020		; 1GB IS $20000 SECTORS
	LD	HL,$0000
	POP	BC			; RECOVER POINTER
	CALL	ST32			; SAVE FAKE CAPACITY
	; FALL THRU
;
CHUSB_RESET3:
	;CALL	CHUSB_DSKRDY		; *DEBUG*
	;CALL	CHUSB_DSKINQ		; *DEBUG*
;
	; SET STATUS AND RETURN
	XOR	A			; CLEAR STATUS
	LD	(IY+CHUSB_STAT),A	; RECORD STATUS
	OR	A			; SET FLAGS
	RET				; AND RETURN
;
;
;
CHUSB_DEVICE:
	LD	D,DIODEV_CHUSB		; D := DEVICE TYPE
	LD	E,(IY+CH_DEV)		; E := PHYSICAL DEVICE NUMBER
	LD	C,%01110011		; USB HARD DISK ATTRIBUTES
	LD	H,(IY+CH_TYPE)		; H := MODE
	LD	L,(IY+CH_IOBASE)	; L := BASE I/O ADDRESS
	XOR	A			; SIGNAL SUCCESS
	RET
;
; CHUSB_GETMED
;
CHUSB_MEDIA:
	LD	A,E			; GET FLAGS
	OR	A			; SET FLAGS
	JR	Z,CHUSB_MEDIA1		; JUST REPORT CURRENT STATUS AND MEDIA
	CALL	CHUSB_RESET		; RESET CHUSB INTERFACE
;
CHUSB_MEDIA1:
	LD	A,(IY+CHUSB_STAT)	; GET STATUS
	OR	A			; SET FLAGS
	LD	D,0			; NO MEDIA CHANGE DETECTED
	LD	E,MID_HD		; ASSUME WE ARE OK
	RET	Z			; RETURN IF GOOD INIT
	LD	E,MID_NONE		; SIGNAL NO MEDIA
	LD	A,ERR_NOMEDIA		; NO MEDIA ERROR
	OR	A			; SET FLAGS
	RET				; AND RETURN
;
;
;
CHUSB_SEEK:
	BIT	7,D			; CHECK FOR LBA FLAG
	CALL	Z,HB_CHS2LBA		; CLEAR MEANS CHS, CONVERT TO LBA
	RES	7,D			; CLEAR FLAG REGARDLESS (DOES NO HARM IF ALREADY LBA)
	LD	(IY+CHUSB_LBA+0),L	; SAVE NEW LBA
	LD	(IY+CHUSB_LBA+1),H	; ...
	LD	(IY+CHUSB_LBA+2),E	; ...
	LD	(IY+CHUSB_LBA+3),D	; ...
	XOR	A			; SIGNAL SUCCESS
	RET				; AND RETURN
;
;
;
CHUSB_CAP:
	LD	A,(IY+CHUSB_STAT)	; GET STATUS
	PUSH	AF			; SAVE IT
	LD	A,CHUSB_MEDCAP		; OFFSET TO CAPACITY FIELD
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	LD32			; GET THE CURRENT CAPACITY INTO DE:HL
	LD	BC,512			; 512 BYTES PER BLOCK
	POP	AF			; RECOVER STATUS
	OR	A			; SET FLAGS
	RET
;
;
;
CHUSB_GEOM:
	; FOR LBA, WE SIMULATE CHS ACCESS USING 16 HEADS AND 16 SECTORS
	; RETURN HS:CC -> DE:HL, SET HIGH BIT OF D TO INDICATE LBA CAPABLE
	CALL	CHUSB_CAP		; GET TOTAL BLOCKS IN DE:HL, BLOCK SIZE TO BC
	LD	L,H			; DIVIDE BY 256 FOR # TRACKS
	LD	H,E			; ... HIGH BYTE DISCARDED, RESULT IN HL
	LD	D,16 | $80		; HEADS / CYL = 16, SET LBA CAPABILITY BIT
	LD	E,16			; SECTORS / TRACK = 16
	RET				; DONE, A STILL HAS CHUSB_CAP STATUS
;
; CH37X HELPER ROUTINES
;
;
; PERFORM DISK INQUIRY
; BASICALLY THE SCSI INQUIRY COMMAND
;
CHUSB_DSKINQ:
	;PRTS("\n\rINQUIRY:$")		; *DEBUG*
	LD	A,CH_CMD_DSKINQ		; DISK QUERY
	CALL	CH_CMD			; DO IT
	CALL	CH_POLL			; WAIT FOR RESPONSE
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CP	$14			; SUCCESS?
	RET	NZ			; ABORT IF NOT
	CALL	CH_CMD_RD		; SEND READ COMMAND
	CALL	CH_RD			; GET LENGTH
	LD	B,A			; LOOP COUNTER
	LD	HL,HB_WRKBUF		; USE WORK BUFFER FOR DATA
DSKINQ1:
	CALL	CH_RD			; GET A BYTE
	LD	(HL),A			; SAVE IT
	INC	HL			; BUMP BUF PTR
	DJNZ	DSKINQ1			; LOOP FOR ALL DATA
;
	;LD	DE,HB_WRKBUF		; *DEBUG*
	;CALL	DUMP_BUFFER		; *DEBUG*
;
	;CALL	CHUSB_PRTPREFIX		; PRINT DEVICE PREFIX
	;LD	HL,HB_WRKBUF + 8
	;LD	B,28
DSKINQ2:
	;LD	A,(HL)
	;INC	HL
	;CALL	COUT
	;DJNZ	DSKINQ2
;
	RET
;
; PERFORM DISK MOUNT
;
CHUSB_DSKMNT:
	;PRTS("\n\rMOUNT:$")		; *DEBUG*
	LD	A,CH_CMD_DSKMNT		; DISK QUERY
	CALL	CH_CMD			; DO IT
	CALL	CH_POLL			; WAIT FOR RESPONSE
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
	CP	$14			; SUCCESS?
	RET	NZ			; ABORT IF NOT
	CALL	CH_CMD_RD		; SEND READ COMMAND
	CALL	CH_RD			; GET LENGTH
	LD	B,A			; LOOP COUNTER
	LD	HL,HB_WRKBUF		; USE WORK BUFFER FOR DATA
DSKMNT1:
	CALL	CH_RD			; GET A BYTE
	LD	(HL),A			; SAVE IT
	INC	HL			; BUMP BUF PTR
	DJNZ	DSKMNT1			; LOOP FOR ALL DATA
;
	;LD	DE,HB_WRKBUF		; *DEBUG*
	;CALL	DUMP_BUFFER		; *DEBUG*
;
	;CALL	CHUSB_PRTPREFIX		; PRINT DEVICE PREFIX
	;LD	HL,HB_WRKBUF + 8
	;LD	B,28
DSKMNT2:
	;LD	A,(HL)
	;INC	HL
	;CALL	COUT
	;DJNZ	DSKMNT2
;
	RET
;
; PERFORM DISK READY
;
CHUSB_DSKRDY:
	;PRTS("\n\rREADY:$")		; *DEBUG*
	LD	A,CH_CMD_DSKRDY		; DISK READY
	CALL	CH_CMD			; DO IT
	CALL	CH_POLL			; WAIT FOR RESPONSE
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
;
	RET
;
; PERFORM AUTO SETUP
;
CHUSB_AUTOSET:
	;PRTS("\n\rAUTOSET:$")		; *DEBUG*
	LD	A,CH_CMD_AUTOSET	; AUTOMATIC SETUP FOR USB
	CALL	CH_CMD			; DO IT
	CALL	CH_POLL			; WAIT FOR RESPONSE
	;CALL	PC_SPACE		; *DEBUG*
	;CALL	PRTHEXBYTE		; *DEBUG*
;
	RET
;
; ERROR HANDLERS
;
;
CHUSB_NOMEDIA:
	LD	A,CHUSB_STNOMEDIA
	JR	CHUSB_ERR
;
CHUSB_CMDERR:
	LD	A,CHUSB_STCMDERR
	JR	CHUSB_ERR
;
CHUSB_IOERR:
	LD	A,CHUSB_STIOERR
	JR	CHUSB_ERR
;
CHUSB_TO:
	LD	A,CHUSB_STTO
	JR	CHUSB_ERR
;
CHUSB_NOTSUP:
	LD	A,CHUSB_STNOTSUP
	JR	CHUSB_ERR
;
CHUSB_ERR:
	LD	(IY+CHUSB_STAT),A	; SAVE NEW STATUS
;
CHUSB_ERR2:
#IF (CHUSBTRACE >= 2)
	CALL	CHUSB_PRTSTAT
#ENDIF
	OR	A			; SET FLAGS
	RET
;
;
;
CHUSB_PRTERR:
	RET	Z			; DONE IF NO ERRORS
	; FALL THRU TO CHUSB_PRTSTAT
;
; PRINT FULL DEVICE STATUS LINE
;
CHUSB_PRTSTAT:
	PUSH	AF
	PUSH	DE
	PUSH	HL
	LD	A,(IY+CHUSB_STAT)
	CALL	CHUSB_PRTPREFIX		; PRINT UNIT PREFIX
	CALL	PC_SPACE		; FORMATTING
	CALL	CHUSB_PRTSTATSTR
	POP	HL
	POP	DE
	POP	AF
	RET
;
; PRINT STATUS STRING
;
CHUSB_PRTSTATSTR:
	PUSH	AF
	PUSH	DE
	PUSH	HL
	LD	A,(IY+CHUSB_STAT)
	NEG
	LD	HL,CHUSB_STR_ST_MAP
	ADD	A,A
	CALL	ADDHLA
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	CALL	WRITESTR
	POP	HL
	POP	DE
	POP	AF
	RET
;
; PRINT DIAGNONSTIC PREFIX
;
CHUSB_PRTPREFIX:
	PUSH	AF
	CALL	NEWLINE
	PRTS("CHUSB$")
	LD	A,(IY+CH_DEV)		; GET CURRENT DEVICE NUM
	CALL	PRTDECB
	CALL	PC_COLON
	POP	AF
	RET
;
; DATA STORAGE
;
CHUSB_DEVNUM	.DB	0		; TEMP DEVICE NUM USED DURING INIT
CHUSB_DSKBUF	.DW	0
;
CHUSB_STR_ST_MAP:
	.DW		CHUSB_STR_STOK
	.DW		CHUSB_STR_STNOMEDIA
	.DW		CHUSB_STR_STCMDERR
	.DW		CHUSB_STR_STIOERR
	.DW		CHUSB_STR_STTO
	.DW		CHUSB_STR_STNOTSUP
;
CHUSB_STR_STOK		.TEXT	"OK$"
CHUSB_STR_STNOMEDIA	.TEXT	"NO MEDIA$"
CHUSB_STR_STCMDERR	.TEXT	"COMMAND ERROR$"
CHUSB_STR_STIOERR		.TEXT	"IO ERROR$"
CHUSB_STR_STTO		.TEXT	"TIMEOUT$"
CHUSB_STR_STNOTSUP	.TEXT	"NOT SUPPORTED$"
CHUSB_STR_STUNK		.TEXT	"UNKNOWN ERROR$"

;
;==================================================================================================
; CH375/376 SD CARD SUB-DRIVER
;==================================================================================================
;
; CH DEVICE CONFIGURATION
;
CHSD_CFGSIZ	.EQU	12		; SIZE OF USB CFG TBL ENTRIES
;
; CONFIG ENTRY DATA OFFSETS
;
; FIRST 3 BYTES SAME AS CH CONFIG
CHSD_STAT	.EQU	3		; LAST STATUS (BYTE)
CHSD_MEDCAP	.EQU	4		; MEDIA CAPACITY (DWORD)
CHSD_LBA	.EQU	8		; CURRENT LBA (DWORD)
;
CHSD_CFGTBL:
;
#IF (CHCNT >= 1)
CHSD_CFG0:
	.DB	0			; DEV NUM, FILLED DYNAMICALLY
	.DB	CHTYP_NONE		; DEV TYPE, FILLED DYNCAMICALLY
	.DB	CH0BASE			; IO BASE ADDRESS
	.DB	0			; DEVICE STATUS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
#ENDIF
;
#IF (CHCNT >= 2)
CHSD_CFG1:
	.DB	0			; DEV NUM
	.DB	CHTYP_NONE		; DEV TYPE, FILLED DYNCAMICALLY
	.DB	CH1BASE			; IO BASE ADDRESS
	.DB	0			; DEVICE STATUS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
#ENDIF
;
#IF ($ - CHSD_CFGTBL) != (CHCNT * CHSD_CFGSIZ)
	.ECHO	"*** INVALID CHSD CONFIG TABLE ***\n"
#ENDIF
;
	.DB	$FF			; END OF TABLE MARKER
;
;
;
CHSD_INIT:
	LD	A,(IY+CH_TYPE)		; GET DEVICE TYPE
	PUSH	HL			; COPY INCOMING HL
	POP	IY			; ... TO IY
	LD	(IY+CH_TYPE),A		; SAVE DEVICE TYPE
;
	; UPDATE DRIVER RELATIVE UNIT NUMBER IN CONFIG TABLE
	LD	A,(CHSD_DEVNUM)		; GET NEXT UNIT NUM TO ASSIGN
	LD	(IY+CH_DEV),A		; UPDATE IT
	INC	A			; BUMP TO NEXT UNIT NUM TO ASSIGN
	LD	(CHSD_DEVNUM),A		; SAVE IT
;
	CALL	NEWLINE			; FORMATTING
	PRTS("CHSD$")			; LABEL FOR IO ADDRESS
	LD	A,(IY+CH_DEV)		; GET DEVICE NUM
	CALL	PRTDECB			; PRINT IT
	CALL	PC_COLON		; FORMATTING
;
	RET


CHSD_DEVNUM	.DB	0		; TEMP DEVICE NUM USED DURING INIT





;
;=============================================================================
; DATA STORAGE
;=============================================================================
;
CH_FWVER		.DW	0,0	; MMNNBBB (M=MAJOR, N=MINOR, B=BUILD)
;
CHSD_IOFNADR		.DW	0	; PENDING IO FUNCTION ADDRESS
;
CHSD_DSKBUF		.DW	0
;
CHSD_DSKSTAT		.DB	0
CHSD_ERRCODE		.DW	0,0
CHSD_CSDBUF		.FILL	16,0
;
CHSD_CMD		.DB	0
;
CHSD_TIMEOUT		.DW	$0000	; FIX: MAKE THIS CPU SPEED RELATIVE
